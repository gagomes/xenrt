diff -ru python2.7-2.7.3/Grammar/Grammar dython/Grammar/Grammar
--- python2.7-2.7.3/Grammar/Grammar	2012-04-09 19:07:29.000000000 -0400
+++ dython/Grammar/Grammar	2013-07-29 06:23:00.825132939 -0400
@@ -43,11 +43,14 @@
                       '>>' test [ (',' test)+ [','] ] )
 del_stmt: 'del' exprlist
 pass_stmt: 'pass'
-flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
+flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt | cont_stmt | auto_stmt | until_stmt
 break_stmt: 'break'
 continue_stmt: 'continue'
 return_stmt: 'return' [testlist]
 yield_stmt: yield_expr
+cont_stmt: 'xenrtdebugger_breakpoint' [test]
+auto_stmt: 'xenrtdebugger_errormarker' 
+until_stmt: 'xenrtdebugger_silentbreakpoint'
 raise_stmt: 'raise' [test [',' test [',' test]]]
 import_stmt: import_name | import_from
 import_name: 'import' dotted_as_names
@@ -62,10 +65,11 @@
 exec_stmt: 'exec' expr ['in' test [',' test]]
 assert_stmt: 'assert' test [',' test]
 
-compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
+compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | br_stmt
 if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
 while_stmt: 'while' test ':' suite ['else' ':' suite]
 for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
+br_stmt: 'xenrtdebugger_iteratebreakpoint' exprlist 'in' testlist ':' suite
 try_stmt: ('try' ':' suite
            ((except_clause ':' suite)+
             ['else' ':' suite]
diff -ru python2.7-2.7.3/Parser/Python.asdl dython/Parser/Python.asdl
--- python2.7-2.7.3/Parser/Python.asdl	2012-04-09 19:07:35.000000000 -0400
+++ dython/Parser/Python.asdl	2013-07-29 06:23:08.449123953 -0400
@@ -23,6 +23,7 @@
 
 	      -- use 'orelse' because else is a keyword in target languages
 	      | For(expr target, expr iter, stmt* body, stmt* orelse)
+              | Br(expr target, expr iter, stmt* body)
 	      | While(expr test, stmt* body, stmt* orelse)
 	      | If(expr test, stmt* body, stmt* orelse)
 	      | With(expr context_expr, expr? optional_vars, stmt* body)
@@ -32,6 +33,7 @@
 	      | TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)
 	      | TryFinally(stmt* body, stmt* finalbody)
 	      | Assert(expr test, expr? msg)
+              | Cont(expr test)
 
 	      | Import(alias* names)
 	      | ImportFrom(identifier? module, alias* names, int? level)
@@ -44,6 +46,9 @@
 	      | Global(identifier* names)
 	      | Expr(expr value)
 	      | Pass | Break | Continue
+              | Auto
+              | Until
+
 
 	      -- XXX Jython will be different
 	      -- col_offset is the byte offset in the utf8 string the parser uses
diff -ru python2.7-2.7.3/Python/ast.c dython/Python/ast.c
--- python2.7-2.7.3/Python/ast.c	2012-04-09 19:07:35.000000000 -0400
+++ dython/Python/ast.c	2013-07-29 06:23:21.309118679 -0400
@@ -2356,6 +2356,17 @@
             return Break(LINENO(n), n->n_col_offset, c->c_arena);
         case continue_stmt:
             return Continue(LINENO(n), n->n_col_offset, c->c_arena);
+        case cont_stmt:
+            if (NCH(ch) == 1)
+                  return Cont(NULL, LINENO(n), n->n_col_offset, c->c_arena);
+            else if (NCH(ch) == 2){
+                  expr_ty expression = ast_for_expr(c, CHILD(ch, 1));
+                  return Cont(expression, LINENO(n),n->n_col_offset, c->c_arena);
+            }
+        case until_stmt:
+            return Until(LINENO(n),n->n_col_offset, c->c_arena);
+        case auto_stmt:
+            return Auto(LINENO(n),n->n_col_offset, c->c_arena);
         case yield_stmt: { /* will reduce to yield_expr */
             expr_ty exp = ast_for_expr(c, CHILD(ch, 0));
             if (!exp)
@@ -2987,6 +2998,39 @@
                c->c_arena);
 }
 
+static stmt_ty
+ast_for_br_stmt(struct compiling *c, const node *n)
+{
+    asdl_seq *_target, *seq = NULL, *suite_seq;
+    expr_ty expression;
+    expr_ty target;
+    const node *node_target;
+    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */
+    REQ(n, br_stmt);
+
+
+    node_target = CHILD(n, 1);
+    _target = ast_for_exprlist(c, node_target, Store);
+    if (!_target)
+        return NULL;
+    /* Check the # of children rather than the length of _target, since
+       for x, in ... has 1 element in _target, but still requires a Tuple. */
+    if (NCH(node_target) == 1)
+        target = (expr_ty)asdl_seq_GET(_target, 0);
+    else
+        target = Tuple(_target, Store, LINENO(n), n->n_col_offset, c->c_arena);
+
+    expression = ast_for_testlist(c, CHILD(n, 3));
+    if (!expression)
+        return NULL;
+    suite_seq = ast_for_suite(c, CHILD(n, 5));
+    if (!suite_seq)
+        return NULL;
+
+    return Br(target, expression, suite_seq, LINENO(n), n->n_col_offset,
+               c->c_arena);
+}
+
 static excepthandler_ty
 ast_for_except_clause(struct compiling *c, const node *exc, node *body)
 {
@@ -3284,6 +3328,8 @@
                 return ast_for_while_stmt(c, ch);
             case for_stmt:
                 return ast_for_for_stmt(c, ch);
+            case br_stmt: 
+                return ast_for_br_stmt(c, ch);
             case try_stmt:
                 return ast_for_try_stmt(c, ch);
             case with_stmt:
diff -ru python2.7-2.7.3/Python/compile.c dython/Python/compile.c
--- python2.7-2.7.3/Python/compile.c	2012-04-09 19:07:35.000000000 -0400
+++ dython/Python/compile.c	2013-07-29 06:23:30.289120484 -0400
@@ -1621,6 +1621,36 @@
     compiler_use_next_block(c, end);
     return 1;
 }
+static int
+compiler_br(struct compiler *c, stmt_ty s)
+{
+        basicblock *start, *cleanup, *end;
+
+        start = compiler_new_block(c);
+        cleanup = compiler_new_block(c);
+        end = compiler_new_block(c);
+        if (start == NULL || end == NULL || cleanup == NULL)
+                return 0;
+        ADDOP_JREL(c, SETUP_LOOP, end);
+        if (!compiler_push_fblock(c, LOOP, start))
+                return 0;
+        VISIT(c, expr, s->v.Br.iter);
+        ADDOP(c, GET_ITER);
+        compiler_use_next_block(c, start);
+        /* for expressions must be traced on each iteration,
+           so we need to set an extra line number. */
+        c->u->u_lineno_set = false;
+        ADDOP_JREL(c, FOR_ITER, cleanup);
+        VISIT(c, expr, s->v.Br.target);
+        VISIT_SEQ(c, stmt, s->v.Br.body);
+        ADDOP_JABS(c, JUMP_ABSOLUTE, start);
+        compiler_use_next_block(c, cleanup);
+        ADDOP(c, POP_BLOCK);
+        compiler_pop_fblock(c, LOOP, start);
+//      VISIT_SEQ(c, stmt, s->v.For.orelse);
+        compiler_use_next_block(c, end);
+        return 1;
+}
 
 static int
 compiler_for(struct compiler *c, stmt_ty s)
@@ -2129,6 +2159,8 @@
         return compiler_print(c, s);
     case For_kind:
         return compiler_for(c, s);
+    case Br_kind:
+        return compiler_br(c,s);
     case While_kind:
         return compiler_while(c, s);
     case If_kind:
diff -ru python2.7-2.7.3/Python/symtable.c dython/Python/symtable.c
--- python2.7-2.7.3/Python/symtable.c	2012-04-09 19:07:35.000000000 -0400
+++ dython/Python/symtable.c	2013-07-29 06:23:39.589117406 -0400
@@ -1068,6 +1068,11 @@
         if (s->v.For.orelse)
             VISIT_SEQ(st, stmt, s->v.For.orelse);
         break;
+    case Br_kind:
+        VISIT(st,expr,s->v.Br.target);
+        VISIT(st,expr,s->v.Br.iter);
+        VISIT_SEQ(st,stmt,s->v.Br.body);
+        break;
     case While_kind:
         VISIT(st, expr, s->v.While.test);
         VISIT_SEQ(st, stmt, s->v.While.body);
@@ -1164,6 +1169,9 @@
         break;
     case Pass_kind:
     case Break_kind:
+    case Cont_kind:
+    case Auto_kind:
+    case Until_kind:
     case Continue_kind:
         /* nothing to do here */
         break;
