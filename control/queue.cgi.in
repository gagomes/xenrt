#!/usr/bin/python
#
# XenRT job control CGI script.
#
# (C) XenSource UK Ltd. November 2005
# James Bulpin

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
import sys, string, time, os, traceback, cgi, os.path, urllib, tempfile, re
import smtplib, atexit, xml.dom.minidom, shutil, urlparse, sets
import pgdb
import time
import random, math
import glob


#############################################################################
# Configuration                                                             #
#############################################################################

_sharedir = "@sharedir@"
_confdir = "@confdir@"
_masterurl = "@masterurl@"

# We need to import some XenRT modules for Jira stuff
# These have to be inserted at the beginning or we find the xenrt.py in the
# control dir instead of the xenrt in sharedir...
sys.path.insert(0,"%s/exec" % (_sharedir))
sys.path.insert(1,"%s/exec/xenrt" % (_sharedir))
sys.path.insert(2,"%s/lib" % (_sharedir))

for p in glob.glob("%s/lib/*egg" % (_sharedir)):
    if os.path.exists(p):
        sys.path.append(p)

maxloss    = 0.10

smtp_server = None
email_sender = None

netdata = os.popen("/sbin/ip addr show dev eth0").read()
r = re.search(r"inet ([0-9\.]+)", netdata)
if r:
    addr = r.group(1)
else:
    addr = "127.0.0.1"

url_base = "http://%s/share/control/" % (addr)

core_params = ["VERSION","REVISION","OPTIONS","USERID","UPLOADED","REMOVED","JOBSTATUS","JOBID"]

basedir    = "%s/control" % (_sharedir)
connectstring = "localhost:xenrt"

# Parse a site config file
cf = "%s/site.xml" % (_confdir)
if os.path.exists(cf):
    dom = xml.dom.minidom.parse(cf)
    for i in dom.childNodes:
        if i.nodeType == i.ELEMENT_NODE:
            if i.localName == "xenrt":
                for var in i.childNodes:
                    if var.nodeType == var.ELEMENT_NODE:
                        for t in var.childNodes:
                            if t.nodeType == t.TEXT_NODE and t.data and \
                                   string.strip(t.data) != "":
                                data = string.strip(str(t.data))
                                name = str(var.localName)
                                if name == "SMTP_SERVER":
                                    smtp_server = data
                                elif name == "SMTP_SENDER":
                                    email_sender = data
                                elif name == "CGI_URL_BASE":
                                    url_base = data
                                elif name == "JOBSCHED_BASE_DIR":
                                    basedir = data
                                elif name == "DATABASE_CONNECT_STRING":
                                    connectstring = data

results    = basedir + "/results"

idfile     = basedir + "/id.dat"
norun      = basedir + "/norun"
logfile    = basedir + "/operation.log"

mutex = None
mutex_held = 0

colours = {"pass":       ("green", None, "#90c040"),
           "fail":       ("orange", None, None),
           "vmcrash":    ("red", None, None),
           "xencrash":   ("black", "white", None),
           "started":    ("#ccff99", None, None),
           "running":    ("#ccff99", None, None),
           "skipped":    ("#FFFFFF", None, None),
           "partial":    ("#96FF00", None, None),
           "error":      ("#667FFF", None, None),
           "other":      ("#CCCCCC", None, None),
           "paused":     ("#FF80FF", None, None),
           "continuing": ("#ccff99", None, None),
           "pass/w":     ("#F5FF80", None, "#90c040"),
           "fail/w":     ("orange", None, None),
           "vmcrash/w":  ("red", None, None),
           "xencrash/w": ("black", "white", None),
           "started/w":  ("#ccff99", None, None),
           "skipped/w":  ("#FFFFFF", None, None),
           "partial/w":  ("#96FF00", None, None),
           "error/w":    ("#667FFF", None, None),
           "other/w":    ("#CCCCCC", None, None),
           "paused/w":   ("#FF80FF", None, None),
           "continuing/w": ("#ccff99", None, None),
           "OK":         ("green", None, "#90c040"),
           "ERROR":      ("red", None, None),
           }

schedulercache = {"siteprops" : {}, "machineprops": {}, "siteresources" : {}}

#############################################################################
# Database connection                                                       #
#############################################################################

try:
    db = pgdb.connect(connectstring)
except:
    db = None

def close_db():
    if db:
        db.close()
    if mutex:
        mutex.close()

atexit.register(close_db)

def results_filename(prefix, id, find=0, mkdir=0):
    global results
    # Before started using subdirectories...
    old_style = "%s/%s%08u" % (results, prefix, id)
    # And afterwards...
    if prefix == "":
        sprefix = "job"
    else:
        sprefix = prefix
    new_style = "%s/%s/%02u/%02u/%02u/%s%08u" % \
                (results, sprefix, (id/1000000)%100, (id/10000)%100,
                 (id/100)%100, prefix, id)
    if mkdir:
        dirname = os.path.dirname(new_style)
        if not os.path.exists(dirname):
            os.makedirs(dirname)
    if find:
        if os.path.exists(old_style):
            return old_style
        return new_style
    return new_style

def colour_style(colour, rswarn=0):
    global colours
    if not colours.has_key(colour):
        colour = "other"
    fg, bg, warn = colours[colour]
    if rswarn and warn:
        fg = warn
    if fg:
        reply = "background-color: %s;" % (fg)
    else:
        reply = ""
    if bg:
        reply = reply + " color: %s;" % (bg)
    return reply

def colour_tag(colour):
    global colours
    if not colours.has_key(colour):
        colour = "other"
    fg, bg, warn = colours[colour]
    if fg:
        reply = "bgcolor=\"%s\"" % (fg)
    else:
        reply = ""
    if bg:
        reply = reply + " color=\"%s\"" % (bg)
    return reply

def normalise(i):
    """
    Takes a number i, which may have a modifier of k, M, G or T and
    returns the number with the modifier applied.
    """
    
    number = 0
    multiplier = ''
    
    # Extract number part.
    number = long(re.match('[0-9]+', i).group())	
    
    # Extract modifier.
    multiplier = string.upper(re.search('[kKMGT]?$', i).group())
    
    # Normalise number.
    if multiplier == 'K':
        return number * 1024			
    elif multiplier == 'M':
        return number * 1024 * 1024
    elif multiplier == 'G':
        return number * 1024 * 1024 * 1024
    elif multiplier == 'T':
        return number * 1024 * 1024 * 1024 * 1024
    return number

# Send an email message
# toaddrs = is a list of email addresses
def send_mail(fromaddr, toaddrs, subject, message, reply=None):
    if not smtp_server:
        return
    now = time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime())
    msg = ("Date: %s\r\nFrom: %s\r\nTo: %s\r\nSubject: %s\r\n"
           % (now, fromaddr, ", ".join(toaddrs), subject))
    if reply:
        msg = msg + "Reply-To: %s\r\n" % (reply)
    msg = msg + "\r\n" + message

    server = smtplib.SMTP(smtp_server)
    #server.set_debuglevel(1)
    server.sendmail(fromaddr, toaddrs, msg)
    server.quit()

def pretty_print_utilisation(ts):
    days = int(ts / 86400)
    ts -= (days * 86400)
    hours = int(ts / 3600)
    ts -= (hours * 3600)
    mins = int(ts / 60)
    ts -= (mins * 60)
    if days:
        if days > 1:
            return "%u days %02u:%02u:%02u" % (days,hours,mins,ts)
        else:
            return "%u day %02u:%02u:%02u" % (days,hours,mins,ts)
    else:
        return "%02u:%02u:%02u" % (hours,mins,ts)

#####
# Logging
logdata = {}
logdata['pid'] = "%u" % (os.getpid())

log_fields = [ 'timestamp', 'JOBID', 'USERID', 'MACHINE', 'action', 'pid' ]

def log(logkey, logvalue):
    global logdata
    logdata[logkey] = logvalue

def log_emit():
    global logdata, logfile, log_fields
    try:
        lf = file(logfile, 'a')
        logdata['timestamp'] = time.strftime("[%X %x %Z]", time.localtime())
        ll = []
        for s in log_fields:
            if logdata.has_key(s):
                ll.append(logdata[s])
            else:
                ll.append("-")
        lf.write("%s\n" % (string.join(ll, " ")))
        lf.close()
    except:
        sys.stderr.write("Error opening '%s' for append." % (logfile))
        traceback.print_exc(file=sys.stderr)
    release_lock_exit()

# Output log entry when we exit
atexit.register(log_emit)

#####
# Locking

def get_lock():
    global mutex, mutex_held
    if mutex_held:
        mutex_held += 1
    else:
        if not mutex:
            mutex = pgdb.connect(connectstring)
        cur = mutex.cursor()
        cur.execute("LOCK TABLE scheduleLock")
        mutex_held = 1

def release_lock():
    global mutex, mutex_held
    check_mutex_held()
    mutex_held = mutex_held - 1
    if not mutex_held:
        mutex.commit()

def release_lock_exit():
    global mutex, mutex_held
    if mutex_held:
        mutex.commit()
    mutex_held = 0

def check_mutex_held():
    global mutex,mutex_held
    if not mutex_held:
        raise Exception("Mutex not held")
    else:
        if not mutex:
            raise Exception("Mutex claims to be held, but no DB connection")

def split_params(params):
    # Split the params into two dictionaries, one containing core parameters
    # (i.e. ones that go in tbljobs), and one containing extra parameters
    # (i.e. ones that go in tbljobdetails). Return these two in a dictionary
    # as core and extra

    global core_params;
  
    core = {}
    extra = {}

    for p in params.keys():
        if p in core_params:
            core[p] = params[p]
        else:
            extra[p] = params[p]
 
    result = {}
    result["core"] = core
    result["extra"] = extra

    return result
    

def new_job(params):

    global core_params, db

    splitparams = split_params(params)
    c = splitparams["core"]
    e = splitparams["extra"]
    e["JOB_SUBMITTED"] = time.asctime(time.gmtime()) + " UTC"

    for cp in core_params:
        if not c.has_key(cp):
            if cp == "JOBSTATUS":
                c[cp] = "new"
            else:
                c[cp] = ""  

    cur = db.cursor()
    cur.execute("LOCK TABLE tbljobs IN EXCLUSIVE MODE")
    cur.execute(("INSERT INTO tbljobs (version,revision,options," +
                 "jobstatus,userid,uploaded,removed) VALUES " +
                 "('%s','%s','%s','%s','%s','%s','%s');") % \
                 (c["VERSION"], c["REVISION"], c["OPTIONS"], c["JOBSTATUS"], \
                  c["USERID"], c["UPLOADED"], c["REMOVED"]))

    # Lookup jobid
    cur.execute("SELECT last_value FROM jobid_seq");
    rc = cur.fetchone()
    id = int(rc[0])
    db.commit() # Commit to release the lock

    for key in e.keys():
        cur.execute(("INSERT INTO tbljobdetails (jobid,param,value) " +
                     "VALUES (%u,'%s','%s');") % (id, key, e[key]))

    # If we have specifed a jobgroup and tag then update the jobgroup
    if params.has_key("JOBGROUP") and params.has_key("JOBGROUPTAG"):
        jobgroup = params["JOBGROUP"]
        jobtag = params["JOBGROUPTAG"]
        sql = "DELETE FROM tblJobGroups WHERE " \
              "gid = '%s' AND description = '%s'" % (jobgroup, jobtag)
        try:
            cur.execute(sql)
        except:
            pass
        sql = "INSERT INTO tblJobGroups (gid, jobid, description) VALUES " \
              "('%s', %u, '%s');" % (jobgroup, id, jobtag)
        cur.execute(sql)

    db.commit()
    cur.close()
    return id


JOB_STATUS_NEW     = 1
JOB_STATUS_RUNNING = 2
JOB_STATUS_DONE    = 3
JOB_STATUS_REMOVED = 4

job_status_desc = ['', 'new', 'running', 'done', 'removed']

def list_jobs(status):

    global db, job_status_desc

    jobstatus = job_status_desc[status]

    cur = db.cursor()
    cur.execute(("SELECT jobid FROM tbljobs WHERE jobstatus='%s';") % (jobstatus))
    reply = []
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        reply.append(rc[0])

    cur.close()

    return reply

def get_jobs(status, activeonly=True):

    global db, job_status_desc

    jobstatus = job_status_desc[status]

    cur = db.cursor()
    cur2 = db.cursor()
    conditions = ["jobstatus = '%s'" % (jobstatus)]
    if activeonly:
        conditions.append("removed = ''")
    cur.execute("SELECT jobid, jobStatus, version, revision,  " 
                "userId FROM tbljobs WHERE %s ORDER BY jobid DESC;" %
                (string.join(conditions, " AND ")))
    reply = []
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        d = {}
        if rc[0]:
            d['JOBID'] = str(rc[0])
        if rc[1] and string.strip(rc[1]) != "":
            d['JOBSTATUS'] = string.strip(rc[1])
        if rc[2] and string.strip(rc[2]) != "":
            d['VERSION'] = string.strip(rc[2])
        if rc[3] and string.strip(rc[3]) != "":
            d['REVISION'] = string.strip(rc[3])
        if rc[4] and string.strip(rc[4]) != "":
            d['USERID'] = string.strip(rc[4])
        reply.append(d)

        # Look up other variables
        cur2.execute("SELECT param, value FROM tblJobDetails WHERE jobid = "
                     "%s AND param in ('DEPS', 'JOBDESC', 'TESTRUN_SR', 'MACHINE');" % (d['JOBID']))
        while 1:
            rd = cur2.fetchone()
            if not rd:
                break
            if rd[0] and rd[1]:
                d[string.strip(rd[0])] = string.strip(rd[1])           
        if d['JOBSTATUS'] == "running":
            cur2.execute("SELECT COUNT(result) FROM tblresults WHERE jobid=%s AND result='paused';" % (d['JOBID']))
            rd = cur2.fetchone()
            if rd[0] > 0:
                d['PAUSED'] = "yes"
            else:
                d['PAUSED'] = "no"
        else:
            d['PAUSED'] = "no"

    cur.close()
    cur2.close()

    return reply

def parse_job(rc,cur):
    d = {}
    if rc[0]:
        d['JOBID'] = str(rc[0])
    if rc[1] and string.strip(rc[1]) != "":
        d['VERSION'] = string.strip(rc[1])
    if rc[2] and string.strip(rc[2]) != "":
        d['REVISION'] = string.strip(rc[2])
    if rc[3] and string.strip(rc[3]) != "":
        d['OPTIONS'] = string.strip(rc[3])
    if rc[4] and string.strip(rc[4]) != "":
        d['JOBSTATUS'] = string.strip(rc[4])
    if rc[5] and string.strip(rc[5]) != "":
        d['USERID'] = string.strip(rc[5])
    if rc[6] and string.strip(rc[6]) != "":
        d['UPLOADED'] = string.strip(rc[6])
    if rc[7] and string.strip(rc[7]) != "":
        d['REMOVED'] = string.strip(rc[7])

    cur.execute(("SELECT param, value FROM tblJobDetails WHERE " +
                      "jobid = %u;") % (rc[0]))
    
    while 1:
        rd = cur.fetchone()
        if not rd:
            break
        if rd[0] and rd[1] and string.strip(rd[1]) != "" and \
               string.strip(rd[1]) != "":
            d[string.strip(rd[0])] = string.strip(rd[1])
    
    if d['JOBSTATUS'] == "running":
        cur.execute("SELECT COUNT(result) FROM tblresults WHERE jobid=%s AND result='paused';" % (d['JOBID']))
        rd = cur.fetchone()
        if rd[0] > 0:
            d['PAUSED'] = "yes"
        else:
            d['PAUSED'] = "no"
    else:
        d['PAUSED'] = "no"

    return d

def get_job(id):

    global db
 
    cur = db.cursor()    
    d = {}
    cur.execute(("SELECT jobid, version, revision, options, jobStatus, " +
                 "userId, uploaded, removed FROM tbljobs WHERE " +
                 "jobId = %u;") % (id))
    rc = cur.fetchone()
    if rc:
        d = parse_job(rc,cur)
   
    cur.close()
  
    return d

def get_param_for_jobs(param, joblist):
    if len(joblist) == 0:
        return {}
    global db
    cur = db.cursor()
    
    global core_params
    if param in core_params:
        cur.execute("SELECT jobid, %s FROM tblJobs WHERE jobid in (%s)" %
                (sqlescape(param), string.join(map(str, joblist), ",")))
    else:
        cur.execute("SELECT jobid, value FROM tblJobDetails WHERE jobid in (%s)"
                " AND param = '%s'" %
                (string.join(map(str, joblist), ","), sqlescape(param)))
    reply = {}
    while True:
        rc = cur.fetchone()
        if not rc:
            break
        reply[rc[0]] = string.strip(rc[1])
    cur.close()
    return reply

def machine_data(machine):

    global db

    maindata = scm_machine_get(machine)
    if not maindata:
        return {}

    d = {}
    if maindata[1]:
        d["SITE"] = maindata[1]
    if maindata[2]:
        d["CLUSTER"] = maindata[2]
    if maindata[3]:
        d["POOL"] = maindata[3]
    if maindata[4]:
        d["STATUS"] = maindata[4]
    if maindata[5]:
        d["RESOURCES"] = maindata[5]
    if maindata[6]:
        d["FLAGS"] = maindata[6]
    if maindata[7]:
        d["DESCRIPTION"] = maindata[7]
    if maindata[8]:
        d["COMMENT"] = maindata[8]
        d["LEASEUSER"] = maindata[8]
    if maindata[9]:
        d["LEASETO"] = maindata[9]
    if maindata[10]:
        d["JOBID"] = maindata[10]
    if maindata[11]:
        d["LEASEFROM"] = maindata[11]
    if maindata[12]:
        d["LEASEREASON"] = maindata[12]
    if maindata[13]:
        d["LEASEPOLICY"] = maindata[13]

    cur = db.cursor()
    cur.execute(("SELECT key, value FROM tblMachineData " +
                 "WHERE machine = '%s';") % (machine))
    while 1:
        rc = cur.fetchone()
        if not rc:
             break
        if rc[0] and rc[1] and string.strip(rc[0]) != "" and \
            string.strip(rc[1]) != "":
            d[string.strip(rc[0])] = string.strip(rc[1])
    cur.close()
    return d

def set_status(id, status, commit=True):

    global db, job_status_desc

    try:
        jobstatus = job_status_desc[status]
   
        cur = db.cursor()
        cur.execute(("UPDATE tbljobs SET jobstatus='%s' WHERE jobid=%u;") % (jobstatus,id))
        if commit:
            db.commit()

    finally:
        cur.close()
 
# Performs the attribute checking for the FLAGS field mentioned above
# returns 1 if the required attributes are all present, 0 otherwise
# If the required attribute starts with ! then we reject the job if the
# machine has that attribute: (e.g. "FLAG=!e1000")
def check_attributes(available, required):

    suitable = 1

    if required:
        reqlist = string.split(required, ",")
    else:
        reqlist = []
    availlistraw = string.split(available, ",")
    availlist = map(lambda x:x.strip("+"), availlistraw)

    # Check each required attribute
    for req in reqlist:
        if req[0] == "~":
            # This isn't a required attribute, but it allows it to run on a machine that specifies "+"
            continue
        elif req[0] == '!':
            if req[1:] in availlist:
                suitable = 0
                break
        else:
            if not req in availlist or "-%s" % (req) in availlist:
                suitable = 0
                break
            
    # See if we have mandatory flags (the job must specify these flags
    # to be able to use this machine).
    for avail in availlistraw:
        if avail and avail[0] == "+":
            if avail[1:] not in reqlist and ("~%s" % avail[1:]) not in reqlist:
                suitable = 0
                break

    return suitable

def parse_input(commandline):
    """
    Takes a string of resources/requirements as specified in XRT-66 and
    returns a list of lists. Each element of the returned list is a list
    of the form:
    
    [ <resource> , <operator> , <value> ]
    
    Where <value> is normalised, removing any suffix.
    """

    result = []
    
    # Split the input into a list of records.
    t = re.findall('[^/]+', commandline)
    
    # Split each record into [ <resource> , <operator> , <value> ] form.
    for entry in t:
        result.append(re.split('(<=|>=|<|>|=)', entry))
        
    # Normalise the values in the list.
    for entry in result:
        entry[2] = normalise(entry[2])
	
    # Return the normalised list.
    return result

def check_input(commandline):
    """
    Check that an argument conforms to the format specified in XRT-66. Return 0
    if the input is correctly formed, 1 otherwise.
    """	

    if re.match('([A-Za-z0-9_]+(<=|>=|=|<|>)[0-9]+[kMGT]?/)*([A-Za-z0-9_]+(<=|>=|=|>|<)[0-9]+[kMGT]?$)', 
		commandline) == None:
        return 1
    else:
        return 0

def check_constraint(constraint, entry):
    """
    Check if the resource 'entry' satisfies the 'constraint'. Return 1 if
    the constraint is satisfied and 0 if it is not.
    """

    #sys.stderr.write("Checking '%s' '%s'\n" % (constraint, entry))

    # Check all the possible predicates.
    if constraint[1] == '<':
        if not entry:
            return 1
        if entry[2] < constraint[2]:
            return 1
    elif constraint[1] == '>':
        if not entry:
            return 0
        if entry[2] > constraint[2]:
            return 1
    elif constraint[1] == '>=':
        if not entry:
            return 0
        if entry[2] >= constraint[2]:
            return 1
    elif constraint[1] == '<=':
        if not entry:
            return 1
        if entry[2] <= constraint[2]:
            return 1
    elif constraint[1] == '=':
        if not entry:
            if constraint[2] == 0:
                return 1
            return 0
        if entry[2] == constraint[2]:
            return 1
    # Constraint wasn't satisifed.
    sys.stderr.write("no satis\n")
    return 0
	

def check_resources(available, required):
    """
    Determines whether a machine with the resources specified by 'available'
    is suitable for running a job with the resource requirements specified by
    'required'. The function returns 1 if the resources are sufficient and 0
    if they are not.
    """

    #sys.stderr.write("checking '%s' '%s'\n" % (available, required))

    # Remove any quotes (XRT-114)
    available = string.strip(available, "'\"")
    required = string.strip(required, "'\"")

    # Check arguments are properly formed.
    if check_input(available) or check_input(required):
        sys.stderr.write("Error. malformed inputs to check_resources\n")
        return 0
	
    # Parse the two lists.
    resources = parse_input(available)
    requirements = parse_input(required)
	
    # Check to see if all constraints are satisfied.
    suitable = 1
    for constraint in requirements:
        #sys.stderr.write("checking constraint %s\n" % (constraint))
        found = 0
        for entry in resources:
            #sys.stderr.write("checking resource %s\n" % (entry))
            # Check if this resource is the same as the one in the current
            # constraint.
            if entry[0] == constraint[0]:
                found = 1
                if not check_constraint(constraint, entry):
                    #sys.stderr.write("s1\n")
                    suitable = 0
                break
        # If nothing found then the required resource is not available
        if not found:
            if not check_constraint(constraint, None):
                suitable = 0
            break

    #sys.stderr.write("suitable = %u\n" % (suitable))
    # All constraints satisfied!
    return suitable

def list_job_details(fields, filter, fd):
    
    ss = [JOB_STATUS_NEW, JOB_STATUS_RUNNING]
    if filter.has_key("JOBSTATUS"):
        if filter['JOBSTATUS'] == "running":
            ss = [JOB_STATUS_RUNNING]
        elif filter['JOBSTATUS'] == "new":
            ss = [JOB_STATUS_NEW]

    for s in ss:
        jobs = get_jobs(s)
        for job in jobs:
            show = 1
            for f in filter.keys():
                if not job.has_key(f):
                    show = 0
                elif job[f] != filter[f]:
                    show = 0
            if not show:
                continue
            jobid = ""
            jobstatus = ""
            if job.has_key("JOBID"):
                jobid = job["JOBID"]
            if job.has_key("JOBSTATUS"):
                jobstatus = job["JOBSTATUS"]
            if jobstatus == "running" and job.has_key("PAUSED") and job['PAUSED'] == "yes":
                jobstatus = "paused"
            rl = [jobid, jobstatus]
            for f in fields:
                if job.has_key(f):
                    rl.append(job[f])
                else:
                    rl.append("")
            fd.write(string.join(rl, "\t") + "\n")

def update_field(id, key, value, commit=True):

    details = get_job(id)
    if not details:
        raise Exception("Could not find job %u" % (id))

    if key in core_params:
        cur = db.cursor()
        try:
            cur.execute("UPDATE tbljobs SET %s='%s' WHERE jobid=%u;" % 
                        (key,value,id))
            if commit:
                db.commit()
        finally:
            cur.close()
    else:
        cur = db.cursor()
        try:
            if not details.has_key(key):
                cur.execute("INSERT INTO tbljobdetails (jobid,param,value) "
                            "VALUES (%u,'%s','%s');" % (id, key, value))
            elif len(value) > 0:
                cur.execute("UPDATE tbljobdetails SET value='%s' WHERE "
                            "jobid=%u AND param='%s';" % (value,id,key))
            else:
                # Use empty string as a way to delete a property
                cur.execute("DELETE FROM tbljobdetails WHERE jobid=%u "
                            "AND param='%s';" % (id, key))
            db.commit()
        finally:
            cur.close()

def update_machine_param(machine, key, value):

    global db

    # If key starts with "+" or "-" then we are to add or remove the
    # value string from a comma separated list for that key.
    op = 0
    if key[0] == "+":
        op = 1
        key = key[1:]
    if key[0] == "-":
        op = 2
        key = key[1:]
    
    cur = db.cursor()
    cur.execute(("SELECT value FROM tblMachineData WHERE machine= '%s' " +
                 "AND key = '%s';") % (machine, key))
    rc = cur.fetchone()
    if not rc:
        if op == 0 or op == 1:
            cur.execute("INSERT INTO tblMachineData (machine, key, value)"
                        " VALUES ('%s', '%s', '%s');" %
                        (machine, key, value))
    else:
        prev = ""
        if rc[0]:
            prev = string.strip(rc[0])
        if op == 1 or op == 2:
            ll = string.split(prev, ",")
            llnew = []
            match = 0
            for item in ll:
                if item == '':
                    continue
                if op == 1:
                    if item == value:
                        match = 1
                    llnew.append(item)
                else:
                    if item != value:
                        llnew.append(item)
            if op == 1 and match == 0:
                llnew.append(value)
            value = string.join(llnew, ",")
        cur.execute(("UPDATE tblMachineData SET value = '%s' WHERE " +
                     "machine = '%s' AND key = '%s';") %
                    (value, machine, key))
    db.commit()
    cur.close()

def upload(id, fh, data, prefix=""):
    global results
    filename = results_filename(prefix, id, mkdir=1)
    fout = file(filename, 'w')
    if fh:
        shutil.copyfileobj(fh, fout)
    else:
        fout.write(data)
    fout.close()

def download(id, fh, prefix=""):
    global results
    filename = results_filename(prefix, id, find=1)
    fin = file(filename, 'r')
    while 1:
        data = fin.read(4096)
        if not data or len(data) == 0:
            break
        fh.write(data)
    fin.close()

def lookup_detailid(jobid, phase, test):

    reply = -1
 
    global db

    cur = db.cursor()

    cur.execute(("SELECT detailid from tblResults WHERE jobid = %u AND " +
                 "phase = '%s' AND test = '%s'") % (jobid, phase, test))

    rc = cur.fetchone()
    if rc and rc[0]:
        reply = int(rc[0])
        
    cur.close()

    return reply

def lookup_jobid(detailid):

    reply = -1

    global db

    cur = db.cursor()

    cur.execute(("SELECT jobid from tblResults WHERE detailid = %u") % 
                 (int(detailid)))

    rc = cur.fetchone()
    if rc and rc[0]:
        reply = int(rc[0])

    cur.close()

    return reply

def update_detailid_uploaded(detailid, uploaded):

    global db
    cur = db.cursor()

    cur.execute("UPDATE tblResults SET uploaded = '%s' WHERE detailid = %u" %
                (uploaded, detailid))

    db.commit()

    cur.close()

def showlog(id, wide, verbose, times=False):

    text = ""

    global db
    cur = db.cursor()
    cur2 = db.cursor()

    if wide != "no":
        cur.execute("SELECT options FROM tblJobs WHERE jobid = %u" %
                    (id))
        rc = cur.fetchone()
        if rc:
            if rc[0]:
                options = string.strip(rc[0])
            else:
                options = "-"
            pref = options + " "
        else:
            pref = ""
    else:
        pref = ""

    cur.execute(("SELECT phase, test, result, detailid FROM qryResults " +
                 "WHERE jobid = %u") %
                (id))
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        line = "%s%-10s %-12s %-10s" % \
              (pref, string.strip(rc[0]), string.strip(rc[1]),
               string.strip(rc[2]))
        text = text + line
        detailid = int(rc[3])
        if verbose != "no" or times:
            cur2.execute(("SELECT ts, key, value FROM tblDetails WHERE " +
                          "detailid = %u ORDER BY ts;") % (detailid))
            detailedtext = ""
            started = None
            finished = None
            while 1:
                rc2 = cur2.fetchone()
                if not rc2:
                    break
                fts = string.strip(rc2[0])
                fkey = string.strip(rc2[1])
                fvalue = string.strip(rc2[2])
                if fkey == "result" and times:
                    if fvalue == "started":
                        started = time.mktime(time.strptime(fts,  "%Y-%m-%d %H:%M:%S"))
                    if fvalue in ("pass", "fail", "error", "partial"):
                        finished = time.mktime(time.strptime(fts,  "%Y-%m-%d %H:%M:%S"))
                if verbose != "no":
                    line = "...[%-19s] %-10s %s" % (fts, fkey, fvalue)
                    detailedtext = detailedtext + line + "\n"
            if times and started and finished:
                text = text + " (Duration %6us)" % (int(finished-started))
            text = text + "\n" + detailedtext
        else:
            text = text + "\n"
    cur2.close()
    cur.close()

    return text

#############################################################################
# Site management                                                           #
#############################################################################

"""
CREATE TABLE tblSites (
    site      character(24) PRIMARY KEY,
    status    character(16) DEFAULT 'active',
    flags     character(256),
    descr     character(128),
    comment   character(128),
    ctrladdr  character(64),
    adminid   character(16)
);
GRANT ALL ON TABLE tblSites TO GROUP gxenrt;
"""

def scm_site_update(site,
                    status,
                    flags,
                    descr,
                    comment,
                    ctrladdr,
                    adminid,
                    maxjobs,
                    sharedresources):
    global db
    cur = db.cursor()
    sql = "SELECT site FROM tblSites WHERE site = '%s'" % (site)
    cur.execute(sql)
    if not cur.fetchone():
        # Need to create a new record
        sql = "INSERT into tblSites (site) VALUES ('%s')" % (sqlescape(site))
        cur.execute(sql)
    
    u = []
    if status:
        u.append("status = '%s'" % (sqlescape(status)))
    if flags:
        u.append("flags = '%s'" % (sqlescape(flags)))
    if descr:
        u.append("descr = '%s'" % (sqlescape(descr)))
    if comment:
        u.append("comment = '%s'" % (sqlescape(comment)))
    if ctrladdr:
        u.append("ctrladdr = '%s'" % (sqlescape(ctrladdr)))
    if adminid:
        u.append("adminid = '%s'" % (sqlescape(adminid)))
    if maxjobs:
        u.append("maxjobs = %d" % (maxjobs))
    if sharedresources:
        u.append("sharedresources = '%s'" % sqlescape(sharedresources))
    sql = "UPDATE tblSites SET %s WHERE site = '%s'" % \
          (string.join(u, ", "), sqlescape(site))
    cur.execute(sql)

    db.commit()
    cur.close()

def scm_flags_modify(site, operation, value):

    global db

    # If key starts with "+" or "-" then we are to add or remove the
    # value string from a comma separated list for that key.
    if operation[0] == "+":
        op = 1
    elif operation[0] == "-":
        op = 2
    else:
        raise Exception("Unknown operation %s" % (operation))
    
    cur = db.cursor()
    cur.execute("SELECT flags FROM tblSites WHERE site = '%s' " % (site))
    rc = cur.fetchone()
    if not rc:
        raise Exception("Could not find site '%s'" % (site))
    else:
        prev = ""
        if rc[0]:
            prev = string.strip(rc[0])
        ll = string.split(prev, ",")
        llnew = []
        match = 0
        for item in ll:
            if item == '':
                continue
            if op == 1:
                if item == value:
                    match = 1
                llnew.append(item)
            else:
                if item != value:
                    llnew.append(item)
        if op == 1 and match == 0:
            llnew.append(value)
        value = string.join(llnew, ",")
        cur.execute("UPDATE tblSites SET flags = '%s' WHERE site = '%s'" %
                    (value, site))

    db.commit()
    cur.close()

def scm_site_list(status=None,checkFull=False):
    """Return details of sites."""
    global db

    qry = []
    if status:
        qry.append("status = '%s'" % (status))
    if len(qry) == 0:
        qrystr = ""
    else:
        qrystr = "WHERE %s" % string.join(qry, " AND ")

    sql = """SELECT s.site, s.status, s.flags, s.descr, s.comment, s.ctrladdr,
                    s.adminid, s.maxjobs
             FROM tblSites s %s ORDER BY site;""" % (qrystr)
    cur = db.cursor()
    cur.execute(sql)

    reply = []
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        rep = map(mystrip, rc)
        if checkFull:
            # Only include sites that are full (defined as having >= 20 active
            # jobs)

            # Each job has one 'running' machine, as any other machines are
            # 'slaved', so filtering on 'running' gets us the count of jobs
            currentActive = len(scm_machine_list(site=rep[0],status='running')) + len(scm_machine_list(site=rep[0],status='scheduled'))
            rep.append(int(rep[7]) - currentActive)
        reply.append(rep)
            
    cur.close()
    return reply

def scm_site_get(site):
    """Get details of a site"""
    cur = db.cursor()
    sql = """SELECT s.site, s.status, s.flags, s.descr, s.comment, s.ctrladdr,
                    s.adminid, s.maxjobs, s.sharedresources
             FROM tblSites s WHERE s.site = '%s'
             """ % (sqlescape(site))
    cur.execute(sql)
    rc = cur.fetchone()
    cur.close()
    if not rc:
        return None
    return map(mystrip, rc)

def site_data(site):

    global db

    maindata = scm_site_get(site)
    if not maindata:
        return {}

    d = {}
    if maindata[0]:
        d["SITE"] = maindata[0]
    if maindata[1]:
        d["STATUS"] = maindata[1]
    if maindata[2]:
        d["FLAGS"] = maindata[2]
    if maindata[3]:
        d["DESCRIPTION"] = maindata[3]
    if maindata[4]:
        d["COMMENT"] = maindata[4]
    if maindata[5]:
        d["CTRLADDR"] = maindata[5]
    if maindata[6]:
        d["ADMINID"] = maindata[6]
    if maindata[7]:
        d["MAXJOBS"] = maindata[7]
    if maindata[8]:
        d["SHAREDRESOURCES"] = maindata[8]

    return d

def handle_slist(form):
    """Handle the slist CLI call"""
    print "Content-type: text/plain\n"
    try:
        quiet = False
        showdesc = True
        showprops = False
        chead = "Description"
        if form.has_key("quiet") and form["quiet"].value == "yes":
            quiet = True
        if form.has_key("props") and form["props"].value == "yes":
            showprops = True
            showdesc = False
            chead = "Properties"
        sites = scm_site_list()
        fmt = "%-8s %-7s %s\n"
        if not quiet:
            sys.stdout.write(fmt % ("Site", "Status", chead))
            sys.stdout.write("==============================================="
                             "=============================\n")
        for s in sites:
            item = ""
            if showdesc:
                item = s[3]
            elif showprops:
                item = s [2]
            sys.stdout.write(fmt % (s[0], s[1], item))
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error listing sites"

def handle_sdefine(form):
    """handle the sdefine CLI call"""
    try:
        print "Content-type: text/plain\n"
        site = None
        status = None
        flags = ''
        descr = ''
        comment = None
        ctrladdr = None
        adminid = None
        maxjobs = None
        if form.has_key("site"):
            site = form["site"].value
        if form.has_key("status"):
            status = form["status"].value
        if form.has_key("flags"):
            flags = form["flags"].value  
        if form.has_key("descr"):
            descr = form["descr"].value
        if form.has_key("comment"):
            comment = form["comment"].value
        if form.has_key("ctrladdr"):
            ctrladdr = form["ctrladdr"].value
        if form.has_key("adminid"):
            adminid = form["adminid"].value
        if form.has_key("maxjobs"):
            maxjobs = int(form["maxjobs"].value)
        if not site:
            print "ERROR missing field"
        scm_site_update(site, status, flags, descr, comment, ctrladdr, adminid, maxjobs, None)
        # Add a pseudohost for running host-less jobs
        machine = "_%s" % (site)
        scm_machine_update(machine,
                           site,
                           "default",
                           "NOHOST",
                           None,
                           "",
                           "",
                           "Pseudohost for %s" % (site),
                           None)
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"

def handle_sundefine(form):
    """Handle the sundefine CLI call"""
    print "Content-type: text/plain\n"
    site = form["site"].value
    try:
        sql = "DELETE FROM tblSites WHERE site = '%s';" % (site)
        cur = db.cursor()
        cur.execute(sql)
        try:
            # Remove the pseudohost
            sql2 = "DELETE FROM tblMachines WHERE machine = '_%s';" % (site)
            cur.execute(sql2)
        except:
            pass
        db.commit()
        cur.close()        
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error undefining %s" % (site)

#############################################################################
# Site and cluster management                                               #
#############################################################################

"""
CREATE TABLE tblMachines (
    machine   character(24) PRIMARY KEY,
    site      character(24),
    cluster   character(24),
    pool      character(24) DEFAULT 'DEFAULT',
    status    character(16) DEFAULT 'idle',
    resources character(128),
    flags     character(256),
    descr     character(128),
    comment   character(128),
    leaseTo   timestamp,
    jobid     integer
);
GRANT ALL ON TABLE tblMachines TO GROUP gxenrt;
CREATE INDEX tblmachine_site ON tblMachines (site);
"""

def mystrip(s):
    if s == None:
        s = ""
    return string.strip(str(s))

def sqlescape(s):
    return string.replace(s, "'", "''")

def scm_machine_update(machine, site, cluster, pool, status, resources,
                       flags, descr, leasepolicy):
    global db
    if pool:
        dpool = "'%s'" % (sqlescape(pool))
    else:
        dpool = "default"
    if status:
        dstatus = "'%s'" % (sqlescape(status))
    else:
        dstatus = "default"
    cur = db.cursor()
    sql = "SELECT machine FROM tblMachines WHERE machine = '%s'" % (machine)
    cur.execute(sql)
    if cur.fetchone():
        u = []
        if site:
            u.append("site = '%s'" % (sqlescape(site)))
        if cluster:
            u.append("cluster = '%s'" % (sqlescape(cluster)))
        if pool:
            u.append("pool = '%s'" % (sqlescape(pool)))
        if status:
            u.append("status = '%s'" % (sqlescape(status)))
        if resources:
            u.append("resources = '%s'" % (sqlescape(resources)))
        if flags:
            u.append("flags = '%s'" % (sqlescape(flags)))
        if descr:
            u.append("descr = '%s'" % (sqlescape(descr)))
        if leasepolicy != None:
            if leasepolicy == "":
                u.append("leasepolicy = NULL")
            else:
                u.append("leasepolicy = %d" % (int(leasepolicy)))
        sql = "UPDATE tblMachines SET %s WHERE machine = '%s'" % \
              (string.join(u, ", "), sqlescape(machine))
    else:
        sql = """INSERT into tblMachines (machine, site, cluster, pool,
                                          status, resources, flags, descr)
                 VALUES
        ('%s', '%s', '%s', %s, %s, '%s', '%s', '%s')""" % (sqlescape(machine),
                                                           sqlescape(site),
                                                           sqlescape(cluster),
                                                           dpool,
                                                           dstatus,
                                                           sqlescape(resources),
                                                           sqlescape(flags),
                                                           sqlescape(descr))
    cur.execute(sql)
    db.commit()
    cur.close()

def scm_machine_list(site=None,
                     cluster=None,
                     machine=None,
                     status=None,
                     leasecheck=None,
                     pool=None):
    """Return details of machines. If set, cluster and site will filter
    the results on that parameter"""
    global db

    qry = []
    if site:
        qry.append("site = '%s'" % (site))
    if cluster:
        qry.append("cluster = '%s'" % (cluster))
    if machine:
        qry.append("machine = '%s'" % (machine))
    if status:
        qry.append("status = '%s'" % (status))
    if pool:
        qry.append("pool = '%s'" % (pool))
    if leasecheck != None:
        if leasecheck == True:
            qry.append("leaseTo IS NOT NULL")
        elif leasecheck == False:
            qry.append("leaseTo IS NULL")
        else:
            qry.append("leaseTo IS NOT NULL AND comment='%s'" % leasecheck)
    if len(qry) == 0:
        qrystr = ""
    else:
        qrystr = "WHERE %s" % string.join(qry, " AND ")
    sql = """SELECT m.machine, m.site, m.cluster, m.pool, m.status,
                    m.resources, m.flags, m.descr, m.comment, m.leaseTo,
                    m.jobid, m.leasefrom, m.leasereason
             FROM tblMachines m %s ORDER BY machine;""" % (qrystr)
    cur = db.cursor()
    cur.execute(sql)

    reply = []
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        reply.append(map(mystrip, rc))
            
    cur.close()
    return reply

def scm_check_leases():
    """Check for any expired leases."""
    try:
        cur = db.cursor()
        cur.execute("SELECT m.machine, m.leaseTo FROM tblMachines m WHERE "
                    "m.leaseTo IS NOT NULL")

        exp = []
        while True:
            rc = cur.fetchone()
            if not rc:
                break
            m = string.strip(rc[0])
            l = string.strip(str(rc[1]))
            ut = time.mktime(time.strptime(l, "%Y-%m-%d %H:%M:%S"))
            if ut < time.time():
                exp.append("'%s'" % (m))
        if len(exp) > 0:
            cur.execute("UPDATE tblMachines SET leaseTo = NULL, "
                        "comment = NULL, leaseFrom = NULL, leaseReason = NULL WHERE machine in (%s)" %
                        (string.join(exp, ", ")))
        db.commit()
        cur.close()
    except:
        pass

def scm_machine_get(machine):
    """Get details of a named machine"""
    cur = db.cursor()
    sql = """SELECT m.machine, m.site, m.cluster, m.pool, m.status,
                    m.resources, m.flags, m.descr, m.comment, m.leaseTo,
                    m.jobid, m.leasefrom, m.leasereason, m.leasepolicy
             FROM tblMachines m WHERE m.machine = '%s'
             """ % (sqlescape(machine))
    cur.execute(sql)
    rc = cur.fetchone()
    cur.close()
    if not rc:
        return None
    return map(mystrip, rc)

def schedule_on(job, machines):
    global db
    debug = False
    if not debug:
        # Split the comma separated list of scheduled machines over
        # multiple SCHEDULEDON* variables to allow for strings that
        # exceed the database's 256 character limit for this field.
        schstrings = []
        for machine in machines:
            if len(schstrings) == 0 or \
                   len(schstrings[-1] + "," + machine) > 255:
                schstrings.append(machine)
            else:
                schstrings[-1] = schstrings[-1] + "," + machine
        if len(schstrings) == 0:
            raise "No SCHEDULEDON string set"
        if len(schstrings) > 3:
            raise "Machine list too long for the three SCHEDULEDON strings: " \
                  "%s" % (string.join(machines, ","))
        update_field(job, "SCHEDULEDON", schstrings[0], commit=False)
        if len(schstrings) > 1:
            update_field(job, "SCHEDULEDON2", schstrings[1], commit=False)
        if len(schstrings) > 2:
            update_field(job, "SCHEDULEDON3", schstrings[2], commit=False)
        update_field(job, "MACHINE", string.join(machines, ","), commit=False)
    # We may be rescheduling, in which case we don't want to update the status
    # of a machine if the job has already started, hence the check for status
    # being idle
    sql = """UPDATE tblMachines SET status = 'scheduled', jobid = %u
    WHERE machine = '%s' AND STATUS = 'idle';""" % (job, machines[0])
    if debug:
        print sql
    else:
        cur = db.cursor()
        cur.execute(sql)
        cur.close()
    for machine in machines[1:]:
        sql = """UPDATE tblMachines SET status = 'slaved', jobid = %u
        WHERE machine = '%s' AND STATUS = 'idle';""" % (job, machine)
        if debug:
            print sql
        else:
            cur = db.cursor()
            cur.execute(sql)
            cur.close()
    if not debug:
        # Now we're complete, mark the job as running
        set_status(job, JOB_STATUS_RUNNING, commit=True)

def fetch_jobid_list(sql):
    """Execute the SQL query and return a list of the first fields."""
    global db
    reply = []
    cur = db.cursor()
    cur.execute(sql)
    while True:
        rc = cur.fetchone()
        if not rc:
            break
        if rc[0] != None:
            reply.append(int(rc[0]))
    db.commit()
    cur.close()
    return reply

def schedulable_jobs():
    """Get a list of job details that we need to schedule"""
    # All new jobs
    njids = fetch_jobid_list("SELECT jobid FROM tblJobs "
                             "WHERE jobstatus = 'new' AND "
                             "removed = ''")
    if len(njids) == 0:
        # No new jobs
        return {}
    newjobids = []
    for nji in njids:
        newjobids.append(str(nji))
    newjobs = njids

    nowspec = time.strftime("HOUR=%H/DAY=%w", time.gmtime())
    
    jobs = {}
    newjobs.sort()
    for job in newjobs:
        try:
            details = get_job(job)
            if not details:
                sys.stderr.write("Could not read details for job %u.\n" %
                                 (job))
                continue
            # Exclude any jobs that have a START_AFTER (defined as seconds
            # since the epoch) in the future.
            if details.has_key("START_AFTER"):
                sa = int(details["START_AFTER"])
                if sa > int(time.mktime(time.gmtime())):
                    continue

            # Exclude any jobs with time windows that are not currently open
            if details.has_key("TIME_CONSTRAINTS"):
                tconst = details["TIME_CONSTRAINTS"]
                if not check_resources(nowspec, tconst):
                    continue
            jobs[details["JOBID"]] = details
        except:
            pass
    return jobs

def parse_shared_resources(resourcestring):
    result = {}
    if resourcestring:
        # Split the input into a list of records.
        try:
            t = re.findall('[^/]+', resourcestring)
            for entry in t:
                res = string.split(entry, "=", 2)
                result[res[0]] = int(res[1])
        except:
            print "WARNING: Invalid resource string specified %s" % resourcestring
            result = {}
    return result

def list_jobs_for_site(site):
    cur = db.cursor()
    cur.execute("SELECT jobid FROM tblmachines WHERE site='%s' AND (status='scheduled' OR status='running');" % sqlescape(site))
    rc = cur.fetchall()
    return map(lambda x: x[0], rc)


def site_available_shared_resources(site):
    
    global schedulercache
    if schedulercache["siteresources"].has_key(site):
        return schedulercache["siteresources"][site]
    sitedata = site_data(site)
    resources = {}
    if sitedata.has_key("SHAREDRESOURCES"):
        resstring = sitedata["SHAREDRESOURCES"]
        resources = parse_shared_resources(resstring)
        jobs = list_jobs_for_site(site)
        for j in jobs:
            details = get_job(j)
            if details.has_key("SHAREDRESOURCES"):
                usedresources = parse_shared_resources(details["SHAREDRESOURCES"])
                for r in usedresources.keys():
                    if resources.has_key(r):
                        resources[r] = resources[r] - usedresources[r]
    schedulercache["siteresources"][site] = resources
    return resources


def scm_select_machines(machines, number, selected, site, cluster, details, verbose=False):
    """Select <number> machines from the <machines> dictionary.

    The job may be partly done already and the <selected> list will contain
    machines found so far. More machines found are added to this list.

    <site> and <cluster>, if not None, are constraints on machines we can
    choose. Even if no constraints are supplied, we will always pick
    all machines from the same site and cluster (except if the job specifies
    CROSS_CLUSTER=yes which causes the cluster to be ignored).

    <details> is the dictionary of job parameters.
    """

    global schedulercache

    cross_cluster = False
    if details.has_key("CROSS_CLUSTER") and \
           details['CROSS_CLUSTER'][0].lower() in ("y", "t", "1"):
        cross_cluster = True
        cluster = None

    clusters = {}

    # Find clusters that fit our criteria. If we're in CROSS_CLUSTER mode
    # then just put all machines in one cluster
    #print "  listing sites and clusters. constraints 's=%s' 'c=%s'" % (site,
    #                                                                 cluster)
    for m in machines.values():
        if m[0] in selected:
            # Already selected
            continue
        s = m[1]
        if cross_cluster:
            c = "(all)"
        else:
            c = m[2]
            if c == None:
                c = ""
        #print "    checking %s on '%s/%s'" % (m[0], s, c)
        if site != None and s != site:
            #print "      site %s does not match constraint" % (s)
            continue
        if cluster != None and c != cluster:
            #print "      cluster %s does not match constraint" % (c)
            continue
        if not clusters.has_key((s, c)):
            clusters[(s, c)] = {}
        clusters[(s, c)][m[0]] = m

    # Try each cluster
    # Randomise the list so we spread the load a bit (XRT-737)
    cs = clusters.keys()
    random.shuffle(cs)
    for cluster in cs:
        s, c = cluster
        if verbose:
            print "  checking site %s, cluster %s..." % (s, c)
        # Check the available shared resources on the site
        if details.has_key("SHAREDRESOURCES"):
            sharedresourcesavailable = site_available_shared_resources(s)
            sharedresourcesneeded = parse_shared_resources(details["SHAREDRESOURCES"])
            if verbose:
                print "Shared resources available: %s" % ("/".join(map(lambda x:"%s=%s" % (x, sharedresourcesavailable[x]), sharedresourcesavailable.keys())))
                print "Shared resources needed: %s" % ("/".join(map(lambda x:"%s=%s" % (x, sharedresourcesneeded[x]), sharedresourcesneeded.keys())))
            valid = True
            for r in sharedresourcesneeded.keys():
                if (not sharedresourcesavailable.has_key(r)) or sharedresourcesavailable[r] < sharedresourcesneeded[r]:
                    if verbose:
                        print "Too small - not enough %s" % r
                    valid = False
            if not valid:
                continue
        
        # Check there are enough machines left in the cluster
        if len(clusters[cluster]) < number:
            if verbose:
                print "    too small (%u < %u)" % (len(clusters[cluster]), number)
            continue

        selx = []
        needed = number

        # Get site properties
        if schedulercache["siteprops"].has_key(s):
            siteprops = schedulercache["siteprops"][s]
        else:
            siteprops = None
            try:
                sd = site_data(s)
                if sd and sd.has_key("FLAGS") and sd["FLAGS"]:
                    siteprops = sd["FLAGS"]
            except:
                pass

            schedulercache["siteprops"][s] = siteprops

        ms = clusters[cluster].values()

        # Now consider each xindex requirement in turn
        for xindex in range(len(selected), len(selected) + needed):
            found = False
            # Consider each machine in this cluster
            # Randomise the list so we spread the load a bit (XRT-737)
            random.shuffle(ms)
            for m in ms:
                if m[0] in selx:
                    # Machine already provisionally selected
                    continue
                #print "    considering machine %s..." % (m[0])

                # The pool the machine is in
                subpool = m[3]
                if subpool == "":
                    subpool = "DEFAULT"

                # The machine's properties
                props = m[6]

                # Add properties stored in tblMachineData key PROPS
                if schedulercache["machineprops"].has_key(m[0]):
                    props = schedulercache["machineprops"][m[0]]
                else:
                    d = machine_data(m[0])
                    if d and d.has_key("PROPS"):
                        props = string.join([props, d["PROPS"]], ",")
                    schedulercache["machineprops"][m[0]] = props

                # Add site properties
                if siteprops:
                    props = string.join([props, siteprops], ",")

                # Check the subpool matching
                jobpool = ["DEFAULT"]
                if details.has_key("POOL_%u" % (xindex)):
                    jobpool = string.split(details["POOL_%u" % (xindex)], ",")
                elif details.has_key("POOL"):
                    jobpool = string.split(details["POOL"], ",")
                if not subpool in jobpool and not "ANY" in jobpool:
                    # Wrong pool
                    continue

                # Check the cluster matching
                clusterreq = None
                thiscluster = m[2] and m[2].strip() or ""
                if details.has_key("CLUSTER_%u" % xindex):
                    clusterreq = string.split(details["CLUSTER_%u" % xindex], ",")
                elif details.has_key("CLUSTER"):
                    clusterreq = string.split(details["CLUSTER"], ",")
                if clusterreq and thiscluster not in clusterreq:
                    # job has requirements on cluster but this machine is not there
                    continue

                # Check for resource matching
                resreq = None
                if details.has_key("RESOURCES_REQUIRED_%u" % (xindex)):
                    resreq = details["RESOURCES_REQUIRED_%u" % (xindex)]
                elif details.has_key("RESOURCES_REQUIRED"):
                    resreq = details["RESOURCES_REQUIRED"]
                if resreq:
                    if m[5] == "":
                        # No machine resource string, skip
                        continue
                    if not check_resources(m[5], resreq):
                        continue

                # Check for flags. We must do this even if no flags are specified
                # because of the possibility of mandatory machine flags.
                if details.has_key("FLAGS_%u" % (xindex)):
                    if not check_attributes(props, details["FLAGS_%u" % (xindex)]):
                        continue
                elif details.has_key("FLAGS"):
                    if not check_attributes(props, details["FLAGS"]):
                        continue
                else:
                    if not check_attributes(props, None):
                        continue

                # Check for short jobs
                if "shortonly" in string.split(props, ","):
                    if not details.has_key("SHORTJOB") or \
                           details["SHORTJOB"] != "yes":
                        continue

                # All OK
                if verbose:
                    print "      %s suitable" % (m[0])
                found = True
                selx.append(m[0])
                needed -= 1
                break

            if not found:
                # No machines found that match the requirements for this xindex,
                # so this cluster is not suitable, no point continuing
                break

        # If we found enough machines in this pool then we're done
        if needed == 0:
            selected.extend(selx)
            if verbose:
                print "    sufficient machines found (%u)" % (len(selected))
            return True
        else:
            if verbose:
                print "    insufficient machines found"

    # If we get here then we were not able to find sufficient machines
    # in any cluster.
    return False
            
def schedule_jobs(dryrun=False, ignore=False, verbose=False):
    """New world job scheduler - assigns machines to jobs"""
    # TODO - make this more flexible and smarter
    # smarter: look into solutions for the `maximum set packing problem'
    #          or any number of scheduling algorithms

    print "Content-type: text/plain\n"

    # Generate a random integer to track in logs
    schedid = random.randint(0,1000)

    if verbose:
        print "Job scheduler ID %d started %s" % (schedid, time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime()))
    get_lock()
    if verbose:
        print "%d acquired lock %s" % (schedid, time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime()))

    offline_sites = [x[0] for x in scm_site_list(status="offline")]
    sites = scm_site_list(checkFull=True)
    sitecapacity = {}
    for s in sites:
        sitecapacity[s[0]] = s[8]
        if verbose:
            print "%s remaining capacity %d" % (s[0], s[8])
    try:

        # Machines we have available
        scm_check_leases()
        if dryrun and ignore:
            machineslist = scm_machine_list()
        else:
            machineslist = scm_machine_list(status="idle", leasecheck=False)
        machines = {}
        for m in machineslist:
            # Don't include machine on sites marked as "offline"
            if m[1] in offline_sites or (not sitecapacity.has_key(m[1])) or sitecapacity[m[1]] <= 0:
                continue
            machines[m[0]] = m

        # Jobs to be scheduled
        jobs = schedulable_jobs()

        # print "Content-type: text/plain\n"

        sortlist = []
        sortmap = {}
        for jobid in jobs.keys():
            details = jobs[jobid]
            prio = 3
            if details.has_key("JOBPRIO"):
                try:
                    prio = int(details["JOBPRIO"])
                except:
                    pass
            sortkey = "P%03uJ%08u" % (prio, int(jobid))
            sortlist.append(sortkey)
            sortmap[sortkey] = jobid
        sortlist.sort()
        jobidlist = [sortmap[x] for x in sortlist]

        # For each job try to find suitable machine(s)
        for jobid in jobidlist:
            details = jobs[jobid]
            if details.has_key("JOBDESC"):
                jobdesc = " (%s)" % (details["JOBDESC"])
            else:
                jobdesc = ""
            if verbose or dryrun:
                print "New job %s%s" % (jobid, jobdesc)

            # Variables to record the scheduling data
            site = None      # All machines will be at the same site
            cluster = None   # All machines will be from the same cluster
            selected = []    # The machines we choose

            # Check how many machines are needed
            if details.has_key("MACHINES_REQUIRED"):
                try:
                    machines_required = int(details["MACHINES_REQUIRED"])
                except ValueError:
                    print "Warning: skipping job %s because of invalid MACHINES_REQUIRED value" % jobid
                    continue
            else:
                machines_required = 1

            # If the job explicitly asked for named machine(s) then check
            # their availability.
            if details.has_key("MACHINE"):
                if details.has_key("USERID"):
                    leasedmachineslist = scm_machine_list(status="idle", leasecheck=details['USERID'])
                    leasedmachines = {}
                    for m in leasedmachineslist:
                        leasedmachines[m[0]] = m
                    if verbose:
                        print "Job specified specific mahines, so machines (%s) available" % ",".join(leasedmachines.keys())
                else:
                    leasedmachines = {}
                mxs = string.split(details["MACHINE"], ",")
                if len(mxs) > 0:
                    if machines.has_key(mxs[0]) or leasedmachines.has_key(mxs[0]):
                        if verbose:
                            print "  wants %s, it is available" % (mxs[0])
                        selected.append(mxs[0])
                        if leasedmachines.has_key(mxs[0]):
                            site = leasedmachines[mxs[0]][1]
                            cluster = leasedmachines[mxs[0]][2]
                        else:
                            site = machines[mxs[0]][1]
                            cluster = machines[mxs[0]][2]
                        if cluster == None:
                            cluster = ""
                    else:
                        if verbose:
                            print "  wants %s, not available" % (mxs[0])
                        # unscheduable at the moment
                        continue
                    # Any remaining machines have site and cluster ignored
                    schedulable = True
                    for mx in mxs[1:]:
                        if len(selected) == machines_required:
                            break
                        if machines.has_key(mx) or leasedmachines.has_key(mx):
                            selected.append(mx)
                            if verbose:
                                print "  wants %s, it is available" % (mx)
                        else:
                            if verbose:
                                print "  wants %s, not available" % (mx)
                            # unscheduable at the moment
                            schedulable = False

                    if not schedulable:
                        continue
            else:
                if details.has_key("SITE"):
                    site = details["SITE"]
                if details.has_key("CLUSTER"):
                    cluster = details["CLUSTER"]

            # If we get here then we may have found one or more machines
            # explicitly requested by the job. Now find any remaining ones.
            # We may also have found nothing at all so far which means we're
            # not yet constrained by site or cluster
            still_needed = machines_required - len(selected)

            if still_needed > 0:
                scm_select_machines(machines,
                                    still_needed,
                                    selected,
                                    site,
                                    cluster,
                                    details,
                                    verbose=verbose)
            if len(selected) < machines_required:
                continue

            # If we've been able to find all the machines we need, go ahead
            # and schedule them all. The first machine is the primary,
            # it is the one that triggers the site-controller to run
            # the harness.
            if dryrun:
                print "  could schedule %u on %s" % (int(jobid), str(selected))
                continue
            print "  scheduling %u on %s (%d)" % (int(jobid), str(selected), schedid)
            schedule_on(int(jobid), selected)
            
            if not site:
                site = machines[selected[0]][1]
            global schedulercache
            if schedulercache["siteresources"].has_key(site):
                del schedulercache["siteresources"][site]

            # And mark these machines as being unavailable
            for m in selected:
                if machines.has_key(m):
                    del machines[m]

            if sitecapacity.has_key(site):
                sitecapacity[site] -= 1
                if sitecapacity[site] <= 0:
                    for m in machines.keys():
                        if machines[m][1] == site:
                            del machines[m]
    finally:
        release_lock()

    if verbose:
        print "Scheduler %d completed %s" % (schedid,time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime()))

######

def handle_mstatus(form):
    """Handle the mstatus CLI call"""
    print "Content-type: text/plain\n"
    try:
        machine = form["machine"].value
        status = form["status"].value
        sql = "UPDATE tblMachines SET status = '%s' WHERE machine = '%s';" % \
              (status, machine)
        cur = db.cursor()
        cur.execute(sql)
        db.commit()
        cur.close()        
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error listing machines"
    
        
def handle_mlist(form):
    """Handle the mlist CLI call"""
    print "Content-type: text/plain\n"
    try:
        site = None
        cluster = None
        pool = None
        quiet = False
        csv = False
        showres = False
        showdesc = False
        showprops = False
        chead = "Comment/Leased to"
        rfilter = None
        pfilter = None
        ffilter = None
        verbose = False
        iscontroller = False
        leasefilter = None
        if form.has_key("site"):
            site = form["site"].value
        if form.has_key("cluster"):
            cluster = form["cluster"].value
        if form.has_key("pool"):
            pool = form["pool"].value
        if form.has_key("quiet") and form["quiet"].value == "yes":
            quiet = True
        if form.has_key("res") and form["res"].value == "yes":
            showres = True
            chead = "Resources"
        elif form.has_key("desc") and form["desc"].value == "yes":
            showdesc = True
            chead = "Description"
        if form.has_key("controller") and form["controller"].value == "yes":
            quiet = True
            csv = True
            iscontroller = True
            fields = [0, 4, 10]
        if form.has_key("rfilter"):
            rfilter = form["rfilter"].value
        if form.has_key("props") and form["props"].value == "yes":
            showprops = True
            chead = "Properties"
        if form.has_key("pfilter"):
            pfilter = form["pfilter"].value
        if form.has_key("ffilter"):
            ffilter = form["ffilter"].value
        if form.has_key("leasefilter"):
            leasefilter = form["leasefilter"].value
        if form.has_key("notleased"):
            leasefilter = False
        if form.has_key("leased"):
            leasefilter = True 
        if form.has_key("verbose") and form["verbose"].value == "yes":
            verbose = True
        machines = scm_machine_list(site, cluster, pool=pool, leasecheck=leasefilter)
        if showprops or pfilter:
            machineprops = {}
            cur = db.cursor()
            cur.execute("SELECT machine, value FROM tblMachineData "
                        "WHERE key = 'PROPS';")
            while 1:
                rc = cur.fetchone()
                if not rc:
                    break
                if rc[0] and rc[1] and string.strip(rc[0]) != "" and \
                       string.strip(rc[1]) != "":
                    machineprops[string.strip(rc[0])] = string.strip(rc[1])
            cur.close()
            siteprops = dict([(x[0], x[2]) for x in scm_site_list()])
        fmt = "%-12s %-7s %-8s %-9s %-8s %s\n"
        if not quiet:
            sys.stdout.write(fmt %
                             ("Machine", "Site", "Cluster", "Status", "Pool",
                              chead))
            sys.stdout.write("==============================================="
                             "=============================\n")
        if not csv:
            joblist = []
            for m in machines:
                if m[10] and m[4] != "idle":
                    if not m[10] in joblist:
                        joblist.append(m[10])
            descs = get_param_for_jobs("JOBDESC", joblist)
            deps = get_param_for_jobs("DEPS", joblist)
            users = get_param_for_jobs("USERID", joblist)
        for m in machines:
            if not iscontroller and not verbose and m[0] == "_%s" % (m[1]):
                continue
            # Add in siteprops
            if showprops or pfilter:
                if siteprops.has_key(m[1]) and siteprops[m[1]]:
                    if machineprops.has_key(m[0]):
                        machineprops[m[0]] += "," + siteprops[m[1]]
                    else:
                        machineprops[m[0]] = siteprops[m[1]]
            if rfilter:
                if not check_resources(m[5], rfilter):
                    continue
            if pfilter:
                if machineprops.has_key(m[0]):
                    avail = machineprops[m[0]]
                else:
                    avail = ""
                if not check_attributes(avail, pfilter):
                    continue
            if ffilter:
                if not check_attributes(m[6], ffilter):
                    continue
            if csv:
                x = []
                for f in fields:
                    x.append(m[f])
                sys.stdout.write("%s\n" % (string.join(x, ",")))
            else:
                if m[4] == "scheduled":
                    status = "%s (S)" % (m[10])
                elif m[4] == "running":
                    status = "%s" % (m[10])
                elif m[4] == "slaved":
                    status = "(%s)" % (m[10])
                else:
                    status = m[4]
                if showres:
                    comment = m[5]
                elif showdesc:
                    comment = m[7]
                elif showprops:
                    if machineprops.has_key(m[0]):
                        comment = machineprops[m[0]]
                    else:
                        comment = ""
                else:
                    if m[8]:
                        c = string.strip(m[8])
                        if m[12]:
                            c += " - %s" % m[12]
                    else:
                        c = None
                    if m[9]:
                        ts = string.strip(str(m[9]))
                    else:
                        ts = None
                    if ts:
                        if c:
                            comment = "%s (%s)" % (ts, c)
                        else:
                            comment = "%s" % (ts)
                    elif c:
                        comment = c
                    elif m[10] and descs.has_key(int(m[10])) and \
                             status != "idle" and status != "offline":
                        comment = descs[int(m[10])]
                    elif m[10] and deps.has_key(int(m[10])) and users.has_key(int(m[10])) and \
                             status != "idle" and status != "offline":
                        comment = "%s - %s" % (deps[int(m[10])], users[int(m[10])])
                    else:
                        comment = ""
                if m[2]:
                    cluster = string.strip(m[2])
                else:
                    cluster = "default"
                sys.stdout.write(fmt % (m[0], m[1], cluster, status, m[3],
                                        comment))
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error listing machines"

def handle_mdefine(form):
    """handle the mdefine CLI call"""
    try:
        print "Content-type: text/plain\n"
        machine = None
        site = None
        cluster = ''
        pool = None
        status = None
        resources = ''
        flags = ''
        descr = ''
        if form.has_key("machine"):
            machine = form["machine"].value
        if form.has_key("site"):
            site = form["site"].value
        if form.has_key("cluster"):
            cluster = form["cluster"].value
        if form.has_key("pool"):
            pool = form["pool"].value
        if form.has_key("status"):
            status = form["status"].value
        if form.has_key("resources"):
            resources = form["resources"].value
        if form.has_key("flags"):
            flags = form["flags"].value  
        if form.has_key("descr"):
            descr = form["descr"].value
        if not machine or not site:
            print "ERROR missing field(s)"    
        scm_machine_update(machine, site, cluster, pool, status, resources,
                           flags, descr, None)
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"

def handle_mundefine(form):
    """Handle the mundefine CLI call"""
    print "Content-type: text/plain\n"
    machine = form["machine"].value
    try:
        cur = db.cursor()
        sql = "DELETE FROM tblMachines WHERE machine = '%s';" % (machine)
        cur.execute(sql)
        sql = "DELETE FROM tblMachineData WHERE machine = '%s';" % (machine)
        cur.execute(sql)
        db.commit()
        cur.close()        
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error undefining %s" % (machine)

def handle_borrow(form):
    """Handle the borrow CLI call"""
    try:
        print "Content-type: text/plain\n"
        userid = None
        reason = "NULL"
        force = False
        hours = 24
        machine = form["machine"].value
        if form.has_key("USERID"):
            userid = form["USERID"].value
        if form.has_key("reason"):
            reason = "'%s'" % sqlescape(form["reason"].value)
        if form.has_key("hours"):
            hours = int(form["hours"].value)
        leaseToTime = time.gmtime(time.time() + (hours * 3600))
        leaseTo = time.strftime("%Y-%m-%d %H:%M:%S", leaseToTime)
        leaseFrom = time.strftime("%Y-%m-%d %H:%M:%S",
                                time.gmtime(time.time()))
        if form.has_key("forever"):
            leaseTo = "2030-01-01 00:00:00"
            leaseToTime = time.strptime(leaseTo, "%Y-%m-%d %H:%M:%S")
            hours = (time.mktime(leaseToTime) - time.time()) / 3600
        if form.has_key("force"):
            force = True
        sql = "SELECT comment, leaseTo, leasepolicy FROM tblmachines WHERE machine = '%s'" % (machine)
        cur = db.cursor()
        cur.execute(sql)
        rc = cur.fetchone()
        cur.close()
        if rc[2] and hours > rc[2]:
            print "ERROR: The policy for this manchine only allows leasing for %d hours, please contact QA if you need a longer lease" % rc[2]
        elif rc[0] and rc[0].strip() != userid and not force:
            print "ERROR: machine already leased to %s (use --force to override)" % rc[0].strip()
        elif rc[1] and time.strptime(rc[1], "%Y-%m-%d %H:%M:%S") > leaseToTime and not force:
            print "ERROR: machine already leased for longer (use --force to override)"
        else:
            sql = "UPDATE tblMachines SET leaseTo = '%s', leasefrom = '%s', comment = '%s', leasereason = %s " \
                  "WHERE machine = '%s'" % (leaseTo, leaseFrom, userid, reason, machine)
            cur = db.cursor()
            cur.execute(sql)
            db.commit()
            cur.close()        
            print "OK"        
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"

def handle_return(form):
    """handle the return CLI call"""
    try:
        print "Content-type: text/plain\n"
        machine = form["machine"].value
        force = False
        if form.has_key("force"):
            force = True
        userid = None
        if form.has_key("USERID"):
            userid = form["USERID"].value
        sql = "SELECT comment FROM tblmachines WHERE machine = '%s'" % (machine)
        cur = db.cursor()
        cur.execute(sql)
        rc = cur.fetchone()
        cur.close()
        if rc[0] and userid and rc[0].strip() != userid and not force:
            print "ERROR: machine is not leased to you (use --force to override)"
        else:
            sql = "UPDATE tblMachines SET leaseTo = NULL, comment = NULL, leasefrom = NULL, leasereason = NULL " \
              "WHERE machine = '%s'" % (machine)
            cur = db.cursor()
            cur.execute(sql)
            db.commit()
            cur.close()        
            print "OK"        
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"    

#############################################################################

class MatrixCell:
    def __init__(self, row):
        self.row = row
        self.result = None
        self.warning = False
        self.detailid = None
        self.uploaded = False
        self.relative = ""

    def setResult(self, r):
        self.result = r

    def setDetailID(self, d):
        self.detailid = d

    def setRelative(self, r):
        self.relative = r

    def setWarning(self, w=True):
        self.warning = w
        
    def setUploaded(self, u=True):
        self.uploaded = u

    def isActive(self):
        if self.detailid:
            return True
        return False

    def render(self, fd):
        global me
        if not self.isActive():
            matrixCellRenderEmpty(fd)
            return
        col = colour_style(self.result, rswarn=self.warning)
        fd.write("<td class=\"results-cell\">"
                 "  <table class=\"results-innertable\">"
                 "    <tr><td style='%s'>"
                 "      <a href=\"%s?action=detail&detailid=%s\" "
                 "         target=\"testdesc\" class=\"info\">D</a>" %
                 (col, me, self.detailid))
        if self.uploaded:
            fd.write(" <a href=\"%s?action=browse&html=yes&test=yes&id=%s\" target=\"_blank\">L</a>" % (os.path.basename(sys.argv[0]),self.detailid))
        fd.write("%s<br><b>%s</b></td></tr></table></td>" % (self.relative, self.result))

def matrixCellRenderEmpty(fd):
        fd.write("<td></td>")

class MatrixRow:
    def __init__(self, rowgroup, title, desc):
        self.rowgroup = rowgroup
        self.title = title
        self.desc = desc
        self.cells = {}

    def addCell(self, jobid):
        c = MatrixCell(self)
        self.cells[jobid] = c
        return c

    def isActive(self):
        count = 0
        for c in self.cells.values():
            if c.isActive():
                count = count + 1
        return count

    def render(self, fd, tdopen, jobids):
        if not self.isActive():
            return tdopen
        if not tdopen:
            fd.write("<tr>")
            tdopen = True
        fd.write("<th class=\"column-row-header\">")
        fd.write("<a class=\"info\">%s" % (self.title))
        fd.write("<span>%s</span>" % (self.desc))
        fd.write("</a></th>")
        for j in jobids:
            if self.cells.has_key(j):
                self.cells[j].render(fd)
            else:
                matrixCellRenderEmpty(fd)
        fd.write("</tr>\n")
        tdopen = False
        return tdopen

class MatrixRowGroup:
    def __init__(self, matrix, title, desc):
        self.matrix = matrix
        self.title = title
        self.desc = desc
        self.rows = {}
        self.rowsOrder = []

    def addRow(self, title, desc):
        if not self.rows.has_key(title):
            r = MatrixRow(self, title, desc)
            self.rows[title] = r
            self.rowsOrder.append(title)
        return self.rows[title]

    def isActive(self):
        count = 0
        for rt in self.rowsOrder:
            if self.rows[rt].isActive():
                count = count + 1
        return count

    def render(self, fd, jobids):
        rows = self.isActive()
        if not rows:
            return
        fd.write("<tr><th rowspan=\"%u\" class=\"column-row-header\">" %
                 (rows))
        fd.write("<a class=\"info\">%s" % (self.title))
        fd.write("<span>%s</span>" % (self.desc))
        fd.write("</a></th>")
        tdopen = True
        for rt in self.rowsOrder:
            tdopen = self.rows[rt].render(fd, tdopen, jobids)

class Matrix:
    """Represents a results matrix to be displayed using HTML"""
    def __init__(self):
        self.columns = None
        self.jobs = None
        self.rowgroups = {}
        self.rowgroupsOrder = []

    def setColumns(self, c):
        self.columns = c

    def setJobs(self, j):
        self.jobs = j

    def setJobData(self, j):
        self.jobdata = j

    def addRowGroup(self, title, desc):
        if not self.rowgroups.has_key(title):
            rg = MatrixRowGroup(self, title, desc)
            self.rowgroups[title] = rg
            self.rowgroupsOrder.append(title)
        return self.rowgroups[title]
        
    def render(self, fd):
        global me
        fd.write("<table id=\"results-grid\">\n")
        for c in self.columns:
            fd.write("<tr><td colspan=\"2\"></td>")
            for cell in c:
                # See if this looks like a build number - if it does, link to xenbuilder
                text = cell[1]
                m = re.search("\-(\d*)", text)
                if m:
                    text = "<a href=\"http://xenbuilder.uk.xensource.com/builds?q_view=details&q_number=%s\" target=\"_blank\">%s</a>" % (m.group(1), text)
                fd.write("<th colspan=\"%u\"><span style=\"color: white;\">"
                         "%s</span></td>" % (cell[0], text))
            fd.write("</tr>\n")
    
        fd.write("<tr><td colspan=\"2\"></td>")
        for j in self.jobs:
            fd.write("<th><a href=\"%s?action=status&id=%s&html=yes\" "
                     "target=\"jobdesc\" class=\"info\">D</a>" % (me, j))
            if self.jobdata.has_key(j) and \
                   self.jobdata[j].has_key("UPLOADED") and \
                   self.jobdata[j]["UPLOADED"] == "yes":
                fd.write(" <a href=\"%s?action=browse&html=yes&id=%s\" target=\"_blank\">L</a>" % (os.path.basename(sys.argv[0]),j))
            else:
                fd.write("&nbsp;")
            fd.write("</th>")
        fd.write("</tr>\n")

        for rgtitle in self.rowgroupsOrder:
            self.rowgroups[rgtitle].render(fd, self.jobs)
        
        fd.write("</table>\n")

#############################################################################

def handle_warnings_etc(form):
    print "Content-type: text/html\n"
    if not form.has_key("jobid") and not form.has_key("jobgroup"):
        print "ERROR No job ID or group specified"
        sys.exit(0)
    if form.has_key("key"):
        fieldkey = form["key"].value
    else:
        fieldkey = "warning"
    jobids = []
    try:
        cur = db.cursor()
        if form.has_key("jobid"):
            jobids.append(form["jobid"].value)
        else:
            cur.execute("SELECT jobid FROM tblJobGroups WHERE gid = '%s'" %
                        (form["jobgroup"].value))
            while True:
                rc = cur.fetchone()
                if not rc:
                    break
                jobids.append(str(rc[0]))
    
        for jobid in jobids:
            cur.execute("SELECT detailid, value FROM tblDetails WHERE "
                        "  detailid IN (SELECT detailid FROM tblResults "
                        "    WHERE jobid = %s) AND key = '%s'" %
                        (jobid, fieldkey))
            while True:
                rc = cur.fetchone()
                if not rc:
                    break
                detailid = str(rc[0])
                warning = rc[1].strip()
                print string.join([jobid, detailid, warning], "\t")
    finally:
        cur.close()
    
#############################################################################

"""
CREATE TABLE tblSubResults (
    detailid integer NOT NULL,
    subgroup character(48) NOT NULL,
    subtest character(48) NOT NULL,
    result character(12),
    subid serial NOT NULL,
    reason character(48),
    comment character(32),
    PRIMARY KEY (detailid, subgroup, subtest)
);
GRANT ALL ON TABLE tblSubResults TO GROUP gxenrt;
CREATE INDEX idx_tblSubResults_subid ON tblSubResults(subid);
grant all on table tblsubresults_subid_seq to GROUP gxenrt;
"""

def handle_subresults(form):
    """Parse XML to update tblSubResults"""
    try:
        print "Content-type: text/plain\n"
        jobid = form["jobid"].value
        phase = form["phase"].value
        test = form["test"].value

        cur = db.cursor()

        detailid = lookup_detailid(int(jobid), phase, test)
        if detailid == -1:
            sql = "INSERT INTO tblResults (jobid, phase, test, result) " \
                  "VALUES (%s, '%s', '%s', '%s');" % \
                  (jobid, phase, test, "unknown")
            cur.execute(sql)
            detailid = lookup_detailid(int(jobid), phase, test)
        if True:
            fh = form["file"].file
            if fh:
                x = xml.dom.minidom.parse(fh)
                fh.close()
            else:
                x = xml.dom.minidom.parseString(form["file"].value)
            for n in x.childNodes:
                if not n.nodeType == n.ELEMENT_NODE or \
                       not n.localName == "results":
                    continue
                for t in n.childNodes:
                    if not t.nodeType == t.ELEMENT_NODE or \
                           not t.localName == "test":
                        continue
                    for g in t.childNodes:
                        if not g.nodeType == g.ELEMENT_NODE or \
                               not g.localName == "group":
                            continue
                        gname = "DEFAULT"
                        for i in g.childNodes:
                            if i.nodeType == i.ELEMENT_NODE and \
                                   i.localName == "name":
                                for a in i.childNodes:
                                    if a.nodeType == a.TEXT_NODE:
                                        gname = string.strip(str(a.data))
                            elif i.nodeType == i.ELEMENT_NODE and \
                                     i.localName == "test":
                                tname = "DEFAULT"
                                result = "unknown"
                                reason = ""
                                for j in i.childNodes:
                                    if j.nodeType == j.ELEMENT_NODE and \
                                           j.localName == "name":
                                        for a in j.childNodes:
                                            if a.nodeType == a.TEXT_NODE:
                                                tname = string.strip(\
                                                    str(a.data))
                                    elif j.nodeType == j.ELEMENT_NODE and \
                                           j.localName == "state":
                                        for a in j.childNodes:
                                            if a.nodeType == a.TEXT_NODE:
                                                result = string.strip(\
                                                    str(a.data))
                                    elif j.nodeType == j.ELEMENT_NODE and \
                                           j.localName == "reason":
                                        for a in j.childNodes:
                                            if a.nodeType == a.TEXT_NODE:
                                                reason = string.strip(\
                                                    str(a.data))
                                gname = gname[0:48]
                                tname = tname[0:48]
                                reason = reason[0:48]
                                # Insert this record
                                sql = "SELECT subid from tblSubResults " \
                                      "WHERE detailid = %u AND subgroup = " \
                                      "'%s' AND subtest = '%s'" % \
                                      (detailid,
                                       sqlescape(gname),
                                       sqlescape(tname))
                                cur.execute(sql)
                                rc = cur.fetchone()
                                if rc:
                                    subid = int(rc[0])
                                    sql = "UPDATE tblSubResults SET result =" \
                                          " '%s', reason = '%s' WHERE " \
                                          "subid = %u" % \
                                          (sqlescape(result),
                                           sqlescape(reason),
                                           subid)
                                    cur.execute(sql)
                                else:
                                    sql = "INSERT INTO tblSubResults " \
                                          "(detailid, subgroup, subtest, " \
                                          "result, reason) VALUES " \
                                          "(%u, '%s', '%s', '%s', '%s')" % \
                                          (detailid,
                                           sqlescape(gname),
                                           sqlescape(tname),
                                           sqlescape(result),
                                           sqlescape(reason))
                                    cur.execute(sql)
        db.commit()
        cur.close()        
        print "OK"        
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"    

#############################################################################

"""
CREATE VIEW qryGuests AS
  SELECT j.jobid, j.version, j.revision, dc.value AS vcpus, dm.value AS memory,
    dp.value AS pool
  FROM ((tblJobs j LEFT JOIN tblJobDetails dc ON j.jobid = dc.jobid AND
    dc.param = 'GUESTVCPUS')
    LEFT JOIN tblJobDetails dm ON j.jobid = dm.jobid AND
      dm.param = 'GUESTMEMORY')
    LEFT JOIN tblJobDetails dp ON j.jobid = dp.jobid AND dp.param = 'POOL';
GRANT ALL ON TABLE qryGuests TO GROUP gxenrt;
"""

#############################################################################
# Performance database                                                      #
#############################################################################

PD_DLIST = 1
PD_HIDE = 2

# 0 int, 1 char, 2 bool, 3 fp
perfdef = {'jobid': (0, "Job ID", 10, PD_DLIST),
           'jobtype': (1, "Job type", 20, PD_HIDE),
           'perfrun': (2, "Perf run?", 30, PD_HIDE),
           'machine': (1, "Machine", 40, PD_HIDE),
           'productname': (1, "Product", 50, PD_HIDE),
           'productversion': (1, "Version", 60, PD_HIDE),
           'productspecial': (1, "Product special", 70, PD_HIDE),
           'hvarch': (1, "H/v arch", 80, PD_HIDE),
           'dom0arch': (1, "Domain0 arch", 90, PD_HIDE),
           'hostdebug': (2, "Host debug?", 100, PD_HIDE),
           'hostspecial': (1, "Host special", 110, PD_HIDE),
           'guestnumber': (0, "Guest number", 115, PD_HIDE),
           'guestname': (1, "Guest name", 120, PD_HIDE),
           'guesttype': (1, "Guest type", 130, PD_HIDE),
           'domaintype': (1, "Domain type", 140, PD_HIDE),
           'domainflags': (1, "Domain flags", 150, PD_HIDE),
           'guestversion': (1, "Guest OS", 160, PD_HIDE),
           'kernelversion': (1, "Guest kernel", 170, PD_HIDE),
           'kernelproductname': (1, "Guest product", 180, PD_HIDE),
           'kernelproductversion': (1, "Guest product version", 190, PD_HIDE),
           'kernelproductspecial': (1, "Guest product special", 200, PD_HIDE),
           'guestarch': (1, "Guest arch", 210, PD_HIDE),
           'guestdebug': (2, "Guest debug?", 220, PD_HIDE),
           'pvdrivers': (1, "PV drivers?", 230, PD_HIDE),
           'vcpus': (0, "vCPUS", 240, PD_HIDE),
           'memory': (0, "Memory MB", 250, PD_HIDE),
           'storagetype': (1, "Storage type", 260, PD_HIDE),
           'guestspecial': (1, "Guest special", 270, PD_HIDE),
           'alone': (2, "Only guest?", 280, PD_HIDE),
           'benchmark': (1, "Benchmark", 400, PD_HIDE),
           'bmversion': (1, "Benchmark version", 410, PD_HIDE),
           'bmspecial': (1, "Benchmark special", 420, PD_HIDE),
           'metric': (1, "Metric", 500, PD_HIDE),
           'value': (3, "Value", 510, PD_HIDE),
           'units': (1, "Units", 520, PD_HIDE),
           'ts': (4, "Timestamp", 600, PD_HIDE)}

perfdeps = {'productversion': ['productname'],
            'kernelproductversion': ['kernelproductname'],
            'bmversion': ['benchmark'],
            'metric': ['benchmark']}

perfomit = ["dbench",
            "tbench",
            "lmbench",
            "postmark",
            "iometer",
            "sciencemark2",
            ".*_throughput",
            ".*:lat"]

genevaga = "3.2.0-2004"
rioga = "4.0.1-4249p"
miamiga = "4.1.0-7843p"

class HeaderTree:
    def __init__(self, titles):
        self.titles = titles
        self.map = {}

    def getDepth(self):
        return len(self.titles)

    def addGroup(self, group):
        dict = self.map
        new = False
        for i in group:
            if not dict.has_key(i):
                new = True
                break
            dict = dict[i][0]
        if not new:
            return
        dict = self.map
        for i in group:
            if not dict.has_key(i):
                dict[i] = [{}, 0]
            dict[i][1] = dict[i][1] + 1
            dict = dict[i][0]

    def getColMap(self):
        dicts = [self.map]
        reply = []
        path = []
        for i in range(len(self.titles)):
            newdicts = []
            reply.append([])
            path.append("")
            for dict in dicts:
                keys = dict.keys()
                keys.sort()
                for k in keys:
                    reply[i].append((k, dict[k][1]))
                    newdicts.append(dict[k][0])
            dicts = newdicts
        return reply

    def getRowMap(self):
        reply = []
        

def handle_perfdata(form):
    """Read an uploaded XML file of one or more performance results and place
    into the database."""

    global perfdef
    timenow = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(time.time()))
    cur = db.cursor()

    try:
        print "Content-type: text/html\n"
        fh = form["file"].file
        if fh:
            x = xml.dom.minidom.parse(fh)
            fh.close()
        else:
            x = xml.dom.minidom.parseString(form["file"].value)
        for n in x.childNodes:
            if not n.nodeType == n.ELEMENT_NODE or \
                   not n.localName == "performance":
                continue
            for t in n.childNodes:
                if not t.nodeType == t.ELEMENT_NODE or \
                       not t.localName == "datapoint":
                    continue
                dp = {}
                for g in t.childNodes:
                    if g.nodeType == g.ELEMENT_NODE:
                        for i in g.childNodes:
                            if i.nodeType == i.TEXT_NODE:
                                dp[str(g.localName)] = \
                                                     string.strip(str(i.data))
                f = []
                v = []
                for dpi in dp.keys():
                    if perfdef.has_key(dpi):
                        f.append(dpi)
                        l, desc, order, flags = perfdef[dpi]
                        if l == 0:
                            v.append(dp[dpi])
                        elif l == 1:
                            v.append("'%s'" % (sqlescape(dp[dpi])))
                        elif l == 2:
                            if string.lower(dp[dpi][0]) in ("1", "y", "t"):
                                v.append("TRUE")
                            else:
                                v.append("FALSE")
                        elif l == 3:
                            v.append(dp[dpi])
                        elif l == 4:
                            v.append("'%s'" % (sqlescape(dp[dpi])))
                        else:
                            v.append(dp[dpi])
                sql = "INSERT INTO tblPerf (ts, %s) VALUES ('%s', %s)" % \
                      (string.join(f, ", "), timenow, string.join(v, ", "))
                #sys.stderr.write(sql)
                cur.execute(sql)

        db.commit()
        cur.close()
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR updating database"

########################################################################################

def handle_suite_status(form):
    suiterun = None

    print "Content-type: text/plain\n"

    if form.has_key("suiterun"):
        suiterun = form["suiterun"].value

    if not suiterun:
        print "ERROR You must specify a suiterun"
        sys.exit(0)

    if form.has_key("resources") and form["resources"].value == "yes":
        # Get a list of jobs recorded for this suite run (this may not
        # be complete is TCs/seqs have been rerun)
        sql = "select s.jobid, jobstart, jobend, mreq, jg.description " \
              "from (select jobid, " \
              "value as jobstart from tbljobdetails where jobid in (select " \
              "jobid from tbljobgroups where gid = 'SR%s') and param = " \
              "'STARTED') s left join  (select jobid, value as jobend from " \
              "tbljobdetails where jobid in (select jobid from tbljobgroups " \
              "where gid = 'SR%s') and param = 'FINISHED') e on s.jobid = " \
              "e.jobid left join (select jobid, value as mreq from " \
              "tbljobdetails where jobid in (select jobid from tbljobgroups " \
              "where gid = 'SR%s') and param = 'MACHINES_REQUIRED') m on " \
              "s.jobid = m.jobid left join tbljobgroups jg on s.jobid = " \
              "jg.jobid where gid = 'SR%s';" % \
              (suiterun, suiterun, suiterun, suiterun)
        cur = db.cursor()
        try:
            cur.execute(sql)
            descs = []
            while True:
                rc = cur.fetchone()
                if not rc:
                    break
                jobid = rc[0]
                if rc[1] and rc[2] and rc[1].strip() and rc[2].strip():
                    duration = time.mktime(time.strptime(\
                        rc[2].strip(), "%a %b %d %H:%M:%S %Y %Z")) - \
                        time.mktime(time.strptime(\
                        rc[1].strip(), "%a %b %d %H:%M:%S %Y %Z"))
                else:
                    duration = None
                if rc[3] and rc[3].strip():
                    machines = int(rc[3])
                else:
                    machines = 1
                jobdesc = rc[4].strip()
                descs.append(jobdesc)
                if duration:
                    durtxt = "%u" % (int(duration))
                else:
                    durtxt = ""
                print "RES_%s=%u,%s,%u" % (jobdesc, jobid, durtxt, machines)
                #if duration:
                #    print "DURATION_%s=%u" % (jobdesc, int(duration))
                #print "MACHINES_%s=%u" % (jobdesc, machines)
            print "JOBDESCS=%s" % (string.join(descs, ","))
        finally:
            cur.close()

    else:
        sql = "SELECT j.jobid, g.description, j.jobstatus from tbljobgroups g INNER JOIN tbljobs j ON j.jobid = g.jobid WHERE g.gid='SR%s'" % suiterun
        cur = db.cursor()
        try:
            cur.execute(sql)
            while True:
                rc = cur.fetchone()
                if not rc:
                    break
                print "%-8s %-15s %s" % (rc[0], rc[1], rc[2])
        finally:
            cur.close()

def handle_runsuite(form):
    suite = None
    revision = None
    branch = None
    sku = None
    suiteseqs = None
    details = {}
    print "Content-type: text/plain\n"

    try:
        if form.has_key("suite"):
            suite = "/etc/xenrt/suites/%s" % form["suite"].value
        if form.has_key("revision"):
            revision = form["revision"].value
        if form.has_key("branch"):
            branch = form["branch"].value
        if form.has_key("sku"):
            sku = "/etc/xenrt/suites/%s" % form["sku"].value
        if form.has_key("suiteseqs"):
            suiteseqs = form["suiteseqs"].value
        if form.has_key("attemptrerun"):
            attemptrerun = True
        else:
            attemptrerun = False
        for key in form.keys():
            if not key in ("suite", "revision", "branch", "sku", "USERID", "action", "suiteseqs", "attemptrerun"):
                details[key] = form[key].value

        if not suite or not revision:
            print "ERROR Missing suite and/or revision"
            sys.exit(0)

        # Form a command line to launch the suite
        cmd = ["xrt", "--run-suite", suite, "-r", revision]
        if branch:
            cmd.extend(["-b", branch])
        if sku:
            cmd.extend(["--sku", sku])
        if suiteseqs:
            cmd.extend(["--suite-seqs", suiteseqs])
        for d in details.keys():
            cmd.extend(["-D", "%s=%s" % (d, details[d])])
        attempts = 0
        tryAgain = True
        while tryAgain:
            attempts += 1
            tryAgain = False
            data = os.popen("%s 2>&1" % string.join(cmd)).read()
            jobs = {}
            suite = None
            for l in data.splitlines():
                m = re.match("Starting (.+)\.\.\. (\d+)", l)
                if m:
                    jobs[m.group(1)] = m.group(2)
                m = re.match("SUITE (\d+)", l)
                if m:
                    suite = m.group(1)
                if re.search("A suite run with this suite and version already exists!", l) and attemptrerun and attempts < 2:
                   cmd.extend(["--rerun-all"])
                   tryAgain = True
                
        if suite:
            print "SR%s" % suite
            for j in jobs.keys():
                print "%s:%s" % (j, jobs[j])
        else:
            sys.stderr.write(data)
            print "ERROR Could not parse the run suite output"
            print data
    except Exception, e:
        sys.stderr.write(str(e))
        traceback.print_exc(file=sys.stderr)
        print "ERROR Exception occurred, see error_log for details"

def handle_power(form):
    machine = None
    powerop = None
    print "Content-type: text/plain\n"

    powerargs = { "off" : "--poweroff", "on": "--poweron", "reboot": "--powercycle" , "nmi": "--nmi"}

    try:
        if form.has_key("machine"):
            machine  = form["machine"].value
        if form.has_key("powerop"):
            powerop = form["powerop"].value
            if powerop not in powerargs.keys():
                print "ERROR Invalid power operation"
                sys.exit(0)

        if not machine or not powerop:
            print "ERROR Missing suite and/or revision"
            sys.exit(0)

        # Form a command line to launch the suite
        cmd = ["xrt", powerargs[powerop], machine]
        print os.popen("%s 2>&1" % string.join(cmd)).read()
    except Exception, e:
        sys.stderr.write(str(e))
        traceback.print_exc(file=sys.stderr)
        print "ERROR Exception occurred, see error_log for details"

def handle_mconfig(form):
    print "Content-type: text/plain\n"
    machine = form['machine'].value
    if form.has_key("generated"):
        try:
            xrtcmd = "--run-tool \"machineXML('%s')\"" % (machine)
            
            # Form a command line to launch the suite
            cmd = ["xrt", xrtcmd]
            print os.popen("%s 2>&1" % string.join(cmd)).read()
        except Exception, e:
            sys.stderr.write(str(e))
            traceback.print_exc(file=sys.stderr)
            print "ERROR Exception occurred, see error_log for details"
    else:
        try:
            f = open("/etc/xenrt/machines/%s.xml" % (machine))
            print f.read()
            f.close()
        except Exception, e:
            print "No config defined, machine config will be taken from racktables"

def handle_network(form):
    print "Content-type: text/plain\n"

    try:
        xrtcmd = "--show-network"
        if form.has_key("ipv6"):
            xrtcmd = "--show-network6"
        
        # Form a command line to launch the suite
        cmd = ["xrt", xrtcmd]
        print os.popen("%s 2>&1" % string.join(cmd)).read()
    except Exception, e:
        sys.stderr.write(str(e))
        traceback.print_exc(file=sys.stderr)
        print "ERROR Exception occurred, see error_log for details"

def htmlEscape(line):
    out = re.sub("&", "&amp;", line)
    out = re.sub("<", "&lt;", out)
    out = re.sub(">", "&gt;", out)
    return out

def processXenRTLog(filehandle):
    print """
<html>
<head>
<title>XenRT Log</title>
<script language = "javascript">
var max = 0;
function toggle(id)
    {
    if (document.getElementById('block' + id).style.display == 'table')
        {
        document.getElementById('block' + id).style.display='none'
        }
    else
        {
        document.getElementById('block' + id).style.display='table';
        }
    }

function expandAll()
    {
    for (i = 0; i < max; i++)
        {
        document.getElementById('block' + i).style.display='table';
        }
    }

function collapseAll()
    {
    for (i = 0; i < max; i++)
        {
        document.getElementById('block' + i).style.display='none';
        }
    }

</script>
</head>
<body>
<pre>
<a href="javascript:expandAll()">Expand All</a> <a href="javascript:collapseAll()">Collapse All</a>
"""
    inVerboseBlock = False
    blockCount = 0
    for l in filehandle.readlines():
        l = htmlEscape(l)
        if not inVerboseBlock:
            if re.match("^\[VERBOSE\]", l):
                inVerboseBlock = True
                verboseText = "%s\n" % l.rstrip()
            else:
                print nonverbLine(l)
        else:
            if not re.match("^\[VERBOSE\]", l) and re.match("^\[[A-Z]+\]", l):
                inVerboseBlock = False
                print verboseSection(verboseText, blockCount)
                print nonverbLine(l)
                blockCount += 1
            else:
                verboseText += "%s\n" % l.rstrip()
    if inVerboseBlock:
        print verboseSection(verboseText, blockCount)
        blockCount += 1
    print "<script language=\"javascript\">max=%d;</script>" % blockCount
    print "<a href=\"javascript:expandAll()\">Expand All</a> <a href=\"javascript:collapseAll()\">Collapse All</a>"

    print "</pre></body></html>"

def verboseSection(text, index):
    out = "<a href=\"javascript:toggle(%d)\">(%d verbose lines)</a></pre>\n" % (index, len(text.splitlines()))
    out += "<div id=\"block%d\" style=\"display:none;background-color:#DDDDDD;margin-left:30px\">\n<pre>" % index
    out += text
    out += "</pre></div><pre>"
    return out
    
def nonverbLine(l):
    s = l.rstrip()
    if re.match("^\[REASON\]", s):
        s = '<span style="background-color: #FF5555;">%s</span>' % s
    return s
            
#############################################################################

form = cgi.FieldStorage(keep_blank_values=True)

if not form.has_key("action"):
    print "Content-type: text/plain\n"
    print "ERROR No action specified"
    sys.exit(0)

action = form["action"].value

# Gather fields for logging
for s in log_fields:
    if form.has_key(s):
        log(s, form[s].value)
if form.has_key("id"):
    log("JOBID", form['id'].value)

if action in ("testlogs", "browse", "browsebinary", "browsefolded", "frame"):
    url = os.environ["REQUEST_URI"]
    url = url.replace("/share/control/", "/xenrt/")
    url = url.replace("/control/", "/xenrt/")
    print "Location:%s\n\n" % url
    sys.exit(0)

if action == "getmasterurl":
    print "Content-type: text/plain\n"
    print _masterurl
elif action == "submit":
    details = {}
    for key in form.keys():
        if key != 'action':
            details[key] = form[key].value
    if details.has_key("MACHINE") and details["MACHINE"] == "ALL":
        # XRT-127
        allto = 86400
        if details.has_key("ALLTIMEOUT"):
            try:
                allto = int(details["ALLTIMEOUT"])
            except:
                pass
        alltimenow = time.mktime(time.localtime())
        details["ALLTIMEOUT"] = "%u" % (int(alltimenow) + allto)
    try:
        id = new_job(details)
    except:
        print "Content-type: text/plain\n"
        print "ERROR Internal error"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)
    print "Content-type: text/plain\n"
    if id == -1:
        print "ERROR Could not create new job"
    else:
        print "OK " + `id`
        log("JOBID", `id`)

elif action == "schedule":
    dryrun = False
    ignore = False
    verbose = False
    if form.has_key("dryrun") and form["dryrun"].value == "yes":
        dryrun = True
    if form.has_key("ignore") and form["ignore"].value == "yes":
        ignore = True
    if form.has_key("verbose") and form["verbose"].value == "yes":
        verbose = True
    schedule_jobs(dryrun=dryrun, ignore=ignore, verbose=verbose)

elif action == "mlist2":
    handle_mlist(form)
elif action == "mstatus":
    handle_mstatus(form)
elif action == "mdefine":
    handle_mdefine(form)
elif action == "mundefine":
    handle_mundefine(form)
elif action == "borrow":
    handle_borrow(form)
elif action == "return":
    handle_return(form)
elif action == "slist":
    handle_slist(form)
elif action == "sdefine":
    handle_sdefine(form)
elif action == "sundefine":
    handle_sundefine(form)
elif action == "subresults":
    handle_subresults(form)
elif action == "perfdata":
    handle_perfdata(form)
elif action == "suitestatus":
    handle_suite_status(form)
elif action == "runsuite":
    handle_runsuite(form)
elif action == "power":
    handle_power(form)
elif action == "network":
    handle_network(form)
elif action == "mconfig":
    handle_mconfig(form)
elif action == "warnings":
    handle_warnings_etc(form)

elif action == "machine":
    if not form.has_key("machine"):
        print "Content-type: text/plain\n"
        print "ERROR No machine supplied"
        sys.exit(0)
    machine = form["machine"].value
    html = 0
    if form.has_key("html") and form["html"].value == "yes":
        html = 1
    if html:
        print "Content-type: text/html\n"
    else:
        print "Content-type: text/plain\n"
    try:
        m = machine_data(machine)
        if html:
            print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
            "http://www.w3.org/TR/html4/loose.dtd">
            <HTML>
            <head>
            <title>XenRT - test detail</title>
            <link href="style.css" rel="stylesheet" type="text/css">
            </head>

            <BODY>
            <div id="contents-results">
            """

            print """
            <table>
            """

        for key in m.keys():
            if html:
                print "<tr><td><b>%s</b></td><td>%s</td></tr>" % \
                      (key, m[key])
            else:
                print "%s=%s\n" % (key, m[key])

        if html:
            print "</table>"
            print "</div></BODY></HTML>"

    except:
        print "ERROR Could not find machine " + machine

elif action == "site":
    if not form.has_key("site"):
        print "Content-type: text/plain\n"
        print "ERROR No machine supplied"
        sys.exit(0)
    site = form["site"].value
    html = 0
    if form.has_key("html") and form["html"].value == "yes":
        html = 1
    if html:
        print "Content-type: text/html\n"
    else:
        print "Content-type: text/plain\n"
    try:
        s = site_data(site)
        if html:
            print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
            "http://www.w3.org/TR/html4/loose.dtd">
            <HTML>
            <head>
            <title>XenRT - test detail</title>
            <link href="style.css" rel="stylesheet" type="text/css">
            </head>

            <BODY>
            <div id="contents-results">
            """

            print """
            <table>
            """

        for key in s.keys():
            if html:
                print "<tr><td><b>%s</b></td><td>%s</td></tr>" % \
                      (key, s[key])
            else:
                print "%s=%s\n" % (key, s[key])
        availableresources = site_available_shared_resources(site)
        availableresourcestext = "/".join(map(lambda x:"%s=%s" % (x, availableresources[x]), availableresources.keys()))
        print "AVAILABLERESOURCES='%s'" % availableresourcestext

        if html:
            print "</table>"
            print "</div></BODY></HTML>"

    except:
        print "ERROR Could not find site " + site

elif action == "status":
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    html = 0
    if form.has_key("html") and form["html"].value == "yes":
        html = 1
    if html:
        print "Content-type: text/html\n"
    else:
        print "Content-type: text/plain\n"

    parsed = get_job(id)

    if len(parsed) == 0:
        print "ERROR Could not find job " + `id`
        sys.exit(0)

    if html:
        print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
        <head>
        <title>XenRT - test detail</title>
        <link href="style.css" rel="stylesheet" type="text/css">
        </head>
        
        <BODY>
        <div id="contents-results">
        """

        print """
        <table>
        """

        # Print CHECK first (XRT-303)
        if parsed.has_key('CHECK'):
            print "<tr><td><b>%s</b></td><td>%s</td></tr>" % \
                  ("CHECK", parsed["CHECK"])
        for key in parsed.keys():
            if key != "CHECK":
                print "<tr><td><b>%s</b></td><td>%s</td></tr>" % \
                      (key, parsed[key])

        print "</table>"

        print "</div></BODY></HTML>"

    else:
        if parsed.has_key('CHECK'):
            print "%s='%s'" % ("CHECK", parsed["CHECK"])                  
        for key in parsed.keys():
            if key != "CHECK":
                print "%s='%s'" % (key, parsed[key])

elif action == "complete":
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    print "Content-type: text/plain\n"
    try:
        set_status(id, JOB_STATUS_DONE, commit=True)
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Could not mark job as complete"

elif action == "email_raw":
    print "Content-type: text/plain\n"
    try:
        sender = form["sender"].value
        recipient = form["recipient"].value
        subject = form["subject"].value
        message = form["message"].value
        
        send_mail(sender, [recipient], subject, message)
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Could not send email"

elif action == "email":
    if not email_sender:
        print "Content-type: text/plain\n"
        print "OK But no email configuration so nothing sent"
        sys.exit(0)
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    print "Content-type: text/plain\n"
    try:
        parsed = get_job(id)
        if parsed.has_key("EMAIL"):
            if parsed.has_key("SCHEDULEDON"):
                machine = parsed["SCHEDULEDON"]
                if parsed.has_key("SCHEDULEDON2"):
                    machine = machine + "," + parsed["SCHEDULEDON2"]
                if parsed.has_key("SCHEDULEDON3"):
                    machine = machine + "," + parsed["SCHEDULEDON3"]
            elif parsed.has_key("MACHINE"):
                machine = parsed["MACHINE"]
            else:  
                machine = "unknown"
            if parsed.has_key("CHECK"):
                result = parsed["CHECK"]
            elif parsed.has_key("RETURN"):
                result = parsed["RETURN"]
            else:
                result = "unknown"
            if parsed.has_key("JOBDESC"):
                jobdesc = "%s (JobID %u)" % (parsed["JOBDESC"], id)
            else:
                jobdesc = "JobID %u" % (id)
            me = os.path.basename(sys.argv[0])
            emailto = string.split(parsed["EMAIL"], ",")
            subject = "[xenrt] %s %s %s" % (jobdesc, machine, result)
            summary = showlog(id, "yes", "yes")
            message = """
================ Summary =============================================
%s%s?action=frame&title=JobID%%20%u&jobs=%u
======================================================================
%s
======================================================================
""" % (url_base, me, id, id, summary)
            for key in parsed.keys():
                message =  message + "%s='%s'\n" % (key, parsed[key])
            send_mail(email_sender, emailto, subject, message, reply=emailto[0])
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Could not send summary email"


elif action == "list":
    if form.has_key("fields"):
        fields = string.split(form["fields"].value, ",")
    else:
        fields = []
    filter = {}
    for f in form.keys():
        if f[0:7] == "filter_":
            filter[f[7:]] = form[f].value
    print "Content-type: text/plain\n"
    try:
        list_job_details(fields, filter, sys.stdout)
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Error listing jobs"

elif action == "update":
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    print "Content-type: text/plain\n"
    try:
        for key in form.keys():
            if key != 'action' and key != 'id':
                update_field(id, key, form[key].value)
        print "OK"
    except:
        print "ERROR Internal error"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)

elif action == "mupdate":
    if not form.has_key("machine"):
        print "Content-type: text/plain\n"
        print "ERROR No machine supplied"
        sys.exit(0)
    machine = form["machine"].value
    print "Content-type: text/plain\n"
    try:
        for key in form.keys():
            if key != 'action' and key != 'machine':
                if key == "SUBPOOL" or key == "POOL":
                    scm_machine_update(machine,
                                       None,
                                       None,
                                       form[key].value,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None)
                elif key == "SITE":
                    scm_machine_update(machine,
                                       form[key].value,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None)
                elif key == "CLUSTER":
                    scm_machine_update(machine,
                                       None,
                                       form[key].value,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None)
                elif key == "RESOURCES":
                    scm_machine_update(machine,
                                       None,
                                       None,
                                       None,
                                       None,
                                       form[key].value,
                                       None,
                                       None,
                                       None)
                elif key == "FLAGS":
                    scm_machine_update(machine,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       form[key].value,
                                       None,
                                       None)
                elif key == "DESCRIPTION":
                    scm_machine_update(machine,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       form[key].value,
                                       None)
                elif key == "LEASEPOLICY":
                    scm_machine_update(machine,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       None,
                                       form[key].value)
                else:
                    update_machine_param(machine, key, form[key].value)
        print "OK"
    except:
        print "ERROR Internal error"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)

elif action == "supdate":
    if not form.has_key("site"):
        print "Content-type: text/plain\n"
        print "ERROR No site supplied"
        sys.exit(0)
    site = form["site"].value
    print "Content-type: text/plain\n"
    try:
        for key in form.keys():
            if key != 'action' and key != 'site':
                if key == "STATUS":
                    scm_site_update(site,
                                    form[key].value,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None)
                elif key == "FLAGS":
                    scm_site_update(site,
                                    None,
                                    form[key].value,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None)
                elif key == "DESCRIPTION":
                    scm_site_update(site,
                                    None,
                                    None,
                                    form[key].value,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None)
                elif key == "COMMENT":
                    scm_site_update(site,
                                    None,
                                    None,
                                    None,
                                    form[key].value,
                                    None,
                                    None,
                                    None,
                                    None)
                elif key == "CTRLADDR":
                    scm_site_update(site,
                                    None,
                                    None,
                                    None,
                                    None,
                                    form[key].value,
                                    None,
                                    None,
                                    None)
                elif key == "ADMINID":
                    scm_site_update(site,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    form[key].value,
                                    None,
                                    None)
                elif key == "MAXJOBS":
                    scm_site_update(site,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    int(form[key].value),
                                    None)
                elif key == "SHAREDRESOURCES":
                    scm_site_update(site,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    None,
                                    form[key].value)
                elif key in ("+FLAGS", "-FLAGS"):
                    scm_flags_modify(site, key, form[key].value)
                else:
                    print "ERROR Unknown site parameter '%s'" % (key)
                    sys.exit(0)
        print "OK"
    except:
        print "ERROR Internal error"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)

elif action == "upload":
    prefix = ""
    phase = None
    test = None
    if form.has_key("phase"):
        phase = form["phase"].value
    if form.has_key("test"):
        test = form["test"].value
    if form.has_key("prefix"):
        prefix = form["prefix"].value
        prefix = string.replace(prefix, '<', '')
        prefix = string.replace(prefix, '>', '')
        prefix = string.replace(prefix, '/', '')
        prefix = string.replace(prefix, '&', '')
        prefix = string.replace(prefix, '\\', '')
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)

    # See if this is for a particular test
    if phase and test:
        detailid = lookup_detailid(id, phase, test)
        if detailid == -1:
            print "Content-type: text/plain\n"
            print "ERROR Could not find detailID for %u %s %s" % \
                  (id, phase, test)
            sys.exit(0)
        id = detailid
        prefix = "test"

    if not form.has_key("file"):
        print "Content-type: text/plain\n"
        print "ERROR No file supplied"
        sys.exit(0)
    data = None
    fh = form["file"].file
    if not fh:
        #print "Content-type: text/plain\n"
        #print "ERROR File field does not contain any data"
        #sys.exit(0)
        data = form["file"].value
    print "Content-type: text/plain\n"
    try:
        upload(id, fh, data, prefix=prefix)
        print "OK"
    except:
        print "ERROR Internal error"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)

    if phase and test:
        update_detailid_uploaded(id, "yes")
    
elif action == "download":
    if not form.has_key("id"):
        sys.exit(0)
    id = string.atoi(form["id"].value)
    print "Content-type: application/octet-stream"
    print "Content-Disposition: attachment; filename=\"%d.bz2\"\n" % (id)
    if form.has_key("prefix"):
        prefix = form["prefix"].value
        prefix = string.replace(prefix, '<', '')
        prefix = string.replace(prefix, '>', '')
        prefix = string.replace(prefix, '/', '')
        prefix = string.replace(prefix, '&', '')
        prefix = string.replace(prefix, '\\', '')
    elif form.has_key("phase") and form.has_key("test"):
        id = lookup_detailid(id, form["phase"].value, form["test"].value)
        if id == -1:
            print "ERROR Specified test not found"
            sys.exit(0)
        prefix = "test"
    else:
        prefix = ""

    try:
        download(id, sys.stdout, prefix=prefix)
    except Exception, e:
        if isinstance(e, IOError):
            # We can still report error to client at this point
            print "ERROR File missing"
        traceback.print_exc(file=sys.stderr)
        sys.exit(0)

elif action == "testlogs":

    me = os.path.basename(sys.argv[0])

    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)

    if not form.has_key("phase"):
        print "Content-type: text/plain\n"
        print "ERROR No phase supplied"
        sys.exit(0)

    if not form.has_key("test"):
        print "Content-type: text/plain\n"
        print "ERROR No test supplied"
        sys.exit(0)

    jobid = string.atoi(form["id"].value)
    phase = form["phase"].value
    test = form["test"].value

    # Find the detailid and redirect to the browse page
    detailid = lookup_detailid(jobid, phase, test)
    if detailid == -1:
        print "Content-type: text/plain\n"
        print "ERROR Logs not found for %s/%s" % (phase,test)
        sys.exit(0)

    # Redirect
    print "Location: %s?action=browse&html=yes&test=yes&id=%s\n" % (me,detailid)
    sys.exit(0)

elif action == "browse":

    me = os.path.basename(sys.argv[0])

    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    html = 0
    filepref = ""
    linkpref = ""
    linkprefb = ""
    if form.has_key("html") and form["html"].value == "yes":
        html = 1
        linkpref = "%s?action=browse&id=%u&html=yes" % (me, id)
        linkprefb = "%s?action=browsebinary&id=%u&html=yes" % (me, id)
        linkprefc = "%s?action=browsefolded&id=%u&html=yes" % (me, id)
    job = id
    if form.has_key("test") and form["test"].value == "yes":
        filepref = "test"
        linkpref = linkpref + "&test=yes"
        linkprefb = linkprefb + "&test=yes"
        linkprefc = linkprefc + "&test=yes"
        job = lookup_jobid(id)
    details = get_job(job)

    if details.has_key("LOG_SERVER") and details["LOG_SERVER"] != os.environ["SERVER_NAME"]:
        # Redirect to the log server
        url = "http://%s%s" % (details["LOG_SERVER"], os.environ["REQUEST_URI"])
        print "Location:%s\n" % url
    elif not details.has_key("LOG_SERVER") and urlparse.urlsplit(_masterurl).netloc != os.environ["SERVER_NAME"]:
        # Redirect to the master server if we're not already there and a log server isn't specified
        url = "http://%s%s" % (urlparse.urlsplit(_masterurl).netloc, os.environ["REQUEST_URI"])
        print "Location:%s\n" % url

    else:
        if html == 1:
            print "Content-type: text/html\n"
        else:
            print "Content-type: text/plain\n"
            
        filename = ""
        if form.has_key("filename"):
            filename = form["filename"].value

        htmlheader = """
        <HTML>
          <HEAD>
            <TITLE>XenRT log browser: %s</TITLE>
          </HEAD>
          <BODY>
        """ % (filename)

        htmlfooter = """
          </BODY>
        </HTML>
        """

        tarfile = results_filename(filepref, id, find=1)
        if filename == "":
            if html:
                print htmlheader
            p = os.popen("tar -jvtf %s" % (tarfile))
            while 1:
                line = p.readline()
                if not line:
                    break
                line = string.strip(line)
                all = line.split()
                line = " ".join(all[5:len(all)])
                size = int(all[2])
                if size > 1024:
                    size = size / 1024
                    if size > 1024:
                        size = size / 1024
                        size = "%uM" % (size)
                    else:
                        size = "%uK" % (size)
                else:
                    size = "<1K"
                if line[0:2] == "./":
                    dline = line[2:]
                else:
                    dline = line
                if line [-1:] != "/":
                    if html:
                        if string.split(line, ".")[-1] in ('gz',
                                                           'tgz',
                                                           'bz2',
                                                           'tbz2',
                                                           'zip',
                                                           'exe'):
                            print "<BR><A href=\"%s&%s\">%s (%s)</A>" % \
                                  (linkprefb, urllib.urlencode({"filename": line}),
                                   dline,size)
                        elif dline.strip() == "xenrt.log":
                            print "<BR><A href=\"%s&%s\">%s (%s)</A> " \
                                  "(<A href=\"%s&%s\">raw</A>) <b>(<A href=\"%s&%s\">folded</A>)</b>" % \
                                  (linkpref,
                                   urllib.urlencode({"filename": line}),
                                   dline,size,
                                   linkprefb,
                                   urllib.urlencode({"filename": line}),
                                   linkprefc,
                                   urllib.urlencode({"filename": line}))
                            
                        else:
                            print "<BR><A href=\"%s&%s\">%s (%s)</A> " \
                                  "(<A href=\"%s&%s\">raw</A>)" % \
                                  (linkpref,
                                   urllib.urlencode({"filename": line}),
                                   dline,size,
                                   linkprefb,
                                   urllib.urlencode({"filename": line}))
                    else:
                        print dline
            if html:    
                print htmlfooter
            p.close()
        else:
            if string.split(filename, ".")[-1] in ('png',
                                               'jpg',
                                               'jpeg',
                                               'gif'):
                print htmlheader
                print "<img src=\"%s&%s\" />" % (linkprefb, urllib.urlencode({"filename": filename}))
                print htmlfooter
            else:
                p = os.popen('tar -jxf %s -O "%s"' % (tarfile, filename))
                line = p.readline()
                if not line:
                    line = ""
                if re.search(r"<html>", line, re.IGNORECASE) or \
                   filename[-5:] == ".html" or \
                   filename[-4:] == ".htm" or \
                   filename[-4:] == ".css" or \
                   filename[-3:] == ".js":
                    dataishtml = True
                else:
                    dataishtml = False
                if html and not dataishtml:
                    print htmlheader
                    print "<PRE>"
                base = "%s&%s/" % \
                       (linkpref,
                        urllib.urlencode({"filename": os.path.dirname(filename)}))
                while 1:
                    if not dataishtml:
                        line = string.replace(line, "<", "&lt;")
                        line = string.replace(line, ">", "&gt;")
                    else:
                        for x in ("href", "HREF", "src", "SRC"):
                            line = re.sub(r"%s=\"([^/]+?)\"" % (x),
                                          "%s=\"%s\\1\"" % (x, base),
                                          line)
                    sys.stdout.write(line)
                    line = p.readline()
                    if not line:
                        break
                if html and not dataishtml:
                    print "</PRE>"
                    print htmlfooter
                p.close()

elif action == "browsebinary":

    me = os.path.basename(sys.argv[0])

    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    job = id
    html = 0
    filepref = ""
    linkpref = ""
    if form.has_key("test") and form["test"].value == "yes":
        filepref = "test"
        linkpref = linkpref + "&test=yes"
        job = lookup_jobid(id)
    details = get_job(job)

    if details.has_key("LOG_SERVER") and details["LOG_SERVER"] != os.environ["SERVER_NAME"]:
        # Redirect to the log server
        url = "http://%s%s" % (details["LOG_SERVER"], os.environ["REQUEST_URI"])
        print "Location:%s\n" % url
    elif not details.has_key("LOG_SERVER") and urlparse.urlsplit(_masterurl).netloc != os.environ["SERVER_NAME"]:
        # Redirect to the master server if we're not already there and a log server isn't specified
        url = "http://%s%s" % (urlparse.urlsplit(_masterurl).netloc, os.environ["REQUEST_URI"])
        print "Location:%s\n" % url

    else:
        filename = ""
        if form.has_key("filename"):
            filename = form["filename"].value

        suffix = string.lower(string.split(filename, ".")[-1])
        if suffix in ("jpg", "jpeg"):
            t = "image/jpeg"
        elif suffix == "gif":
            t = "image/gif"
        elif suffix == "png":
            t = "image/png"
        elif suffix in ("gz", "tgz"):
            t = "application/x-gzip"
        elif suffix == "b2z":
            t = "application/x-bzip2"
        elif suffix == "zip":
            t = "application/zip"
        else:
            t = "application/data"
        print "Content-type: %s" % (t)
        print "Content-Disposition: attachment; filename=\"%s\"\n" % \
              (os.path.basename(filename))
        tarfile = results_filename(filepref, id, find=1)
        p = os.popen('tar -jxf %s -O "%s"' % (tarfile, filename))
        shutil.copyfileobj(p, sys.stdout)
        p.close()

elif action == "browsefolded":

    me = os.path.basename(sys.argv[0])

    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    html = 0
    filepref = ""
    linkpref = ""
    if form.has_key("test") and form["test"].value == "yes":
        filepref = "test"
        linkpref = linkpref + "&test=yes"

    filename = ""
    if form.has_key("filename"):
        filename = form["filename"].value

    print "Content-type: text/html\n"
    tarfile = results_filename(filepref, id, find=1)
    p = os.popen("tar -jxf %s -O %s" % (tarfile, filename))
    processXenRTLog(p)
    p.close()

elif action == "remove":
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    print "Content-type: text/plain\n"
    try:
        # We leave the job as it is but mark it as "removed" so it
        # doesn't show in lists. This is becauses users keep on
        # removing running jobs thereby confusing the daemon
        update_field(id, "REMOVED", "yes")
        print "OK"
    except:
        traceback.print_exc(file=sys.stderr)
        print "ERROR Could not remove job"

elif action == "showlog":
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    if not form.has_key("verbose"):
        verbose = "no"
    else:
        verbose = form["verbose"].value
    if not form.has_key("wide"):
        wide = "no"
    else:
        wide = form["wide"].value
    if form.has_key("times") and form['times'].value[0] == 'y':
        times = True
    else:
        times = False
    print "Content-type: text/plain\n"
    sys.stdout.write(showlog(id, wide, verbose, times=times))

elif action == "setresult":
    timenow = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(time.time()))
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    if not form.has_key("phase"):
        print "Content-type: text/plain\n"
        print "ERROR No phase supplied"
        sys.exit(0)
    phase = form["phase"].value
    if not form.has_key("test"):
        print "Content-type: text/plain\n"
        print "ERROR No test supplied"
        sys.exit(0)
    test = form["test"].value
    if not form.has_key("result"):
        print "Content-type: text/plain\n"
        print "ERROR No result supplied"
        sys.exit(0)
    result = form["result"].value

    cur = db.cursor()

    print "Content-type: text/plain\n"

    # Make sure this phase+test combination exists in the lookup table
    cur.execute(("SELECT phase,test FROM tlkptestphase WHERE phase='%s' " +
                 "AND test='%s';") % (phase,test))
    if not cur.rowcount:
        cur.execute(("INSERT INTO tlkptestphase (phase,test) VALUES ('%s'," +
                     "'%s');") % (phase,test))

    cur.execute(("SELECT jobid, phase, test, result FROM tblResults " +
                 "WHERE jobid = %u AND phase = '%s' AND test = '%s';") %
                (id, phase, test))
    rc = cur.fetchone()
    if not rc:
        cur.execute("INSERT INTO tblResults (jobid, phase, test, result) "
                    "VALUES (%u, '%s', '%s', '%s');" %
                    (id, phase, test, result))
    else:
        cur.execute(("UPDATE tblResults SET result = '%s' WHERE jobid = %u " +
                     " AND phase = '%s' AND test = '%s';") %
                    (result, id, phase, test))

    # Also add to the detailed history
    cur.execute(("SELECT detailid FROM tblResults " +
                 "WHERE jobid = %u AND phase = '%s' AND test = '%s';") %
                (id, phase, test))
    rc = cur.fetchone()
    if not rc:
        print "ERROR Could not get detailid for test"
        cur.close()
        db.close()
        sys.exit(0)
    else:
        detailid = int(rc[0])
        cur.execute(
            "INSERT INTO tblDetails (detailid, ts, key, value) VALUES "
            "(%u, '%s', 'result', '%s');" % (detailid, timenow, result))
        
    db.commit()
    cur.close()
    print "OK"

elif action == "event":
    timenow = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(time.time()))
    if not form.has_key("etype"):
        print "Content-type: text/plain\n"
        print "ERROR No event type supplied"
        sys.exit(0)
    etype = form["etype"].value
    if not form.has_key("subject"):
        print "Content-type: text/plain\n"
        print "ERROR No subject supplied"
        sys.exit(0)
    subject = form["subject"].value
    if not form.has_key("edata"):
        print "Content-type: text/plain\n"
        print "ERROR No event data supplied"
        sys.exit(0)
    edata = form["edata"].value

    cur = db.cursor()

    print "Content-type: text/plain\n"

    try:
        cur.execute("INSERT INTO tblEvents (ts, etype, subject, edata) "
                    "VALUES ('%s', '%s', '%s', '%s');" %
                    (timenow, etype, subject, edata))
        
        db.commit()
        cur.close()
        print "OK"
    except:
        print "ERROR Database error"

elif action == "logdata":
    timenow = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(time.time()))
    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)
    id = string.atoi(form["id"].value)
    if not form.has_key("phase"):
        print "Content-type: text/plain\n"
        print "ERROR No phase supplied"
        sys.exit(0)
    phase = form["phase"].value
    if not form.has_key("test"):
        print "Content-type: text/plain\n"
        print "ERROR No test supplied"
        sys.exit(0)
    test = form["test"].value
    if not form.has_key("key"):
        print "Content-type: text/plain\n"
        print "ERROR No key supplied"
        sys.exit(0)
    key = form["key"].value
    if not form.has_key("value"):
        print "Content-type: text/plain\n"
        print "ERROR No value supplied"
        sys.exit(0)
    value = form["value"].value

    cur = db.cursor()

    print "Content-type: text/plain\n"

    # Make sure this phase+test combination exists in the lookup table
    cur.execute(("SELECT phase,test FROM tlkptestphase WHERE phase='%s' " +
                 "AND test='%s';") % (phase,test))
    if not cur.rowcount:
        cur.execute(("INSERT INTO tlkptestphase (phase,test) VALUES ('%s'," +
                     "'%s');") % (phase,test))

    # Make sure we have a result field for this test
    result = ""
    if key == "result":
        result = value
    detailid = 0
    cur.execute(("SELECT detailid FROM tblResults " +
                 "WHERE jobid = %u AND phase = '%s' AND test = '%s';") %
                (id, phase, test))
    rc = cur.fetchone()
    if not rc:
        cur.execute("INSERT INTO tblResults (jobid, phase, test, result) "
                    "VALUES (%u, '%s', '%s', '%s');" %
                    (id, phase, test, result))
        cur.execute(("SELECT detailid FROM tblResults " +
                     "WHERE jobid = %u AND phase = '%s' AND test = '%s';") %
                    (id, phase, test))
        rc = cur.fetchone()
        if not rc:
            print "ERROR Could not get detailid for test"
            cur.close()
            db.close()
            sys.exit(0)
        else:
            detailid = int(rc[0])
    else:
        detailid = int(rc[0])

    if len(key) > 24:
        key = key[0:24]
    if len(value) > 255:
        value = value[0:255]
    value = string.replace(value, "'", "\\'")
    cur.execute("INSERT INTO tblDetails (detailid, ts, key, value) "
                "VALUES (%u, '%s', '%s', '%s');" %
                (detailid, timenow, key, value))

    # If the key was "result" the update the result in tblResult as well
    if key == "result":
        cur.execute(("UPDATE tblResults SET result = '%s' WHERE jobid = %u " +
                     " AND phase = '%s' AND test = '%s';") %
                    (value, id, phase, test))

    # If the key was "warning" then modify the result in tblResult
    if key == "warning":
        cur.execute(("SELECT result FROM tblResults WHERE jobid = %u " +
                     "AND phase = '%s' AND test = '%s';") % (id, phase, test))
        rc = cur.fetchone()
        if rc and rc[0]:
            result = string.strip(rc[0])
        else:
            result = "unknown"
        if result[-2:] != "/w":
            result = result + "/w"
        cur.execute(("UPDATE tblResults SET result = '%s' WHERE jobid = %u " +
                     " AND phase = '%s' AND test = '%s';") %
                    (result, id, phase, test))
        
    db.commit()
    cur.close()
    print "OK"

elif action == "detail":

    big = 1

    if not form.has_key("detailid"):
        print "Content-type: text/plain\n"
        print "ERROR No detail ID supplied"
        sys.exit(0)
    detailid = string.atoi(form["detailid"].value)

    cur = db.cursor()

    print "Content-type: text/html\n"
    print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
    <head>
    <title>XenRT - test detail</title>
    <link href="style.css" rel="stylesheet" type="text/css">
    </head>

    <BODY>
    <div id="contents-results">
    """ 

    cur.execute(("SELECT phase, test, result, jobid FROM qryResults " +
                 "WHERE detailid = %u") % (detailid))                
    rc = cur.fetchone()    
    if rc:
        phase = string.strip(rc[0])
        test = string.strip(rc[1])
        jobid = rc[3]
        print "<p>%-10s %-12s %-10s</p>" % \
              (phase, test, string.strip(rc[2]))
    else:
        jobid = None

    cur.execute("SELECT options, version FROM tblJobs WHERE jobid = %u" %
                (jobid))
    rc = cur.fetchone()
    if rc:
        options = string.strip(rc[0])
        version = string.strip(rc[1])
    else:
        jobid = None

    sql = "SELECT d.ts, d.key, d.value, NULL, NULL, NULL FROM " \
          "tblDetails d  WHERE d.detailid = %u ORDER BY d.ts;" % \
          (detailid)

    sys.stderr.write("detail: %s\n" % (sql))
    cur.execute(sql)
    
    print """
    <table>
    <tr>
    <td width="100px"><b>Date / Time</b></td>
    <td width="100px"><b>Key</b></td>
    <td><b>Value</b></td>
    </tr>
    """
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        key = string.strip(rc[1])
        value = string.strip(rc[2])
        if key == "result":
            col = colour_tag(value)
        else:
            col = ""
        units = ""
        if rc[3]:
            units = " " + string.strip(rc[3])
        rel = ""
        if rc[4]:
            try:
                v = float(rc[4]) * 100
                if v < 0:
                    rel = " (-%.2f%%)" % (abs(v))
                else:
                    rel = " (+%.2f%%)" % (v)
            except:
                pass
        
        keydisp = key
        print "<tr><td>%s</td><td>%s</td><td %s>%s%s%s</td></tr>" % \
              (string.strip(rc[0]), keydisp, col, value, units, rel)
               
    print "</table>"

    print "</div></BODY></HTML>"

    cur.close()

elif action == "frame":

    me = os.path.basename(sys.argv[0])

    f = {}
    filteraction = None
    for key in form.keys():
        if key == "filteraction":
            filteraction = form[key].value
        elif key != "action":
            f[key] = form[key].value

    if form.has_key("query"):
        f['action'] = "doquery"
        if not filteraction:
            filteraction = "squery"
    else:
        f['action'] = 'matrix'
        if not filteraction:
            filteraction = "filter"

    qstr = urllib.urlencode(f)

    if form.has_key("title"):
        title = form["title"].value
    else:
        title = "XenRT"

    print """Content-type: text/html

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>%s</TITLE>
</HEAD>

<frameset cols="*,400" frameborder="0" border="1">
    <frameset rows="50,*" frameborder="0" border="1">
""" % (title)

    print "<frame name=\"filter\" src=\"%s?action=%s\">" % (me,filteraction)
    print "<frame name=\"matrix\" src=\"%s?%s\">" % (me, qstr)

    print """
  </frameset>
  <frameset rows="300,*" frameborder="0" border="1">
    <frame name="jobdesc" src="blank.html">
"""
    if form.has_key("detailid"):
        print """    <frame name="testdesc" src="%s?action=detail&detailid=%s">
""" % (me, form['detailid'].value)
    else:
        print """    <frame name="testdesc" src="blank.html">
"""
    print """  </frameset>
</frameset>


</HTML>
    """

elif action == "squery":

    me = os.path.basename(sys.argv[0])

    cur = db.cursor()

    print """Content-type: text/html

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <HTML>
      <HEAD>
        <link href="style.css" rel="stylesheet" type="text/css">
      </HEAD>
      <BODY>
        <TABLE border="0"><TR>
    """

    print "<TD valign=\"top\"><FORM action=\"%s\" method=\"POST\" target=\"matrix\">" % (me)

    print """
        <TD valign="top"><FORM action=\"%s\" method=\"POST\" target=\"matrix\">
          <INPUT type="hidden" name="action" value="matrix">
          Jobs:&nbsp;<INPUT type="text" name="jobs" width=12>
          <INPUT type="submit" value="Display">&nbsp;&nbsp;
        </FORM></TD>
    """ % (me)
    
    print """    
    </TR></TABLE>
    </BODY>
    </HTML>
    """ % (me)

    cur.close()

elif action =="jobidfromdetailid":
    print "Content-type: text/html\n"
    print lookup_jobid(form["detailid"].value)

elif action == "jobidsfromdetailids":
    print "Content-type: text/plain\n"
    for key in form.keys():
        if not key in ("USERID", "action"):
            print "%s:%s" % (form[key].value, lookup_jobid(form[key].value))
    
elif action == "matrix":

    cur = db.cursor()

    query = []
    jobiddesc = {}
    joborder = []
    hdgdepth = 1
    maxjobs = 50

    if form.has_key("jobs") or form.has_key("detailid"):
        if form.has_key("jobs"):
            joblist = form["jobs"].value
        else:
            joblist = str(lookup_jobid(form["detailid"].value))
        for j in string.split(joblist, ","):
            ll = string.split(j, ":", 1)
            if len(ll) == 2:
                joborder.append(`string.atoi(ll[0])`)
                jobiddesc[`string.atoi(ll[0])`] = \
                        string.split(string.strip(ll[1]), "&")
                if len(jobiddesc[`string.atoi(ll[0])`]) > hdgdepth:
                    hdgdepth = len(jobiddesc[`string.atoi(ll[0])`])
            elif len(ll) == 1:
                joborder.append(`string.atoi(ll[0])`)
        if len(joborder) > 0:
            query.append("jobid in (%s)" % (string.join(joborder, ",")))
        
    querystr = "SELECT jobid, uploaded FROM tblJobs"
    if len(query) > 0:
        querystr = querystr + " WHERE " + string.join(query, " AND ")
    querystr = querystr + " ORDER BY jobid;"
    cur.execute(querystr)
    id2 = []
    jobdata = {}
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        jobid = "%s" % (rc[0])
        id2.append(jobid)
        jobdata[jobid] = {}
        if rc[1]:
            jobdata[jobid]["UPLOADED"] = string.strip(rc[1])
    ids = string.join(id2, ",")

    me = os.path.basename(sys.argv[0])

    print "Content-type: text/html\n"
    print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
    <head>
    <title>XenRT</title>
    <link href="style.css" rel="stylesheet" type="text/css">
    <script language="JavaScript">
    function openkey() {
        window.open("%s?action=key", "xenrtkey", "toolbar=0, directories=0, location=0, status=0, menubar=0, scrollbars=1, resizable=1, width=100,height=800");
    }
    </script>
    </head>

    <BODY>

    <div id="tableContainer">
    """ % (me)

    # Get phase/test membership
    cur.execute("SELECT phase, test, phasedesc, testdesc FROM " +
                "qryphasetests;")
    phases = []
    phase = None
    desc = ""
    plast = ""
    tlast = ""
    while 1:
        rc = cur.fetchone()
        if not rc:
            break
        p = string.strip(rc[0])
        t = string.strip(rc[1])
        if plast == p and tlast == t:
            continue
        plast = p
        tlast = t
        if rc[2]:
            pd = string.strip(rc[2])
        else:
            pd = ""
        if rc[3]:
            td = string.strip(rc[3])
        else:
            td = ""
        if not phase or p != phase:
            if phase:
                phases.append((phase, tests, desc))
            desc = pd
            phase = p
            tests = []
        tests.append((t, td))
    if tests:
        phases.append((phase, tests, desc))

    # Get data for select job ids - santise the ID list first
    idlist = string.split(ids, ",")
    jobs = []
    for id in idlist:
        try:
            i = int(id)
            jobs.append(`i`)
        except ValueError:
            pass
    # Cap the number of jobs to display
    if len(jobs) > maxjobs:
        jobs = jobs[0-maxjobs:]
    idlist = string.join(jobs, ",")
    data = {}
    if idlist != "":
        cur.execute("SELECT r.jobid, r.phase, r.test, r.result, "
                    "r.detailid, r.uploaded, NULL AS worst "
                    "FROM qryResults r "
                    "WHERE r.jobid IN (%s) ORDER BY r.jobid;" %
                    (idlist))

        while 1:
            rc = cur.fetchone()
            if not rc:
                break
            j = string.strip(`rc[0]`)
            p = string.strip(rc[1])
            if rc[2]:
                t = string.strip(rc[2])
            else:
                t = ""
            if not rc[3]:
                r = ""
            else:
                r = string.strip(rc[3])
            d = string.strip(`rc[4]`)
            if rc[5]:
                u = string.strip(rc[5])
            else:
                u = ""
            if rc[6]:
                try:
                    rs = float(rc[6])
                except:
                    rs = None
            else:
                rs = None
            if not data.has_key(p):
                data[p] = {}
            if not data[p].has_key(t):
                data[p][t] = {}
            data[p][t][j] = (r, d, u, rs)

    # jobs is a list of jobids that we are actually going to display, in
    # in increasing order of id. joborder is the order specified on the job
    # list on the CGI query. These do no necessarily contain the same items
    if len(joborder) > 0:
        neworder = []
        # Remove any items from joborder not in jobs
        for j in joborder:
            if j in jobs:
                neworder.append(j)
        # Append any items in jobs but not in joborder
        for j in jobs:
            if not j in neworder:
                neworder.append(j)
        jobs = neworder

    # Prepare and tidy up the descriptions so that we have a jobiddesc
    # entry for every job and the number if items in the list matches
    # hdgdepth. Then work out the colspans for the higher level headings.
    # The order of the list is lowest level first
    prev = None
    colspans = []
    rng = range(hdgdepth)
    rng.reverse()
    for i in rng: 
        colspans.append([])
    for j in jobs:
        if not jobiddesc.has_key(j):
            jobiddesc[j] = [j]
        while len(jobiddesc[j]) < hdgdepth:
            jobiddesc[j].append('')

        anynew = 0
        for d in rng:
            if not prev or jobiddesc[j][d] != prev[d]:
                colspans[d].append([0, jobiddesc[j][d]])
                prev = None
            colspans[d][-1][0] = colspans[d][-1][0] + 1

        prev = jobiddesc[j]
    
    # Build the matrix
    m = Matrix()
    colspans.reverse()
    m.setColumns(colspans)
    m.setJobs(jobs)
    m.setJobData(jobdata)

    for phaset in phases:
        phase, tests, pdesc = phaset
        rg = m.addRowGroup(phase, pdesc)        
        for testt in tests:
            test, tdesc = testt
            row = rg.addRow(test, tdesc)

            for j in jobs:
                try:
                    result, detailid, upld, rs = data[phase][test][j]
                    cell = row.addCell(j)
                    cell.setResult(result)
                    cell.setDetailID(detailid)
                    if upld == "yes":
                        cell.setUploaded()
                    # Check performance vs. native
                    rsd = ""
                    rswarn = 0
                    if rs != None:
                        if rs < 0:
                            rsd = "%.2f%%" % (rs * 100)
                        else:
                            rsd = "+%.2f%%" % (rs * 100)
                        if rs < (0.0 - maxloss):
                            cell.setWarning()
                    cell.setRelative(rsd)
                except KeyError:
                    pass
        
    m.render(sys.stdout)

    print "</DIV></BODY></HTML>"

    cur.close()


elif action == "jobgroup":

    if not form.has_key("command"):
        print "Content-type: text/plain\n"
        print "ERROR No command supplied"
        sys.exit(0)   
    if not form.has_key("gid"):
        print "Content-type: text/plain\n"
        print "ERROR No gid supplied"
        sys.exit(0)   

    command = form['command'].value
    gid = form['gid'].value

    if form.has_key('desc'):
        desc = string.replace(form['desc'].value, "'", '"')        
    else:
        desc = ""

    if command == "reset":
        sql = "DELETE FROM tblJobGroups WHERE gid = '%s';" % (gid)
    elif command == "add":
        if not form.has_key("jobid"):
            print "Content-type: text/plain\n"
            print "ERROR No jobid supplied"
            sys.exit(0)
        jobid = form['jobid'].value
        sql = "INSERT INTO tblJobGroups (gid, jobid, description) VALUES " \
              "('%s', %s, '%s');" % (gid, jobid, desc)
    else:
        print "Content-type: text/plain\n"
        print "ERROR Unknown command '%s'" % (command)
        sys.exit(0)

    cur = db.cursor()

    try:
        cur.execute(sql)
    except:
        print "Content-type: text/plain\n"
        print "ERROR database insert error"
        sys.exit(0)

    db.commit()
    cur.close()

    print "Content-type: text/plain\n"
    print "OK "

elif action == "utilisation":
    if not form.has_key("period"):
        print "Content-type: text/plain\n"
        print "ERROR No period supplied"
        sys.exit(0)
    else:
        # Period can be specified in 2 ways, either a single integer which
        # is treated as a number of days to look at, or as a pair of comma
        # separated values, which are treated as timestamps
        period = string.strip(form['period'].value)
        if ',' in period:
            sp = period.split(',')
            start = int(sp[0])
            end = int(sp[1])
        else:
            start = (int(time.time()) - (86400 * int(period)))
            end = int(time.time())

    if form.has_key("verbose") and form['verbose'].value == "yes":
        verbose = True
    else:
        verbose = False

    cur = db.cursor()

    if form.has_key("pools"):
        pl = string.strip(form['pools'].value)
        pools = pl.split(',')
    else:
        pools = []
        cur.execute("SELECT DISTINCT pool FROM tblMachines")
        while 1:
            rc = cur.fetchone()
            if not rc:
                break
            pools.append(string.strip(rc[0]))
            
    period = end - start

    html = 0
    if form.has_key("html") and form["html"].value == "yes":
        html = 1
        print "Content-type: text/html\n"
    else:
        print "Content-type: text/plain\n"


    pool_data = {}

    allmax = 0
    alltime = 0
    alljobs = 0

    for pool in pools:
        results = []

        machineslist = scm_machine_list(pool=pool)
        machines = map(lambda x:x[0], machineslist)        
        machines.sort()
        pooltime = 0
        pooljobs = 0
        for machine in machines:
            data = {}
            data['machine'] = machine
            data['pool'] = pool

            # Get the statistics for this machine
            cur.execute(("SELECT extract(epoch FROM ts),etype,edata FROM tblevents " +
                         "WHERE subject='%s' AND (etype='JobStart' OR etype='" +
                         "JobEnd') AND ts > ('epoch'::timestamptz + interval " +
                         "'%u seconds') AND ts < ('epoch'::timestamptz + " +
                         "interval '%u seconds') ORDER BY ts;") % \
                         (machine,start,end))

            started = False
            st_time = 0
            data['timespent'] = 0
            data['jobs'] = 0
            jobsToTimeSpent = {}
            while 1:
                rc = cur.fetchone()
                if not rc:
                    break
                if string.strip(rc[1]) == "JobEnd":
                    if started:
                        # Find the jobid to get the number of machines involved
                        jobid = int(rc[2])
                        jobsToTimeSpent[jobid] = rc[0] - st_time
                        started = False
                else:
                    started = True
                    st_time = rc[0]
                    data['jobs'] += 1

            machineCounts = get_param_for_jobs("MACHINES_REQUIRED", jobsToTimeSpent.keys())
            for j in jobsToTimeSpent.keys():
                if machineCounts.has_key(j):
                    data['timespent'] += int(machineCounts[j]) * jobsToTimeSpent[j]
                else:
                    data['timespent'] += jobsToTimeSpent[j]

            data['percentage'] = (data['timespent'] / period) * 100

            # Format timespent nicely
            data['timespent_str'] = pretty_print_utilisation(data['timespent'])
            pooltime += data['timespent']
            pooljobs += data['jobs']
            results.append(data)

        # Work out overall pool utilisation
        poolutil = (pooltime / (len(results) * period)) * 100
        pooltime_str = pretty_print_utilisation(pooltime)
        pdata = {'poolutil' : poolutil,
                 'pooljobs' : pooljobs,
                 'results'  : results,
                 'pooltime' : pooltime_str}
        pool_data[pool] = pdata

        alltime += pooltime
        alljobs += pooljobs
        allmax += len(results) * period

    allutil = (alltime / allmax) * 100
    alltime_str = pretty_print_utilisation(alltime)
    cur.close()

    if html:
        print """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
        <head>
        <title>XenRT - Utilisation Info</title>
        <link href="style.css" rel="stylesheet" type="text/css">
        </head>

        <BODY>
        """
   
        for pool in pools:

            results = pool_data[pool]['results']
            util = pool_data[pool]['poolutil']
            jobs = pool_data[pool]['pooljobs']
            print "<h2>%s (%u jobs, %u%%)</h2>" % (pool,jobs,util)

            print ("<div><table id='util'><tr><th>Machine</th><th>Utilisation" +
                   "</th><th>Time Spent</th><th>Job Count</th></tr>")

            for data in results:
                print ("<tr><td>%s</td><td>%u%%</td><td>%s</td><td>%u</td>" +
                       "</tr>") % (data['machine'],data['percentage'], \
                                   data['timespent_str'],data['jobs'])
 
            print "</table></div>"

        print "</BODY></HTML>"

    else:
        print string.join(["ALL",
                           "Total",
                           "%u%%" % (allutil),
                           alltime_str,
                           "%u" % (alljobs)], ",")
        for pool in pools:
        
            results = pool_data[pool]['results']
            util = pool_data[pool]['poolutil']
            jobs = pool_data[pool]['pooljobs']
            pooltime = pool_data[pool]['pooltime']
            print string.join(["POOL",
                               pool,
                               "%u%%" % (util),
                               pooltime,
                               "%u" % (jobs)], ",")

            if verbose:
                for data in results:
                    print string.join(["MACHINE",
                                       data['machine'],
                                       "%u%%" % (data['percentage']),
                                       data['timespent_str'],
                                       "%u" % (data['jobs'])], ",")

elif action == "detailid":

    me = os.path.basename(sys.argv[0])

    if not form.has_key("id"):
        print "Content-type: text/plain\n"
        print "ERROR No job ID supplied"
        sys.exit(0)

    if not form.has_key("phase"):
        print "Content-type: text/plain\n"
        print "ERROR No phase supplied"
        sys.exit(0)

    if not form.has_key("test"):
        print "Content-type: text/plain\n"
        print "ERROR No test supplied"
        sys.exit(0)

    jobid = string.atoi(form["id"].value)
    phase = form["phase"].value
    test = form["test"].value

    # Find the detailid
    detailid = lookup_detailid(jobid, phase, test)
    if detailid == -1:
        print "Content-type: text/plain\n"
        print "ERROR No detailid found for %s/%s" % (phase,test)
        sys.exit(0)

    # Redirect
    print "Content-type: text/plain\n"
    print detailid
    sys.exit(0)

