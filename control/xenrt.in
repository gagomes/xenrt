#!/usr/bin/python
#
# XenRT Control Suite client. Interacts with HTTP server.
#
# (C) XenSource UK Ltd. 2005
# James Bulpin, November-December 2005

import sys, string, getopt, urllib, os, pwd, tempfile, xmlrpclib, shutil, json
import os.path, re, glob, random, time

PROFILER_ENABLED = ("XENRT_PROFILE" in os.environ)
XRTPROF = None
XRTPROF_FILENAME = os.path.join(("TMP" in os.environ and os.environ["TMP"] or \
	"/tmp"), "xenrt.prof")


server_url_base = '@webcontrdir@'
logserver_url_base = 'http://%s/share/control/'
s = os.getenv("WEB_CONTROL_PATH")
if s:
    server_url_base = s
if os.getenv("XENRT_DEBUG") == "yes":
    server_url = server_url_base + 'queue-devel.cgi'
    logserver_url = logserver_url_base + 'queue-devel.cgi'
    queuecgi = "queue-devel.cgi"
else:
    server_url = server_url_base + 'queue.cgi'
    logserver_url = logserver_url_base + 'queue.cgi'
    queuecgi = "queue.cgi"
_sharedir = "@sharedir@"
_confdir = "@confdir@"
_console = "@console@"
_conserver = "@conserver@"
_jenkins = "@jenkins@"

def urlopen_with_retry(*args, **kwargs):
    i = 0
    retryTimer = 2
    exception = None
    while i < 7:
        try:
            u = urllib.urlopen(*args, **kwargs)
            if "getcode" in dir(u):
                if u.getcode() >= 400:
                    raise Exception("Invalid HTTP resonse code")
            return u
        except Exception, e:
            time.sleep(retryTimer)
            exception = e
        i+= 1
        retryTimer *= 2
    raise e

class XenRTCommand:

    name = "<default>"
    summary = "<--- no summary --->"
    usage = ""
    mandatory = ""
    group = "Other"

    commands = None
    hide = False

    def __init__(self, commands):
        self.commands = commands
        self.proxies = None

    def getServerURL(self):
        return server_url
    
    def dispatch(self, args, raw=0):

        if len(args) > 0 and args[0] in ("--help", "-h"):
            print "%s\n" % (self. summary)
            if self.usage == "":
                opts = ""
            else:
                opts = " [options]"
            print "Usage: %s %s %s%s" % \
                  (sys.argv[0], self.name, self.mandatory, opts)
            print self.usage
            return 0
        results = self.run(args)
        if raw:
            return results
        else:
            if results:
                return self.render(args, results)
            else:
                return 1

    def run(self, args):
        return 1

    def render(self, args, results):
        return 0

    def printout(self, str):
        if self.commands and self.commands.outfd:
            fd = self.commands.outfd
        else:
            fd = sys.stdout
        fd.write(str)

    def getLogServer(self, job, proxies=None):
        details = {'action': 'status'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        details["id"] = job
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=proxies)

        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        server = None
        if reply.has_key("LOG_SERVER"):
            server = reply['LOG_SERVER']
        return server

    def uploadWithCurl(self, details, filename, proxies=None, url=None):
        cmd = ["curl"]
        cmd.append("-H \"Expect:\"")
        if proxies and proxies.has_key('http'):
            cmd.append("--proxy %s" % (proxies['http'][7:]))
        for d in details.keys():
            cmd.append("-F '%s=%s'" % (d, details[d]))
        cmd.append("-F file=@%s" % (filename))
        if not url:
            url = self.getServerURL()
        cmd.append(url)
        rc = os.system("%s > /dev/null 2>&1" % (string.join(cmd)))
        if rc == 0:
            return 1
        return None

    def upload(self, details, filename, proxies=None, url=None):
        if os.path.exists("/usr/bin/curl"):
            return self.uploadWithCurl(details, filename, proxies=proxies,url=url)
        if filename:
            f = file(filename, 'r')
        else:
            f = sys.stdin
        #data = f.read()
        details["file"] = f.read()
        if filename:
            f.close()
        if not url:
            url = self.getServerURL()
        u = urlopen_with_retry(url, urllib.urlencode(details), proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

    def parse_job(self, data):

        reply = {}
        for s in string.split(data, "\n"):
            #sys.stderr.write(":%s:" % (s))
            ll = string.split(s, "=", 1)
            if len(ll) == 2:
                key = ll[0]
                value = ll[1]
                if value[0] == "'":
                    value = value[1:-1]
                reply[key] = value
        return reply

    def parse_options(self, args):
        secondary = {}
        details = {}
        argmap = {
            '-v': 'VERSION',
            '-r': 'REVISION',
            '-o': 'OPTIONS',
            '-n': 'DEPS',
            '-R': 'REPO',
            '-t': 'TARGET',
            '-F': 'FLAGS'
            }
        argmapbool = {
            '-P': 'PUBLISH',
            '-d': 'DEBUGCMD',
            }
        try:
            optlist, optx = getopt.getopt(args, 'm:v:r:o:n:R:t:F:PU:dU:D:',
                                          ['rpm', 'optrpm', 'nfs', 'gnbd',
                                           'gnbdserver=', 'gnbdclient=',
                                           'domu', 'patch=', 'xenargs=',
                                           'distro=', 'sep', 'smpdom0',
                                           'nobuildopts', 'filevbd', 'swap',
                                           'filevbdnfs', 'carboncd=',
                                           'carbonpatch=', 'xenbuild=',
                                           'ring0', 'perftag=', 'email=',
                                           'tarball=', 'noxenargs',
                                           'nodom0args', 'dom0args=',
                                           'hold=', 'holdfail=', 'arch=',
                                           'sepkern=', 'sepkrev=',
                                           'failkeep', 'res=', 'pool=',
                                           'xgt=', 'xgtnfs=', 'qcow',
                                           'removepassed', 'rpmpath=',
                                           'guestrpms=', 'pw=', 'guestaddr=',
                                           'pq=', 'pqpatch=', 'skip=',
                                           'skipgroup=', 'skiptype=',
                                           'run=', 'rungroup=',
                                           'pause-on-fail=',
                                           'pause-on-pass=',
                                           'hvarch=', 'no-finally',
                                           'debug', 'verbose', 'number=',
                                           'priority=', 'customsequence=',
                                           'customupdates=',
                                           'perf-data=', 'perf-regress=',
                                           'testcasefiles=', 'res1=',
                                           'inputs=',
                                           'flags=','guard=',
                                           'xenrtpqname='])
            for argpair in optlist:
                (flag, value) = argpair
                if argmap.has_key(flag):
                    details[argmap[flag]] = value
                elif argmapbool.has_key(flag):
                    details[argmapbool[flag]] = "yes"
                elif flag == "-m":
                    details['MACHINE'] = value
                    details['MACHINES_SPECIFIED'] = "yes"
                elif flag == "--rpm":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                elif flag == "--rpmpath":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                    details['OPTION_RPM_PATH'] = value
                elif flag == "--guestrpms":
                    details['OPTION_GUEST_RPMS'] = value
                    details['OPTION_XEN_PACKAGE_G'] = "rpm"
                elif flag == "--optrpm":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                    details['RPMARG'] = "2"
                elif flag == "--nfs":
                    details['OPTION_GUEST_ROOT'] = "nfs"
                elif flag == "--filevbd":
                    details['OPTION_GUEST_ROOT'] = "file"
                elif flag == "--filevbdnfs":
                    details['OPTION_GUEST_ROOT'] = "file"
                    details['OPTION_GUEST_BACKING'] = "nfs"
                elif flag == "--qcow":
                    details['OPTION_GUEST_ROOT'] = "qcow"
                elif flag == "--gnbd":
                    details['OPTION_USE_GNBD'] = "yes"
                elif flag == "--gnbdserver":
                    details['OPTION_GNBD_SERVER'] = value
                elif flag == "--gnbdclient":
                    details['OPTION_GNBD_SERVE_FOR'] = value
                elif flag == "--domu":
                    details['OPTION_ONLY_DOMU'] = "yes"
                    details['OPTION_SEP_DOM0U'] = "yes"
                    details['OPTION_BUILD_COMPONENTS'] = "kernels"
                    details['XEN_BUILD_OPTIONS2'] = "KERNELS=linux-2.6-xen0"
                    details['EXTRA_BUILD_OPTIONS'] = "KERNELS=linux-2.6-xenU"
                elif flag == "--patch":
                    details['PATCH_XEN'] = os.path.basename(value)
                    secondary['patch'] = value
                elif flag == "--testcasefiles":
                    tl = [ os.path.basename(x) for x in 
                           string.split(value, ",") ]
                    details['TESTCASEFILES'] = string.join(tl, ",")
                    secondary['testcasefiles'] = value
                elif flag == "--customsequence":
                    details['CUSTOM_SEQUENCE'] = "yes"
                    details['DEPS'] = os.path.basename(string.split(value, ",")[0])
                    secondary['seqfiles'] = value
                elif flag == "--customupdates":
                    updates = []                
                    for u in string.split(value, ","):
                        if not os.path.exists(u):
                            sys.stderr.write("Update %s doesn't exist on this machine." % u)
                            return None, None
                        known_formats = ["rpm", "tar", "tar.gz", "tgz", "tar.bz", "tbz"]                    
                        if len(filter(lambda ext: u.endswith("." + ext), known_formats)) == 0:
                            sys.stderr.write("Update %s has an unknown format ."
                                             "Only the following formats are supported: %s"
                                             % (u, known_formats))
                            return None, None
                        updates.append(os.path.basename(u))
                    details['CUSTOM_UPDATES'] = string.join(updates, ",")
                    secondary['customupdates'] = value
                elif flag == "--perf-data":
                    details['PERFDATAFILE'] = "yes"
                    secondary['perfdata'] = value
                elif flag == "--perf-regress":
                    details['PERFREGRESSFILE'] = "yes"
                    secondary['perfregress'] = value
                elif flag == "--xenargs":
                    details['XEN_EXTRA_ARGS_USER'] = value
                elif flag == "--dom0args":
                    details['DOM0_EXTRA_ARGS_USER'] = value
                elif flag == "--noxenargs":
                    details['OPTION_NO_XEN_ARGS'] = "yes"
                elif flag == "--nodom0args":
                    details['OPTION_NO_DOM0_ARGS'] = "yes"
                elif flag == "-U":
                    details['USERID'] = value
                elif flag == "--distro":
                    try:
                        (pref, rest) = string.split(value, ":", 1)
                        guest = string.atoi(pref)
                        if rest[-1] == "+":
                            rest = rest[:-1]
                            details['OPTION_XEN_PACKAGE[%u]' % (guest)] = \
                                                             "existing"
                        details['ROOT_DISTRO_DOM[%u]' % (guest)] = rest
                        details['OPTION_GUEST_XGT[%u]' % (guest)] = rest
                    except:
                        details['ROOT_DISTRO'] = value
                        details['OPTION_GUEST_XGT'] = value
                elif flag == "--sep":
                    details['OPTION_SEP_DOM0U'] = "yes"
                elif flag == "--smpdom0":
                    details['OPTION_SMP_DOM0'] = "yes"
                elif flag == "--nobuildopts":
                    details['OPTION_CLEAR_BUILDOPTS'] = "yes"
                elif flag == "--debug":
                    details['OPTION_DEBUG'] = "yes"
                elif flag == "--verbose":
                    details['OPTION_VERBOSE'] = "yes"
                elif flag == "--swap":
                    details['OPTION_SWAP_DOMU'] = "yes"
                elif flag == "--carboncd":
                    details['CARBON_CD_IMAGE'] = value
                elif flag == "--carbonpatch":
                    details['CARBON_INSTALLER_PATCH'] = value
                elif flag == "--xenbuild":
                    details['USER_BUILD_OPTIONS'] = value
                elif flag == "--ring0":
                    details['USER_BUILD_OPTIONS'] = "supervisor_mode_kernel=y"
                    details['OPTION_DEFAULT_GLIBC'] = "yes"
                elif flag == "--perftag":
                    details['PERFTAG'] = value
                elif flag == "--email":
                    details['EMAIL'] = value
                elif flag == "--tarball":
                    try:
                        (pref, rest) = string.split(value, ":", 1)
                        guest = string.atoi(pref)
                        details['OPTION_XEN_PACKAGE[%u]' % (guest)] = "tarball"
                        details['INSTALLATION_TARBALL[%u]' % (guest)] = rest
                    except:
                        details['INSTALLATION_TARBALL[0]'] = value
                        details['OPTION_XEN_PACKAGE'] = "tarball"
                elif flag == "--hold":
                    details['MACHINE_HOLD_FOR'] = value
                elif flag == "--holdfail":
                    details['MACHINE_HOLD_FOR_FAIL'] = value
                elif flag == "--arch":
                    (pref, rest) = string.split(value, ":", 1)
                    guest = string.atoi(pref)
                    details['GUEST_ARCH[%u]' % (guest)] = rest
                elif flag == "--sepkern":
                    details['SEPARATE_KERNEL_TREE'] = value
                elif flag == "--sepkrev":
                    details['OPTION_SEP_KREV'] = value
                elif flag == "--failkeep":
                    details['CLEANUP'] = "onsuccess"
                elif flag == "--res":
                    details['RESOURCES_REQUIRED'] = value
                elif flag == "--res1":
                    details['RESOURCES_REQUIRED_1'] = value
                elif flag == "--pool":
                    details['POOL'] = value
                elif flag == "--xgt":
                    if details.has_key("EXTRA_XGTS"):
                        details['EXTRA_XGTS'] = details['EXTRA_XGTS'] + " " \
                                                + value
                    else:
                        details['EXTRA_XGTS'] = value
                elif flag == "--xgtnfs":
                    details['OPTION_XGT_NFS'] = value
                elif flag == "--pw":
                    details['ROOT_PASSWORDS'] = value
                elif flag == "--guestaddr":
                    details['GUEST_HOSTNAME[1]'] = value
                elif flag == "-D":
                    try:
                        var, varval = string.split(value, "=", 1)
                        if len(var) > 24:
                            sys.stderr.write(\
                                "-D parameter too long (24 chars max): %s" % (var))
                            return None, None
                        if len(varval) > 255:
                            sys.stderr.write(\
                                "-D value too long (255 chars max): %s=%s" %
                                (var, varval))
                            return None, None
                        details[var] = varval
                    except:
                        sys.stderr.write("Error parsing -D variable '%s'\n" %
                                         (value))
                        return None, None
                elif flag == "--removepassed":
                    details['OPTION_REMOVE_PASSED'] = "yes"
                elif flag == "--pq":
                    details['OPTION_PATCHQUEUE'] = value
                elif flag == "--pqpatch":
                    details['OPTION_PQ_PATCH'] = value
                elif flag == "--skip":
                    details['SKIP_%s' % (value)] = "yes"
                elif flag == "--skipgroup":
                    details['SKIPG_%s' % (value)] = "yes"
                elif flag == "--skiptype":
                    details['SKIPT_%s' % (value)] = "yes"
                elif flag == "--run":
                    details['RUN_%s' % (value)] = "yes"
                elif flag == "--rungroup":
                    details['RUNG_%s' % (value)] = "yes"
                elif flag == "--priority":
                    details['PRIORITY'] = value
                elif flag == "--pause-on-fail":
                    details['POF_%s' % (value)] = "yes"
                elif flag == "--pause-on-pass":
                    details['POP_%s' % (value)] = "yes"
                elif flag == "--hvarch":
                    details['HVARCH'] = value
                elif flag == "--no-finally":
                    details['NOFINALLY'] = "yes"
                elif flag == "--number":
                    details['MACHINES_REQUIRED'] = value
                elif flag == "--inputs":
                    details['INPUTDIR'] = value
                elif flag == "--flags":
                    details['FLAGS'] = value
                elif flag == "--guard":
                    details['GUARD'] = value
                elif flag == "--xenrtpqname":
                    details['XENRT_PQ_NAME'] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None, None
        except getopt.GetoptError, e:
            sys.stderr.write("Unknown argument: %s\n" % (str(e)))
            return None, None

        if details.has_key('USER_BUILD_OPTIONS') and \
               details['USER_BUILD_OPTIONS'] == "supervisor_mode_kernel=y":
            if not details.has_key('TARGET'):
                details['TARGET'] = "dom0"
            if not details.has_key('OPTION_CLEAR_BUILDOPTS'):
                details['OPTION_CLEAR_BUILDOPTS'] = "yes"

        # For vendor kernel testing set a default repo
        if details.has_key('OPTION_ONLY_DOMU') and \
               details['OPTION_ONLY_DOMU'] == "yes":
            if not details.has_key('SECONDARY_REPO_VERSION'):
                details['SECONDARY_REPO_VERSION'] = "xen-3.0-testing"

        # And not let OPTION_ONLY_DOMU through otherwise run-all will override
        if details.has_key('OPTION_ONLY_DOMU'):
            del details['OPTION_ONLY_DOMU']

        return details, secondary

    job_usage = """
        [ --inputs <directory> ]    directory containing product
        [ -o <architecture> ]       x86-32 (default), x86-32p or x86-64
        [ -v <version> ]            xen-unstable (default), linux, etc.
        [ -r <revision> ]           as datestamp of changeset hash (default is tip)
        [ -m <machine> ]            optional specification of required machine
        [ -R <repository URL> ]     path, ssh or http. (default is local cache)
        [ -n <sequence> ]           test sequence (default is full run)
        [ -t <target> ]             sequence target (default 'all')
        [ -F <flags> ]              miscellaneous for machine selection, e.g. 4GB
        [ -P ]                      enable publishing of results
        [ -d ]                      debug command (show config info, no run)
        [ --res <string> ]          resource requirements
        [ --pool <poolname> ]       the machine pool to use
        [ --number <n> ]            number of machines to acquire (default 1)
        [ --arch <guest>:<arch> ]   x86-32, x86-32p or x86-64
        [ --hvarch <arch> ]         Hypervisor arch (v2 jobs only)
        [ --rpm ]                   test community RPMs
        [ --optrpm ]                test Optimizer RPMs
        [ --rpmpath <path> ]        path to RPMs for dom0/general use
        [ --guestrpms <path> ]      path to RPMs to use for guests
        [ --tarball <URL> ]         use a dist tarball from the specified URL
        [ --tarball <guest>:<URL> ] use a dist tarball from the specified URL
        [ --distro <distro> ]       the Linux distribution to use
        [ --distro <guest>:<distro>[+] ] the Linux distribution to use
        [ --nfs ]                   use NFS root for guests (where supported)
        [ --filevbd ]               use file-backed VBD for guests (local storage)
        [ --filevbdnfs ]            use file-backed VBD for guests (NFS storage)
        [ --qcow ]                  use blktap QCOW storage (if supported)
        [ --gnbd ]                  use GNBD for guest roots
        [ --gnbdclient <machine> ]  be a GNBD server for <machine>
        [ --gnbdserver <machine> ]  use <machine> as GNBD server instead of local
        [ --swap ]                  give swap partitions to guests
        [ --domu ]                  only build guest kernel from this repository,
                                    hypervisor, dom0 kernel and tools come from
                                    xen-3.0-testing
        [ --sep ]                   build -xenU/0 (rather than -xen) kernels
        [ --smpdom0 ]               build and/or boot dom0 on multiple CPUs
        [ --noxenargs ]             clear any default Xen command line arguments
        [ --nodom0args ]            clear any default dom0 command line arguments
        [ --xenargs "<args>" ]      additional arguments for the Xen command line
        [ --dom0args "<args>" ]     additional arguments for the dom0 command line
        [ --debug ]                 perform a debug build (if applicable)
        [ --verbose ]               perform a verbose build (if applicable)
        [ --xenbuild "<opts>" ]     extra build options for the Xen "make world"
        [ --ring0 ]                 build dom0 to run in ring0 (no domUs allowed)
        [ --carboncd "<iso>" ]      path to Carbon installer ISO image
        [ --perftag "<string>" ]    add a performance tag for graph grouping
        [ --email <address> ]       email a summary of results to this address
        [ --hold <minutes> ]        hold a machine after job completes
        [ --holdfail <minutes> ]    hold a machine after job fails
        [ --sepkern <URL> ]         use the kernel from this kernel-only repo
        [ --sepkrev <revision> ]    the revision for the above (default is tip)
        [ --xgtnfs <NFS URL> ]      NFS path for XGT imports
        [ --xgt <xgt file/url> ]    Add an extra XGT to a Carbon installation
        [ -D <variable>=<value> ]   set a general variable
        [ --removepassed ]          remove the job from the joblist if it passes
        [ --pw <password> ]         root password for existing guests
        [ --guestaddr <ipaddr> ]    guest IP address for existing guests
        [ --skip <test> ]           skip test <test> (all phases)
        [ --skipgroup <group> ]     skip group <group>
        [ --skiptype <type> ]       skip test type <type>
        [ --run <test> ]            do not skip test <test> (all phases)
        [ --rungroup <group> ]      do not skip group <group>
        [ --priority <n> ]          run tests up to and including P<n>
        [ --pause-on-fail <test> ]  ask for user intervention for <test> or "ALL"
        [ --pause-on-pass <test> ]  ask for user intervention for <test> or "ALL"
        [ --no-finally ]            no run run any "finally" actions
        [ --customsequence <file> ] use a customised sequence file       
        [ --perf-data <file> ]      upload performance limits data
        [ --perf-regress <file> ]   upload performance regression data
        [ --testcasefiles <files> ] upload extra testcases
        [ --customupdates <files> ] upload customized host installation updates (rpm/tarball)
        [ --guard <guard> ]         patchqueue guard to apply
        [ --xenrtpqname <pqname> ]  patchqueue repository, default "xenrt.pq.hg" (use with --guard)
        """
        
class XenRTStatus(XenRTCommand):

    name = "status"
    summary = "Get the status of a submitted job. Any follow-up arguments" \
            " are considered variable names that we wish status to return.\n" \
            "(Analogous to piping xenrt status through grep.)"
    mandatory = "<jobid> [VarName1] [VarName#] [...]"
    group = "Job"

    def run(self, args):
        details = {'action': 'status'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()

        if not len(args[1:]):
            return reply

        for key in reply.keys():
            if not key in args[1:]:
                del reply[key]
        
        return reply

    def render(self, args, results):
        # Print CHECK first (XRT-303)
        if results.has_key("CHECK"):
            self.printout("%s='%s'\n" % ("CHECK", results["CHECK"]))
        for key in results.keys():
            if key != "CHECK":
                self.printout("%s='%s'\n" % (key, results[key]))
        return 0

class XenRTUtilisation(XenRTCommand):

    name = "utilisation"
    summary = "Get the utilisation of a pool for a specified period"
    usage = """
    -d <days>|<from>,<to>   Summary period as either a number of days or a
                            comma separated pair of UNIX timestamps
                            specifying start and end times. Default is 7 days.
    -p <pool>[,<pool>...]   List of pools to summarise. Default is all.
    -v                      Verbose - show per-machine details as well.
    """

    def run(self, args):
        details = {'action': 'utilisation'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        period = "7"
        self.verbose = False
        try:
            optlist, optx = getopt.getopt(args, 'd:p:v')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-v":
                    details["verbose"] = "yes"
                    self.verbose = True
                elif flag == "-d":
                    period = value
                elif flag == "-p":
                    details['pools'] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        details["period"] = period
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            ll = string.split(string.strip(line), ",")
            reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):        
        for ll in results:
            if ll[0] == "ALL":
                self.printout("Total (%s jobs, %s, %s)\n\n" %
                              (ll[4], ll[3], ll[2]))
                if not self.verbose:
                    self.printout("%-12s %12s %-18s %9s\n" % \
                                  ("Pool", "Utilisation", "Time Spent", "Job Count"))
                    self.printout("------------------------------------------" +
                                  "------------\n")
            elif ll[0] == "POOL" and self.verbose:
                self.printout("\n%s (%s jobs, %s, %s)\n" %
                              (ll[1], ll[4], ll[3], ll[2]))
                self.printout("%-12s %12s %-18s %9s\n" % \
                              ("Machine", "Utilisation", "Time Spent", "Job Count"))
                self.printout("------------------------------------------" +
                              "------------\n")
            elif ll[0] == "MACHINE" or (ll[0] == "POOL" and not self.verbose):
                self.printout("%-12s %12s %-18s %9s\n" % \
                              (ll[1], ll[2], ll[3], ll[4]))
                
class XenRTMachine(XenRTCommand):

    name = "machine"
    summary = "Get data for the specified machine"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'machine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        return reply

    def render(self, args, results):
        for key in results.keys():
            self.printout("%s='%s'\n" % (key, results[key]))
        return 0

class XenRTShowLog(XenRTCommand):

    name = "showlog"
    summary = "Show the test progress log"
    mandatory = "<jobid>"
    usage = """
    [ -v ]      verbose    
    [ -w ]      wide format
    [ -t ]      show testcase durations
    """
    group = "Job"

    def run(self, args):
        details = {'action': 'showlog'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        try:
            optlist, optx = getopt.getopt(args[1:], 'vwt')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-v":
                    details["verbose"] = "yes"
                elif flag == "-w":
                    details["wide"] = "yes"
                elif flag == "-t":
                    details["times"] = "yes"
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        self.printout(results)
        return 0

class XenRTMList2(XenRTCommand):

    name = "mlist2"
    summary = "Get a list of machines"
    usage = """
    [-s] <site>      Filter on site
    [-c] <cluster>   Filter on cluster
    [-o] <pool>      Filter on pool
    [-R] <resources> Filter on a resource string (e.g. "memory>3G/disks=1")
    [-P] <props>     Filter on machines matching the props string
    [-f] <flags>     Filter on machine flags
    [-b] <user>      Filter on machines borrowed by user
    [-n]             Filter on machines that are not borrowed
    [-m]             Filter on machines borrowed by me
    [-a]             Filter on machines borrowed by anyone
    [-r]             Show machine resources
    [-d]             Show machine descriptions
    [-p]             Show machine properties
    [-v]             Show pseudohosts
    """

    def run(self, args):
        self.controller = False
        details = {'action': 'mlist2'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        try:
            optlist, optx = getopt.getopt(args, 's:c:o:qCrdR:pP:vf:mb:na', "broken")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-s":
                    details["site"] = value
                elif flag == "-c":
                    details["cluster"] = value
                elif flag == "-o":
                    details["pool"] = value
                elif flag == "-q":
                    details["quiet"] = "yes"
                elif flag == "-r":
                    details["res"] = "yes"
                elif flag == "-d":
                    details["desc"] = "yes"
                elif flag == "-C":
                    details["controller"] = "yes"
                    self.controller = True
                elif flag == "-R":
                    details["rfilter"] = value
                elif flag == "-p":
                    details["props"] = "yes"
                elif flag == "-P":
                    details["pfilter"] = value
                elif flag == "-f":
                    details["ffilter"] = value
                elif flag == "-b":
                    details["leasefilter"] = value
                elif flag == "-m":
                    details["leasefilter"] = details["USERID"]
                elif flag == "-n":
                    details["notleased"] = "yes"
                elif flag == "-a":
                    details["leased"] = "yes"
                elif flag == "-v":
                    details["verbose"] = "yes"
                elif flag == "--broken":
                    details['broken'] = "yes"
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            if self.controller:
                reply = []
                lines = string.split(data, "\n")
                for l in lines:
                    if l != "":
                        reply.append(string.split(l,","))
            else:
                reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            if self.controller:
                for line in results:
                    self.printout("%s\n" % (string.join(line, ",")))
            else:
                self.printout(results)
        return 0

class XenRTMList(XenRTMList2):
    # Alias for xenrt mlist2
    name = "mlist"

class XenRTList(XenRTCommand):

    name = "list"
    summary = "Show status of new or running jobs"
    usage = """

    The optional parameters specify search filters.

    [ -m ]                   show only my jobs
    [ -U <user> ]            show only <user>'s jobs
    [ -n ]                   show only new jobs
    [ -r ]                   show only running jobs
    [ -s ]                   show testrun suite IDs if known
    [ -S <suiterun id> ]     show only jobs from this suite run
    [ -D <description> ]     show only jobs matching the given JOBDESC
    """
    group = "Scheduler"

    def run(self, args):
        self.showsr = False
        details = {'action': 'list',
                   'fields': 'MACHINE,VERSION,REVISION,DEPS,JOBDESC,USERID,TESTRUN_SR'}
        self.quiet = False
        try:
            optlist, optx = getopt.getopt(args, 'mU:nrsS:qD:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-U":
                    details["filter_USERID"] = value
                elif flag == "-S":
                    details["filter_TESTRUN_SR"] = value
                elif flag == "-m":
                    details["filter_USERID"] = pwd.getpwuid(os.getuid())[0]
                elif flag == "-n":
                    details["filter_JOBSTATUS"] = "new"
                elif flag == "-r":
                    details["filter_JOBSTATUS"] = "running"
                elif flag == "-s":
                    self.showsr = True
                elif flag == "-q":
                    self.quiet = True
                elif flag == "-D":
                    details["filter_JOBDESC"] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            else:
                if line[-1] == "\n":
                    ll = string.split(line[:-1], "\t")
                else:
                    ll = string.split(line, "\t")
                while len(ll) < 7:
                    ll.append("")
                reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):
        fieldwidths = [6, 8, 12, 9, 13, 18, 7]
        fmt = string.join(map(lambda x:"%%-%us" % x, fieldwidths))
        fmt = fmt + "\n"
        if not self.quiet:
            self.printout(fmt % ("ID",
                                 "Status",
                                 "Host(s)",
                                 "Version",
                                 "Revision",
                                 "Desc",
                                 "User"))
            self.printout("--------------------------------------------------"
                          "-----------------------------\n")
        for ll in results:
            if ll[6] != "":
                ll[5] = ll[6]
            ll[6] = ll[7]
            if ll[8] and self.showsr:
                ll[5] = ll[5].split("&")[0]
                ll[5] = "SR%s " % (ll[8]) + ll[5]
            for i in range(len(fieldwidths)):
                if len(ll[i]) > fieldwidths[i]:
                    ll[i] = ll[i][0:fieldwidths[i]]
            self.printout(fmt %
                          (ll[0], ll[1], ll[2], ll[3], ll[4], ll[5], ll[6]))
                          
        
class XenRTComplete(XenRTCommand):

    name = "complete"
    summary = "Mark a job as complete (server call only)"
    mandatory = "<jobid>"
    group = "Job"

    def run(self, args):
        details = {'action': 'complete'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTEmail(XenRTCommand):

    name = "email"
    summary = "Send job summary email (if necessary) (server call only)"
    mandatory = "<jobid>"
    hide = True

    def run(self, args):
        details = {'action': 'email'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSetResult(XenRTCommand):

    name = "setresult"
    summary = "Set test result (server call only)"
    mandatory = "<jobid> <phase> <test> <result>"
    hide = True

    def run(self, args):
        details = {'action': 'setresult'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 4:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        details["result"] = args[3]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTEvent(XenRTCommand):

    name = "event"
    summary = "Record an event"
    mandatory = "<type> <subject> '<data>'"
    hide = True
    
    def run(self, args):
        details = {'action': 'event'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        details["etype"] = args[0]
        details["subject"] = args[1]
        details["edata"] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply
    
class XenRTJobGroup(XenRTCommand):

    name = "jobgroup"
    summary = "Reset job group or add a job to a group"
    mandatory = "<group> {-R | -a <jobid>}"
    usage = """
    [ -d '<description>' ]   short description of this job
    """
    group = "Job group"

    def run(self, args):
        details = {'action': 'jobgroup'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details['gid'] = args[0]
        command = None
        if len(args) > 1:
            optlist, optx = getopt.getopt(args[1:], 'Ra:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-R":
                    command = "reset"
                elif flag == "-a":
                    command = "add"
                    details['jobid'] = value
                elif flag == "-d":
                    details['desc'] = value
        if not command:
            sys.stderr.write("Invalid usage\n")
            return None
        details['command'] = command
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTLogData(XenRTCommand):

    name = "logdata"
    summary = "Set test data fields (server call only)"
    mandatory = "<jobid> <phase> <test> <key> <value>"
    hide = True
    
    def run(self, args):
        details = {'action': 'logdata'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 5:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        details["key"] = args[3]
        details["value"] = args[4]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTRemove(XenRTCommand):

    name = "remove"
    summary = "Remove a job from the system"
    mandatory = "<jobid>"
    group = "Job"

    def run(self, args):
        details = {'action': 'remove'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSubmit(XenRTCommand):

    name = "submit"
    summary = "Submit a XenRT run to the work queue"
    usage = XenRTCommand.job_usage
    group = "Job"
    
    def run(self, args, preconf=None):
        defaults = {
            'OPTIONS': 'x86-32',
            'XENRT_PQ_NAME': 'xenrt.pq.hg'
            }
            
        details, secondary = self.parse_options(args)
        if preconf:
            preconf.update(details)
            details = preconf
        defaults.update(details)
        details = defaults
        if not details:
            return None
        for key in details.keys():
            if len(details[key]) == 0:
                del details[key]
        if not details.has_key("USERID"):
            details["USERID"] = pwd.getpwuid(os.getuid())[0]

        if details.has_key("INPUTDIR") and "latest" in details["INPUTDIR"]:
            
            # if you use a build like this: /usr/groups/xen/carbon/trunk/latest/
            # then it will get cached on the controller using this name as the key.
            # The cached build will then not get updated when the symlink target 
            # build changes.
            
            sys.stderr.write("You must specify a build with a build number in it.\n")
            return None

        if details.has_key("DEBUGCMD"):
            del details['DEBUGCMD']
            com.commands['status'].render(None, details)
            return 0
                    
        details['action'] = 'submit'

        u = urlopen_with_retry(self.getServerURL(), urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        while 1:
            line = u.readline()
            if not line:
                break
            ll = string.split(line, ' ', 2)
            if len(ll) > 0:
                if ll[0] == 'OK':
                    if len(ll) < 2:
                        sys.stderr.write("Server returned success but " +
                                         "without a job ID\n")
                    else:
                        reply = string.atoi(ll[1])
                        # Do we have a patch to upload?
                        if secondary.has_key("patch"):
                            patch = secondary["patch"]
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'patch' }
                            if not self.upload(detp, patch, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of patch %s "
                                                 "failed.\n" % (reply, patch))
                                reply = None
                        if secondary.has_key("seqfiles"):
                            for sf in string.split(secondary['seqfiles'], ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(sf) }
                                if not self.upload(detp, sf, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of sequence file %s "
                                                     "failed.\n" % (reply, sf))
                                    reply = None
                        if secondary.has_key("testcasefiles"):
                            for tf in string.split(secondary['testcasefiles'],
                                                   ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(tf) }
                                if not self.upload(detp, tf, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of test case file "
                                                     "%s failed.\n" % (reply, 
                                                                       tf))
                                    reply = None
                        if secondary.has_key("customupdates"):
                            for cu in string.split(secondary['customupdates'],
                                                   ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(cu) }
                                if not self.upload(detp, cu, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of customized update "
                                                     "%s failed.\n" % (reply, 
                                                                       cu))
                                    reply = None
                        if secondary.has_key("perfdata"):
                            sf = secondary['perfdata']
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'perfdata' }
                            if not self.upload(detp, sf, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of perf data file %s "
                                                 "failed.\n" % (reply, sf))
                                reply = None
                        if secondary.has_key("perfregress"):
                            sf = secondary['perfregress']
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'perfregress' }
                            if not self.upload(detp, sf, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of perf regress file "
                                                 "%s failed.\n" % (reply, sf))
                                reply = None

                elif ll[0] == 'ERROR':
                    if len(ll) < 2:
                        sys.stderr.write("Server returned error but " +
                                         "without an explanation\n")
                    else:
                        sys.stderr.write("ERROR: %s\n" % (ll[1]))
                        reply = None
                        
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%d\n" % (results))
        return 0

class XenRTRun(XenRTCommand):

    name = "run"
    summary = "Run a XenRT test sequence directly"
    usage = XenRTCommand.job_usage
    group = "Miscellaneous"
    
    def run(self, args):
        global _sharedir
        details, secondary = self.parse_options(args)
        if not details:
            return None
        for key in details:
            if len(details[key]) == 0:
                del details[key]
        if not details.has_key("USERID"):
            details["USERID"] = pwd.getpwuid(os.getuid())[0]

        resdir = tempfile.mkdtemp(prefix="xenrtrun.", dir=".")
        print "Output directory: %s" % (resdir)

        optparse = []
        optparse.append(("OPTIONS", "--arch", True))
        optparse.append(("REPO", "--repo", True))
        optparse.append(("REVISION", "--revision", True))
        optparse.append(("OPTION_PATCHQUEUE", "--pq", True))
        optparse.append(("OPTION_PQ_PATCH", "--pqpatch", True))
        optparse.append(("OPTION_PATCHQUEUE_REV", "--pqrev", True))
        optparse.append(("HVARCH", "--hvarch", True))
        optparse.append(("HARNESS_TRACE", "--trace", False))
        optparse.append(("NOFINALLY", "--no-finally", False))
        optparsevars = []
        for opt in optparse:
            var, flag, hasarg = opt
            optparsevars.append(var)

        cmd = ["%s/exec/main.py" % (_sharedir)]
        cmd.append("-V")
        cmd.append("-C")
        cmd.append(resdir)
        cmd.append("--redir")
        cmd.append("--output-to-logdir")
        cmd.append("--matrix")
        cmd.append("matrix.csv")
        if not string.strip(os.popen("nisdomainname").read()) == "hq.xensource.com":
            cmd.append("--remote")
        if details.has_key("CLI_ARGS_PASSTHROUGH"):
            for i in string.split(details["CLI_ARGS_PASSTHROUGH"]):
                cmd.append(i)
        if details.has_key("MACHINE"):
            hosts = string.split(details["MACHINE"], ",")
            cmd.append("--host")
            cmd.append("%s" % (string.join(hosts, ",")))
        if details.has_key("DEPS"):
            cmd.append("--sequence")
            cmd.append("%s" % (details["DEPS"]))
        if details.has_key("TESTCASEFILES"):
            cmd.append("--testcasefiles")
            cmd.append("%s" % (details["TESTCASEFILES"]))
        for optpair in optparse:
            var, flag, hasarg = optpair
            if details.has_key(var):
                cmd.append(flag)
                if hasarg:
                    cmd.append(details[var])
        for k in details.keys():
            if not k in ("DEPS", "DEBUGCMD", "SCHEDULEDON", "SCHEDULEDON2", "SCHEDULEDON3", "TESTCASEFILES", "CLI_ARGS_PASSTHROUGH") and not k in optparsevars:
                cmd.append("-D")
                cmd.append("%s=%s" % (k, details[k]))

        if details.has_key('DEBUGCMD'):
            print "To Run: %s" % (string.join(cmd))
        else:
            print "Running: %s" % (string.join(cmd))        
            pid = os.spawnv(os.P_NOWAIT, cmd[0], cmd)

class XenRTRerun(XenRTSubmit):

    name = "rerun"
    summary = "Rerun a previously existed job"
    mandatory = "<jobid> [faithful|testrun|custom]"
    usage = """
Among the three rerun modes, 'custom' mode is the default choice if none is
present. After the mandatory arguments above, any 'xenrt submit' option can
be used to shadow the original setttings in any mode. Note that it might not
make sense to overwrite settings in the 'faithful' and 'testrun' mode, but we
preserve such possibilities.
    """

    faithful_ex = [ "XMLRPC", "HARNESS_PID", "JOBID", "RUNDIR", "XENRT_VERSION",
                    "JOB_SUBMITTED", "STARTED", "JOBSTATUS", "SCHEDULEDON.*",
                    "CHECK", "RETURN", "UPLOADED", "FINISHED", "PASSRATES",
                    "REGRESSION", "REMOVED", "PREPARE_FAILED" ]
    testrun_ex = [ "MACHINE", "PXE_BIOS_BOOT_RETRY" ]
    custom_ex = [ "JOBGROUP", "TESTRUN.*", "JIRA.*", "USERID",
                  "EMAIL.*", ".*EMAIL_TO", "AUTO_BUG.*" ]

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        jobid = args[0]
        options = com.commands['status'].dispatch([jobid], raw=1)
        if options is None: return None
        if len(args) < 2:
            mode = 'custom'
            noptions = []
        elif args[1].startswith('-'):
            mode = 'custom'
            noptions = args[1:]
        elif args[1] in ['faithful', 'testrun', 'custom']:
            mode = args[1]
            noptions = args[2:]
        else:
            sys.stderr.write("Invalid rerun mode\n")
            return None
        # Exclude patterns
        excludes = []
        # Include options dict
        includes = {}
        if mode == 'faithful':
            excludes += self.faithful_ex
        if mode == 'testrun':
            excludes += self.faithful_ex + self.testrun_ex
            runlogs = com.commands['showlog'].dispatch([jobid], raw=1)
            runlogs = runlogs.strip().splitlines()
            runlogs = filter(lambda l: len(l) >= 2, map(lambda l: l.split(), runlogs))
            runlogs = dict(map(lambda l: (l[1], len(l)>=3 and l[2] or ''), runlogs))
            for tc in runlogs:
                if not runlogs[tc] or re.match("error|fail|block", runlogs[tc]):
                    includes['RUN_%s' % tc] = 'yes'
        if mode == 'custom':
            excludes += self.faithful_ex + self.testrun_ex + self.custom_ex
        excludes = map(lambda s: '^' + s + '$', excludes)
        options=dict(filter(lambda (k,v): not (re.match("|".join(excludes), k)), options.iteritems()))
        options.update(includes)
        options['ORIGINAL_JOBID'] = jobid
        result = XenRTSubmit.run(self, noptions, preconf=options)
        return result

class XenRTUpdate(XenRTCommand):

    name = "update"
    summary = "set/update a field in a job description"
    mandatory = "<jobid> <field> <value>"
    group = "Job"
    
    def run(self, args):
        details = {'action': 'update'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMBroken(XenRTCommand):
    name = "mbroken"
    summary = "Mark a machine as broken"
    mandatory = "<machine> <reason>"
    group = "Machine"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        reason = " ".join(args[1:])

        details = {'action': 'machine', 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            data = self.parse_job(data)
        u.close()
        pool = data['POOL']
        pool = pool.rstrip("x")
        pool = "%sx" % pool

        details = {'action': 'mupdate', 'POOL': pool, 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()
        
        m = re.search("([A-Z]+-\d+)", reason)
        if m:
            details = {'action': 'mupdate', 'BROKEN_TICKET': m.group(1), 'machine':machine}
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
                return None
            u.close()

        details = {'action': 'mupdate', 'BROKEN_INFO': reason, 'machine': machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMFixed(XenRTCommand):
    name = "mfixed"
    summary = "Mark a machine as fixed"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]

        details = {'action': 'machine', 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            data = self.parse_job(data)
        u.close()
        pool = data['POOL']
        pool = pool.rstrip("x")

        details = {'action': 'mupdate', 'POOL': pool, 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()
        
        details = {'action': 'mupdate', 'BROKEN_TICKET': "", 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()

        details = {'action': 'mupdate', 'BROKEN_INFO': "", 'machine': machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMUpdate(XenRTCommand):

    name = "mupdate"
    summary = "set/update a field of machine data"
    mandatory = "<machine> <field> <value>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mupdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMRes(XenRTMUpdate):
    name = "mres"
    summary = "set/update a resource on a machine"
    mandatory = "<machine> <resource>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'machine'}
        if len(args) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        if len(args[1].split("=", 1)) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            reply = self.parse_job(data)
        u.close()
        try:
            res = reply["RESOURCES"]
        except:
            res = ""
        resitems = res.split("/")
        found = False
        for i in range(len(resitems)):
            if resitems[i].split("=")[0] == args[1].split("=")[0]:
                resitems[i] = args[1]
                found = True
        if not found:
            resitems.append(args[1])
        XenRTMUpdate.run(self, [args[0], "RESOURCES", "/".join(resitems)])

class XenRTMStatus(XenRTCommand):

    name = "mstatus"
    summary = "update the status field of machine data"
    mandatory = "<machine> <status>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mstatus'}
        if len(args) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        details["status"] = args[1]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTBorrow(XenRTCommand):

    name = "borrow"
    summary = "Borrow a machine"
    mandatory = "<machine>"
    usage = """
    -h <hours>     Number of hours to borrow for (default is 24)
    -d <days>      Number of days to borrow for (default is 1)
    -r <reason>    Reason for borrowing machine
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'borrow'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], 'h:u:d:fr:', "force")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-h':
                    details["hours"] = value
                elif flag == '-d':
                    details["hours"] = "%d" % (int(value) * 24)
                elif flag == "-r":
                    details["reason"] = value
                elif flag == '-u':
                    details['USERID'] = value
                elif flag == "-f":
                    details["forever"] = "yes"
                elif flag == "--force":
                    details["force"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTReturn(XenRTCommand):

    name = "return"
    summary = "Return a borrowed machine"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'return'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], '', "force")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "--force":
                    details["force"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTProp(XenRTCommand):

    name = "prop"
    summary = "Add/remove dynamic machine properties"
    mandatory = "<machine> add|del <property>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mupdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        if args[1] == "add":
            details["+PROPS"] = args[2]
        elif args[1] == "del" or args[1] == "rem":
            details["-PROPS"] = args[2]
        else:
            sys.stderr.write("Invalid usage: need \"add\" or \"del\".\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSFlag(XenRTCommand):

    name = "sflag"
    summary = "Add/remove site flags"
    mandatory = "<site> add|del <property>"
    group = "Site"

    def run(self, args):
        details = {'action': 'supdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        if args[1] == "add":
            details["+FLAGS"] = args[2]
        elif args[1] == "del" or args[1] == "rem":
            details["-FLAGS"] = args[2]
        else:
            sys.stderr.write("Invalid usage: need \"add\" or \"del\".\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTPool(XenRTCommand):

    name = "pool"
    summary = "Set machine pool"
    mandatory = "<machine> [<poolname>]"
    usage = """
The first usage is for setting the pool a machine is in. A blank <poolname>
moves the machine to the "DEFAULT" pool.
    """
    group = "Machine"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")            
            return None

        # Machine update
        details = {'action': 'mupdate',
                   'SUBPOOL': 'DEFAULT'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        machine = args[0]
        details["machine"] = machine
        if len(args) > 1:
            details["SUBPOOL"] = args[1]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

    def render(self, args, results):
        if len(args) > 0 and args[0] == "--list":
            for r in results:
                self.printout("%s\n" % (r[0]))
        return 0

class XenRTMakeTickets(XenRTCommand):

    name = "maketickets"
    summary = "Make empty Jira tickets for a test run"
    mandatory = "[--findold] [--branch=<branch>] <suite> <version> [<priority>]"
    group = "Miscellaneous"

    def run(self, args):
        details = {'action': 'maketickets'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 2 or len(args) > 4:
            sys.stderr.write("Invalid usage\n")
            return None
        i = 0
        for arg in args:
            if arg.startswith("--"):
                if arg == "--findold":
                    details["findold"] = "yes"
                    continue
                m = re.match("--branch=(.*)", arg)
                if m:
                    details["branch"] = m.group(1)
                    continue
            elif i == 0:
                suite = arg
            elif i == 1:
                version = arg
            elif i == 2:
                details["priority"] = arg
            i += 1    
        details["suite"] = suite
        details["version"] = version
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTSuiteStatus(XenRTCommand):

    name = "suitestatus"
    summary = "Returns the status of a suite run"
    mandatory = "<suiterun>"
    usage = """
    -r             Report details of resource usage by the suite
    -m             Used with -r, orders list by machine-hours
    """
    group = "Miscellaneous"

    def run(self, args):
        self.advanced = False
        self.orderbymh = False
        details = {'action': 'suitestatus'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        try:
            optlist, optx = getopt.getopt(args[1:], 'rm')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-r':
                    details["resources"] = "yes"
                    details["summary"] = "no"
                    self.advanced = True
                elif flag == "-m":
                    self.orderbymh = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        suiterun = args[0]
        details["suiterun"] = suiterun
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if self.advanced:
            data = {}
            for line in results.splitlines():
                if "=" in line:
                    ll = line.split("=", 1)
                    data[ll[0]] = ll[1]
            if data.has_key("JOBDESCS"):
                self.printout("%-24s %5s %8s %7s %7s\n" %
                              ("Sequence",
                               "Hours",
                               "Machines",
                               "M-Hours",
                               "Job ID"))
                costs = {}
                jobdescs = data["JOBDESCS"].split(",")
                for jobdesc in jobdescs:
                    if data.has_key("RES_%s" % (jobdesc)):
                        ll = data["RES_%s" % (jobdesc)].split(",")
                        jobid = int(ll[0])
                        if ll[1]:
                            duration = int(ll[1])
                        else:
                            duration = 0
                        machines = int(ll[2])
                        if self.orderbymh:
                            dkey = "%08u%s" % (duration * machines, jobdesc)
                        else:
                            dkey = "%08u%s" % (duration, jobdesc)
                        costs[dkey] = (duration, jobdesc, jobid, machines)
                dkeys = costs.keys()
                dkeys.sort()
                for dkey in dkeys:
                    duration, jobdesc, jobid, machines = costs[dkey]
                    if duration == 0:
                        durtxt = "     "
                        mhtxt = "       "
                    else:
                        durtxt = "%5.1f" % (duration/3600.0)
                        mhtxt = "%7.1f" % (duration/3600.0 * machines)
                    self.printout("%-24s %5s %8u %7s %7u\n" %
                                  (jobdesc, durtxt, machines, mhtxt, jobid))
        else:
            self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTDetailID(XenRTCommand):

    name = "detailid"
    summary = "Get the detailid for a specified jobid, phase and test"
    mandatory = "<jobid> <phase> <test>"
    hide = True

    def run(self, args):
        details = {'action': 'detailid'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) <> 3:
            sys.stderr.write("Invalid usage\n")
            return None
        jobid = args[0]
        details["id"] = jobid
        phase = args[1]
        details["phase"] = phase
        test = args[2]
        details["test"] = test
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTHelp(XenRTCommand):

    name = "help"
    summary = "Get a summary of commands"
    group = "Miscellaneous"

    def run(self, args):
        cx = {}
        for c in self.commands.getall():
            if not c.hide:
                if not cx.has_key(c.group):
                    cx[c.group] = []
                cx[c.group].append(c)
        first = ["Job", "Suite", "Machine", "Site"]
        last = ["Miscellaneous", "Other"]
        order = []
        order.extend(first)
        for g in cx.keys():
            if not g in first and not g in last:
                order.append(g)
        order.extend(last)
        for g in order:
            self.printout("\n%s commands:\n\n" % (g))
            for c in cx[g]:
                self.printout("  %-10s %s\n" % (c.name, c.summary))
        self.printout("\nRun \"%s <command> --help\" for usage information.\n"
                      % (sys.argv[0]))        
        return 1

class XenRTSubResults(XenRTCommand):

    name = "subresults"
    summary = "Upload a XML subresults file for a job (server call only)"
    mandatory = "<jobid> <phase> <test>"
    usage = """
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'subresults'}
        if len(args) < 3:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["jobid"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        filename = None
        try:
            optlist, optx = getopt.getopt(args[3:], 'f:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    filename = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        return self.upload(details, filename, proxies=self.proxies)

class XenRTPerfData(XenRTCommand):

    name = "perfdata"
    summary = "Upload a XML performance data file (server call only)"
    usage = """
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'perfdata'}
        filename = None
        try:
            optlist, optx = getopt.getopt(args, 'f:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    filename = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        return self.upload(details, filename, proxies=self.proxies)                

class XenRTUpload(XenRTCommand):

    name = "upload"
    summary = "Upload a results file for a job (server call only)"
    mandatory = "<jobid>"
    usage = """
    [ -p <phase> -t <test> ]  Phase and test for per-test results file.
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'upload'}
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        filename = None
        try:
            optlist, optx = getopt.getopt(args[1:], 'p:t:f:P:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-p':
                    details["phase"] = value
                if flag == '-t':
                    details["test"] = value
                if flag == '-f':
                    filename = value
                if flag == '-P':
                    details["prefix"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        url = self.getServerURL()

        logserver = self.getLogServer(id, proxies=self.proxies)
        if logserver:
            url = logserver_url % logserver

        return self.upload(details, filename, proxies=self.proxies, url=url)                

class XenRTDownload(XenRTCommand):

    name = "download"
    summary = "Download a results file for a job"
    mandatory = "<jobid>"
    usage = """
    [ -p prefix ]   Prefix for file to download.
    [ -f filename ] File to write results to (defaults to stdout)
    [ -g phase ]    Optional phase (test also required)
    [ -t test ]     Optional test (phase also required)
    """
    group = "Miscellaneous"

    def run(self, args):
        self.filename = None
        details = {'action': 'download'}
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id        
        usemasterserver=False
        try:
            optlist, optx = getopt.getopt(args[1:], 'op:f:g:t:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-p':
                    details["prefix"] = value
                elif flag == "-f":
                    self.filename = value
                elif flag == "-g":
                    details["phase"] = value
                elif flag == "-t":
                    details["test"] = value
                elif flag == "-o":
                    usemasterserver = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        url = self.getServerURL()

        if not usemasterserver:
            logserver = self.getLogServer(id, proxies=self.proxies)
            if logserver:
                url = logserver_url % logserver

        u = urlopen_with_retry(url, urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            if self.filename:
                f = file(self.filename, "w")
                f.write(data)
                f.close()
                reply = 1
            else:
                reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results is None:
            return 1
        if not self.filename:
            self.printout(results)
        return 0

class XenRTSchedule(XenRTCommand):

    name = "schedule"
    summary = "Run the job scheduler to assign jobs to machines"
    usage = """
    -v     Verbose output
    -d     Perform a dry run to see what could be scheduled, do not schedule
    -i     Ignore current allocations when performing a dry run
    """
    group = "Scheduler"
    
    def run(self, args):
        details = {'action': 'schedule'}
        showstatus = False
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        try:
            optlist, optx = getopt.getopt(args, 'divj')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-d':
                    details["dryrun"] = "yes"
                elif flag == "-i":
                    details["ignore"] = "yes"
                elif flag == "-v":
                    details["verbose"] = "yes"
                elif flag == "-j":
                    showstatus = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details))
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        if showstatus:
            reply += "Schedule complete\n"
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTMDefine(XenRTCommand):

    name = "mdefine"
    summary = "Define a new test machine"
    mandatory = "<machine> <site>"
    usage = """
    -c <cluster>
    -p <pool>
    -r <resourcestring>
    -f <flags>
    -d <description>
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'mdefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        details["machine"] = args[0]
        details["site"] = args[1]
        try:
            optlist, optx = getopt.getopt(args[2:], 'c:p:r:f:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-c':
                    details["cluster"] = value
                if flag == '-p':
                    details["pool"] = value
                if flag == '-r':
                    details["resources"] = value
                if flag == '-f':
                    details["flags"] = value
                if flag == '-d':
                    details["descr"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMDefineXML(XenRTCommand):

    name = "mdefinexml"
    summary = "Define test machines from XML config files"
    mandatory = ""
    usage = """
    -s <site>
    """
    group = "Machine"

    def run(self, args):
        global _confdir

        site = None

        try:
            optlist, optx = getopt.getopt(args, 's:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-s':
                    site = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        if not site:
            # See if there is a CONFDIR/siteid file
            try:
                f = file("%s/siteid","r")
                site = f.read().strip()
                f.close()
            except:
                site = "DEFAULT"

        # Try and read in the XML files
        files = glob.glob("%s/machines/*.xml" % (_confdir))
        machines = []
        for filename in files:
            r = re.search(r"%s/machines/(.*)\.xml" % (_confdir), filename)
            if r:
                machine = r.group(1)
                machines.append(machine)

        for machine in machines:
            print "Adding machine %s" % (machine)
            xmd = XenRTMDefine(None)
            args = [machine,site]
            xmd.dispatch(args)

class XenRTMUndefine(XenRTCommand):

    name = "mundefine"
    summary = "Remove a machine from the system"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mundefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["machine"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTCaseSet(XenRTCommand):

    name = "caseset"
    summary = "List a set of test cases"
    mandatory = "<set>"
    hide = True

    def run(self, args):
        details = {'action': 'caseset'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTCaseSets(XenRTCommand):

    name = "casesets"
    summary = "List all known casesets"
    hide = True

    def run(self, args):
        details = {'action': 'casesets'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTAddCase(XenRTCommand):

    name = "addcase"
    summary = "Add a test case to a set"
    mandatory = "<set>"
    usage = """
    -g <group>
    -c <testcase>
    -x <subgroup>
    -s <subcase>
    """
    hide = True

    def run(self, args):
        details = {'action': 'addcase'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'g:c:s:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-g':
                    details["tgroup"] = value
                if flag == '-c':
                    details["tcase"] = value
                if flag == '-x':
                    details["tcgroup"] = value
                if flag == '-s':
                    details["subtcase"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not details.has_key("tcase"):
            sys.stderr.write("Need a test case\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTDelCase(XenRTCommand):

    name = "delcase"
    summary = "Delete a test case from a set"
    mandatory = "<set>"
    usage = """
    -g <group>
    -c <testcase>
    -x <subgroup>
    -s <subcase>
    """
    hide = True

    def run(self, args):
        details = {'action': 'delcase'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'g:c:s:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-g':
                    details["tgroup"] = value
                if flag == '-c':
                    details["tcase"] = value
                if flag == '-x':
                    details["tcgroup"] = value
                if flag == '-s':
                    details["subtcase"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not details.has_key("tcase"):
            sys.stderr.write("Need a test case\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply


class XenRTInteract(XenRTCommand):

    name = "interact"
    summary = "Interact with a running job"
    mandatory = "{<jobid>|<host:port>}"
    usage = """
    [-l]               List running test cases
    [-c] <testcase>    Continue a paused testcase
    [-u] <testcase>    Continue a paused testcase without blocking on failure
    [-n] <testcase>    Abort a paused testcase
    [-x] <testcase>    Remove the automatic 24 hours unpause of a testcase
    [-C]               Continue any paused testcases
    [-N]               Abort any paused testcases
    [-R] <tcase>=<res> Set a testcase result (PASS|FAIL|ERROR|SKIPPED)
    [-D] <var>=<value> Set a config variable (var may be a /-separated split)
    [-d]               Dump config
    [-A]               Abort a run (after the current tests have completed)
    [-f]               Flush harness.err and harness.out log buffers
    [-I]               Display information about the hosts and guest
    [-r] <guest>:<filename>
                       Read a file from a named guest
    [-s]               Interactive shell
    [-L]               Show last 1000 log output lines
    """
    group = "Job"

    def run(self, args):

        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        if string.find(args[0], ":") > -1:
            hostport = args[0]
        else:
            try:
                id = string.atoi(args[0])
            except:
                details = {'action': 'machine'}
                details['USERID'] = pwd.getpwuid(os.getuid())[0]
                details["machine"] = args[0]
                u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                                   proxies=self.proxies)
                reply = None
                data = u.read()
                if data[0:5] == "ERROR":
                    sys.stderr.write(data)
                    return None
                else:
                    reply = self.parse_job(data)
                u.close()
                if not reply.has_key("JOBID"):
                    sys.stderr.write("Machine has no Job ID")
                    return None
                id = string.atoi(reply['JOBID'])
                 
            details = {'action': 'status'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["id"] = id
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            reply = None
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
            else:
                reply = self.parse_job(data)
            u.close()
            if not reply.has_key("XMLRPC"):
                sys.stderr.write("Job has no XMLRPC variable\n")
                return None
            hostport = reply["XMLRPC"]
        s = xmlrpclib.Server("http://%s" % (hostport))
        shell = False
        logger = False
        try:
            optlist, optx = getopt.getopt(args[1:], 'lc:CD:dAfIr:sLR:n:Nu:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-l':
                    for t in s.getRunningTests():
                        print "%-30s %s" % (t[0], t[1])
                elif flag == '-c':
                    s.setRunningStatus(value, "Continue")
                elif flag == '-u':
                    s.setBlockingStatus(value, False)
                    s.setRunningStatus(value, "Continue")
                elif flag == '-n':
                    s.setRunningStatus(value, "NotContinue")
                elif flag == '-x':
                    s.setRunningStatus(value, "Indefinite")
                elif flag == '-R':
                    l = string.split(value, '=')
                    testcase = l[0]
                    if l[1] == 'PASS':
                        result = 1
                    elif l[1] == 'FAIL':
                        result = 2
                    elif l[1] == 'ERROR':
                        result = 4
                    elif l[1] == 'SKIPPED':
                        result = 5
                    else:
                        sys.stderr.write("Unknown result '%s'" % (l[1]))
                        return None
                    s.setTestResult(testcase, result)
                elif flag == '-C':
                    for t in s.getRunningTests():
                        if t[1] == "Paused":
                            s.setRunningStatus(t[0], "Continue")
                elif flag == '-N':
                    for t in s.getRunningTests():
                        if t[1] == "Paused":
                            s.setRunningStatus(t[0], "NotContinue")
                elif flag == "-D":
                    try:
                        var, varval = string.split(value, "=", 1)
                        if string.find(var, "/") > -1:
                            var = string.split(var, "/")
                        s.setConfigVariable(var, varval)
                    except:
                        sys.stderr.write("Error parsing -D variable '%s'\n" %
                                         (value))
                        return None
                elif flag == "-d":
                    print s.dumpConfig()
                elif flag == "-A":
                    s.abortRun()
                elif flag == "-f":
                    s.flushLogs()
                elif flag == "-I":
                    hosts = s.getHostList()
                    for h in hosts:
                        info = s.getHostInfo(h)
                        print "Host: %s (%s)" % (info[0], info[1])
                    guests = s.getGuestList()
                    for g in guests:
                        info = s.getGuestInfo(g)
                        print "Guest: %s (%s) uuid=%s" % \
                              (info[0], info[1], info[5])
                elif flag == "-r":
                    ll = string.split(value, ":", 1)
                    if len(ll) != 2:
                        sys.stderr.write("Error parsing -r variable '%s'\n" %
                                         (value))
                        return None
                    data = s.getGuestFile(ll[0], ll[1])
                    sys.stdout.write(data.data)
                elif flag == "-s":
                    shell = True
                elif flag == "-L":
                    logger = True
                    
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        if shell:
            print "XenRT interactive Python shell."
            import readline
            while True:
                try:
                    command = raw_input(">>> ")
                    print s.xmlrpcShell(command)
                except EOFError, e:
                    print ""
                    break

        if logger:
            print string.join(s.xmlrpcLogger(), '')

class XenRTSList(XenRTCommand):

    name = "slist"
    summary = "Get a list of sites"
    usage = """
    [-p]             Show site properties
    [-q]             Quiet mode (don't show header)
    """
    group = "Site"

    def run(self, args):
        self.controller = False
        details = {'action': 'slist'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        try:
            optlist, optx = getopt.getopt(args, 'pq')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-q":
                    details["quiet"] = "yes"
                elif flag == "-p":
                    details["props"] = "yes"
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            if self.controller:
                reply = []
                lines = string.split(data, "\n")
                for l in lines:
                    if l != "":
                        reply.append(string.split(l,","))
            else:
                reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            if self.controller:
                for line in results:
                    self.printout("%s\n" % (string.join(line, ",")))
            else:
                self.printout(results)
        return 0

class XenRTSDefine(XenRTCommand):

    name = "sdefine"
    summary = "Define a new site"
    mandatory = "<site>"
    usage = """
    -f <flags>
    -d <description>
    """
    group = "Site"

    def run(self, args):
        details = {'action': 'sdefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["site"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'f:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    details["flags"] = value
                elif flag == '-d':
                    details["descr"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSUndefine(XenRTCommand):

    name = "sundefine"
    summary = "Remove a site from the system"
    mandatory = "<site>"
    group = "Site"

    def run(self, args):
        details = {'action': 'sundefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["site"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSUpdate(XenRTCommand):

    name = "supdate"
    summary = "set/update a field of site data"
    mandatory = "<site> <field> <value>"
    group = "Site"

    def run(self, args):
        details = {'action': 'supdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSite(XenRTCommand):

    name = "site"
    summary = "Get data for the specified site"
    mandatory = "<site>"
    group = "Site"

    def run(self, args):
        details = {'action': 'site'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        return reply

    def render(self, args, results):
        for key in results.keys():
            self.printout("%s='%s'\n" % (key, results[key]))
        return 0

class XenRTRunSuite(XenRTCommand):

    name = "runsuite"
    summary = "Run a test suite on a specified revision"
    mandatory = "<suite> <revision>"
    usage = """
    [-b <branch>]     Branch to test
    [-s <sku>]        SKU to test
    [-S <seqs>]       Suite sequences to run
    [-R]              Attempt to rerun if suite already exists
    [-v]              Verbose
    """
    group = "Suite"

    def findBuild(self):
        global _jenkins
        for i in range(20):
            time.sleep(5)
            j = json.load(urlopen_with_retry("%s/job/Suite%%20Run%%20Basic/api/json?depth=1" % _jenkins))
            for b in j['builds']:
                for a in b['actions']:
                    if a.has_key("parameters"):
                        for p in a['parameters']:
                            if p['name'] == "Cookie" and p['value'] == self.cookie:
                                self.build = b['url']
                                if self.verbose:
                                    print "Found Build %s" % self.build
                                return
            if self.verbose:
                print "Could not find build in job, retrying..."
        raise Exception("Could not find build")

    def waitForBuildCompletion(self):
        for i in range(30):
            j = json.load(urlopen_with_retry("%s/api/json" % self.build))
            if self.verbose:
                print "Building status: %s" % j['building']
            if not j['building']:
                if j['result'] != "SUCCESS":
                    # Find the failure reason if available
                    lines = urlopen_with_retry("%s/consoleText" % self.build)
                    reason = "Unknown"
                    for l in lines:
                        if l.startswith("REASON: "):
                            reason = l[8:].strip()
                            break
                    raise Exception("Could not start suite: %s (%s)" % (str(j['result']), reason))
                return
            time.sleep(10)

        raise Exception("Starting suite timed out")

    def getSuiteRunAndJobs(self):
        j = json.load(urlopen_with_retry("%s/api/json" % self.build))
        m = re.search("\((\d+)\)$", j['fullDisplayName'])
        if not m:
            raise Exception("Could not determine suite run number")
        sr = m.group(1)


        lines = urlopen_with_retry("%s/consoleText" % self.build)
        jobs = {}
        for l in lines:
            m = re.match("^Starting (\S+?)\.\.\. (\d+)$", l)
            if m:
                jobs[m.group(1)] = m.group(2)

        return (sr, jobs)

    def run(self, args):
        global _jenkins
        self.verbose = False
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        
        self.cookie = str(random.randint(0, 2**31-1))
        jenkins = {"Update Mercurial": "false",
                   "Additional_Args": "",
                   "Cookie": self.cookie,
                   "Attempt Rerun": "false"}

        jenkins['Suite'] = "/etc/xenrt/suites/%s" % args[0]
        jenkins['Version'] = args[1]
        if len(args) > 2:
            optlist, optx = getopt.getopt(args[2:], 'b:s:D:S:RV')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-b":
                    jenkins['Branch'] = value
                elif flag == "-s":
                    jenkins['sku'] = "/etc/xenrt/suites/%s" % value
                elif flag == "-S":
                    jenkins["Additional_Args"] += "--suite-seqs %s " % value
                elif flag == "-D":
                    jenkins["Additional_Args"] += "-D %s "% value
                elif flag == "-V":
                    self.verbose = True
                elif flag == "-R":
                    jenkins['Attempt Rerun'] = "true"
                    
        u = urlopen_with_retry("%s/job/Suite%%20Run%%20Basic/buildWithParameters" % _jenkins, urllib.urlencode(jenkins))
        u.close()
        if self.verbose:
            print "Suite submitted, finding build number..."
        self.findBuild()
        self.waitForBuildCompletion()
        (suite, jobs) = self.getSuiteRunAndJobs()

        reply = ["SR%s\n" % suite]
        for j in jobs.keys():
            reply.append("%s:%s\n" % (j, jobs[j]))
        return reply

    def render(self, args, results):
        for r in results:
            self.printout(r)
        return 0

class XenRTWarnings(XenRTCommand):

    name = "warnings"
    summary = "Display warnings or other data generated by a job or job group"
    usage = """
    [ -j <jobid> ]           query by job ID
    [ -g <jobgroup> ]        query by job group
    [ -k <key> ]             type of data to display, default is 'warning'
                             alternatives include 'comment' and 'data'
    """
    group = "Miscellaneous"

    def run(self, args):
        self.showsr = False
        details = {'action': 'warnings'}
        try:
            optlist, optx = getopt.getopt(args, 'j:g:k:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-j":
                    details["jobid"] = value
                elif flag == "-g":
                    details["jobgroup"] = value
                elif flag == "-k":
                    details["key"] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            else:
                if line[-1] == "\n":
                    ll = string.split(line[:-1], "\t")
                else:
                    ll = string.split(line, "\t")
                reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):
        for ll in results:
            self.printout("%s %s %s\n" % (ll[0], ll[1], ll[2]))

class _XenRTControllerOperation(XenRTCommand):
    def getControllerAddrForMachine(self,machine,args):
        site = None
        self.overrideconsole = None
        try:
            optlist, optx = getopt.getopt(args, 's:',['override-console='])
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-s":
                    site = value
                elif flag == "--override-console":
                    self.overrideconsole = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not site:
            details = {'action': 'machine'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["machine"] = machine
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            reply = None
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
            else:
                reply = self.parse_job(data)
            u.close()
        
            if not reply.has_key("SITE"):
                return None
            site = reply["SITE"]
        return self.getControllerAddr(site)

    def getControllerAddr(self,site):
        details = {'action': 'site'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        details["site"] = site
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        if reply.has_key("CTRLADDR"):
            return reply["CTRLADDR"] 
        return None
        
class XenRTSNetwork(_XenRTControllerOperation):
    name = "snetwork"
    summary = "Show network info for a site"
    mandatory = "<site>"
    group = "Site"
    
    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details = {'action': 'network'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]

        addr = self.getControllerAddr(site)
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        self.printout(results)
        return 0

class XenRTMConfig(_XenRTControllerOperation):
    name = "mconfig"
    summary = "See config for a machine"
    mandatory = "<machine>"
    usage = """
    [ --generated ] See the generated config looked up from RackTables
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'mconfig'}
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], '', "generated")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '--generated':
                    details["generated"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        addr = self.getControllerAddrForMachine(machine, [])
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr  + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        u.close()
        return data
        
    def render(self, args, results):
        self.printout(results)
        return 0


class XenRTPower(_XenRTControllerOperation):

    name = "power"
    summary = "Power control a machine"
    mandatory = "<machine> off|on|reboot|nmi"
    group = "Machine"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[2:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {'action': 'power'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if args[1] not in ["off", "on", "reboot", "nmi"]:
            sys.stderr.write("Invalid power operation - must be one of off, on or reboot\n")
            return None
        details["powerop"] = args[1]
        details["machine"] = machine
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        self.printout(results)
        return 0

class XenRTConsole(_XenRTControllerOperation):
    name = "console"
    summary = "Serial console for a machine"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        global _console
        global _conserver
        results = None
        console = os.popen("which console").read().strip()
        if console == "":
            console = _console
        machine = args[0]
        if machine == "-l":
            details = {'action': 'mlist2'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["controller"] = "yes"
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)

            machines = map(lambda x: x.split(",")[0], u.readlines())

            results = []

            for l in os.popen("%s -p 3109 -U -M %s -u" % (console, _conserver)).readlines():
                m = re.match(" (.+?)\s+(.+?)\s+(.+?)", l)
                if m:
                    if not m.group(1) in machines:
                        results.append(m.group(1))
        else:
            addr = self.getControllerAddrForMachine(machine, args[1:])
            if not addr:
                addr = _conserver
            if self.overrideconsole:
                console = self.overrideconsole

            os.system("%s -p 3109 -U -M %s %s" % (console, addr, machine.split(".")[0].split("_")[0]))
        return results

    def render(self, args, results):
        if results:
            for line in results:
                self.printout("%s\n" % line)
        return 0

class XenRTGlobalResLock(XenRTCommand):
   
    name = "globalreslock"
    summary = "Lock a global resource (controller command)"
    mandatory = "<type> <jobid> <site>"
    group = "resources"

    def run(self, args):
        details = {'action': 'lockresource',
                   'type': args[0],
                   'job': args[1],
                   'site': args[2]}

        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details), proxies=self.proxies)

        ret = u.read()
        data = json.loads(ret)
        
        return data

    def render(self, args, results):
        if not 'name' in results.keys():
            sys.stderr.write("ERROR: Could not lock resource\n")
            return 1
        self.printout(json.dumps(results)+"\n")
        return 0

class XenRTGlobalResRelease(XenRTCommand):
    name = "globalresrelease"
    summary = "Release a global resource"
    mandatory = "<job id or resource name>"
    group = "resources"

    def run(self, args):
        details = {'action': 'releaseresource'}
        try:
            details['job'] = int(args[0])
        except:
            details['name'] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)

        data = u.read()

        if data[0:5] == "ERROR":
            reply = ""
            sys.stderr.write(data)
        else:
            reply = "OK"
        return reply

    def render(self, args, results):
        print results
        return 0

class XenRTMGetResource(_XenRTControllerOperation):
    name = "mgetresource"
    summary = "Get a controller resource for a machine"
    mandatory = "<machine> <resource type> [<args>]"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[2:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {"machine": args[0], "type": args[1]}
        if len(args) > 2:
            details['args'] = " ".join(args[2:])
        u = urlopen_with_retry("http://%s/xenrt/api/controller/getresource" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
class XenRTMListResources(_XenRTControllerOperation):
    name = "mlistresources"
    summary = "List controller resources for a machine"
    mandatory = "<machine>"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[1:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {"machine": args[0]}
        u = urlopen_with_retry("http://%s/xenrt/api/controller/listresources" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
class XenRTMReleaseResources(_XenRTControllerOperation):
    name = "mreleaseresources"
    summary = "Relase controller resources"
    mandatory = "<machine> [<resource1> <resource2>...]"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[1:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = []
        for r in args[1:]:
            details.append("resource=%s" % r)
        
        u = urlopen_with_retry("http://%s/xenrt/api/controller/releaseresources" % addr + "?" + "&".join(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
#############################################################################

class Commands:

    def __init__(self, outfd=sys.stdout, raw=0):
        self.outfd = outfd
        self.raw = raw
        self.commands = {}
        self.add(XenRTSubmit)
        self.add(XenRTRun)
        self.add(XenRTStatus)
        self.add(XenRTHelp)
        self.add(XenRTComplete)
        self.add(XenRTEmail)
        self.add(XenRTList)
        self.add(XenRTUpdate)
        self.add(XenRTUpload)
        self.add(XenRTDownload)
        self.add(XenRTRemove)
        self.add(XenRTSetResult)
        self.add(XenRTLogData)
        self.add(XenRTShowLog)
        self.add(XenRTJobGroup)
        self.add(XenRTMachine)
        self.add(XenRTMList)
        self.add(XenRTMConfig)
        self.add(XenRTMList2)
        self.add(XenRTMUpdate)
        self.add(XenRTBorrow)
        self.add(XenRTReturn)
        self.add(XenRTEvent)
        self.add(XenRTPool)
        self.add(XenRTProp)
        self.add(XenRTMRes)
        self.add(XenRTMBroken)
        self.add(XenRTMFixed)
        self.add(XenRTSFlag)
        self.add(XenRTUtilisation)
        self.add(XenRTMStatus)
        self.add(XenRTSchedule)
        self.add(XenRTMDefine)
        self.add(XenRTMDefineXML)
        self.add(XenRTMUndefine)
        self.add(XenRTCaseSet)
        self.add(XenRTCaseSets)
        self.add(XenRTAddCase)
        self.add(XenRTDelCase)
        self.add(XenRTSubResults)
        self.add(XenRTInteract)
        self.add(XenRTPerfData)
        self.add(XenRTMakeTickets)
        self.add(XenRTSuiteStatus)
        self.add(XenRTDetailID)
        self.add(XenRTSList)
        self.add(XenRTSDefine)
        self.add(XenRTSUndefine)
        self.add(XenRTSUpdate)
        self.add(XenRTSite)
        self.add(XenRTRunSuite)
        self.add(XenRTWarnings)
        self.add(XenRTRerun)
        self.add(XenRTPower)
        self.add(XenRTSNetwork)
        self.add(XenRTConsole)
        self.add(XenRTGlobalResLock)
        self.add(XenRTGlobalResRelease)
        self.add(XenRTMGetResource)
        self.add(XenRTMListResources)
        self.add(XenRTMReleaseResources)

    def add(self, cl):
        c = cl(self)
        self.commands[c.name] = c

    def has(self, command):
        return self.commands.has_key(command)

    def run(self, command, args):
        return self.commands[command].dispatch(args, raw=self.raw)

    def getall(self):
        return self.commands.values()

    def setProxies(self, proxies):
        for c in self.commands.values():
            c.proxies = proxies

#############################################################################

def xenrt_profile_stats():
    global XRTPROF_FILENAME
    global XRTPROF

    XRTPROF.close()
    
    stats = hotshot.stats.load(XRTPROF_FILENAME)
    stats.strip_dirs()
    stats.sort_stats('time', 'calls')
    stats.print_stats(120)


if __name__ == '__main__':
    if PROFILER_ENABLED:
	import hotshot
    	import hotshot.stats
	import atexit

    	XRTPROF = hotshot.Profile(XRTPROF_FILENAME)
        atexit.register(xenrt_profile_stats)

    com = Commands(raw=0)

    # Dirty hack to use the JOBSERVER_PROXY variable
    if os.path.exists("/etc/xenrt/site.xml"):
        f = file("/etc/xenrt/site.xml", "r")
        data = f.read()
        f.close()
        r = re.search("<JOBSERVER_PROXY>(http:.*?)<\/JOBSERVER_PROXY>", data)
        if r:
            com.setProxies({'http': r.group(1)})

    if len(sys.argv) < 2:
        sys.stderr.write("Usage: %s <command> [options]\n" % (sys.argv[0]))
        sys.stderr.write("  run '%s help' for a list of commands\n" % \
                         (sys.argv[0]))
        sys.exit(1)

    if com.has(sys.argv[1]):
    	if PROFILER_ENABLED:
        	rc = XRTPROF.runcall(com.run, sys.argv[1], sys.argv[2:])
	else:
		rc = com.run(sys.argv[1], sys.argv[2:])
        if com.raw:
            if rc:
                print rc
                sys.exit(0)
            sys.exit(1)
        sys.exit(rc)

    if sys.argv[1] == '--help':
        sys.exit(com.run("help", sys.argv[2:]))
        
    sys.stderr.write("Command '%s' not recognised.\n" % (sys.argv[1]))
    sys.stderr.write("  run '%s help' for a list of commands\n" %
                     (sys.argv[0]))
    sys.exit(1)
    

