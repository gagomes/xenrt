#!/usr/bin/python
#
# XenRT Control Suite client. Interacts with HTTP server.
#
# (C) XenSource UK Ltd. 2005
# James Bulpin, November-December 2005

import sys, string, getopt, urllib, os, pwd, tempfile, xmlrpclib, shutil, json
import os.path, re, glob, random, time, datetime
import xenrtapi

PROFILER_ENABLED = ("XENRT_PROFILE" in os.environ)
XRTPROF = None
XRTPROF_FILENAME = os.path.join(("TMP" in os.environ and os.environ["TMP"] or \
	"/tmp"), "xenrt.prof")

server_url_base = '@webcontrdir@'
logserver_url_base = 'http://%s/share/control/'
s = os.getenv("WEB_CONTROL_PATH")
if s:
    server_url_base = s
if os.getenv("XENRT_DEBUG") == "yes":
    server_url = server_url_base + 'queue-devel.cgi'
    logserver_url = logserver_url_base + 'queue-devel.cgi'
    queuecgi = "queue-devel.cgi"
else:
    server_url = server_url_base + 'queue.cgi'
    logserver_url = logserver_url_base + 'queue.cgi'
    queuecgi = "queue.cgi"
_sharedir = "@sharedir@"
_confdir = "@confdir@"
_console = "@console@"
_conserver = "@conserver@"
_jenkins = "@jenkins@"
_conskey = """@conskey@"""

class XenRTCommand:

    name = "<default>"
    summary = "<--- no summary --->"
    usage = ""
    mandatory = ""
    group = "Other"

    commands = None
    hide = False
    NEW = False

    def __init__(self, commands):
        self.commands = commands
        self.proxies = None
        self.xenrt = xenrtapi.XenRT()

    def getServerURL(self):
        return server_url
   
    def getLogServerURL(self, jobid):
        logserver = self.getLogServer(jobid, proxies=self.proxies)
        return logserver_url % logserver

    def dispatch(self, args, raw=0):

        if len(args) > 0 and args[0] in ("--help", "-h"):
            print "%s\n" % (self. summary)
            if self.usage == "":
                opts = ""
            else:
                opts = " [options]"
            print "Usage: %s %s %s%s" % \
                  (sys.argv[0], self.name, self.mandatory, opts)
            print self.usage
            return 0
        if self.NEW:
            return self.render(args)
        else:
            results = self.run(args)
            if raw:
                return results
            else:
                if results:
                    return self.render(args, results)
                else:
                    return 1

    def run(self, args):
        return 1

    def boolToYN(self, val):
        return "yes" if val else "no"

    def render(self, args, results):
        return 0

    def printout(self, str):
        if self.commands and self.commands.outfd:
            fd = self.commands.outfd
        else:
            fd = sys.stdout
        fd.write(str)

    def getLogServer(self, job, proxies=None, params=None):
        if not params:
            params=["LOG_SERVER", "JOB_FILES_SERVER"]
        details = {'action': 'status'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        details["id"] = job
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=proxies)

        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        for p in params:
            if reply.has_key(p):
                return reply[p]
        return None

    def uploadWithCurl(self, details, filename, url, proxies=None):
        cmd = ["curl"]
        cmd.append("-H \"Expect:\"")
        if proxies and proxies.has_key('http'):
            cmd.append("--proxy %s" % (proxies['http'][7:]))
        for d in details.keys():
            cmd.append("-F '%s=%s'" % (d, details[d]))
        cmd.append("-F file=@%s" % (filename))
        cmd.append(url)
        rc = os.system("%s > /dev/null 2>&1" % (string.join(cmd)))
        if rc == 0:
            return 1
        return None

    def upload(self, details, filename, proxies=None, scheduler=False):
        if scheduler:
            url = self.getServerURL()
        else:
            url = self.getLogServerURL(details['id'])
        if os.path.exists("/usr/bin/curl"):
            return self.uploadWithCurl(details, filename, url, proxies=proxies)
        if filename:
            f = file(filename, 'r')
        else:
            f = sys.stdin
        #data = f.read()
        details["file"] = f.read()
        if filename:
            f.close()
        u = urlopen_with_retry(url, urllib.urlencode(details), proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

    def parse_job(self, data):

        reply = {}
        for s in string.split(data, "\n"):
            #sys.stderr.write(":%s:" % (s))
            ll = string.split(s, "=", 1)
            if len(ll) == 2:
                key = ll[0]
                value = ll[1]
                if value[0] == "'":
                    value = value[1:-1]
                reply[key] = value
        return reply

    def parse_options(self, args):
        secondary = {}
        details = {}
        argmap = {
            '-v': 'VERSION',
            '-r': 'REVISION',
            '-o': 'OPTIONS',
            '-n': 'DEPS',
            '-R': 'REPO',
            '-t': 'TARGET',
            '-F': 'FLAGS'
            }
        argmapbool = {
            '-P': 'PUBLISH',
            '-d': 'DEBUGCMD',
            }
        try:
            optlist, optx = getopt.getopt(args, 'm:v:r:o:n:R:t:F:PU:dU:D:',
                                          ['rpm', 'optrpm', 'nfs', 'gnbd',
                                           'gnbdserver=', 'gnbdclient=',
                                           'domu', 'patch=', 'xenargs=',
                                           'distro=', 'sep', 'smpdom0',
                                           'nobuildopts', 'filevbd', 'swap',
                                           'filevbdnfs', 'carboncd=',
                                           'carbonpatch=', 'xenbuild=',
                                           'ring0', 'perftag=', 'email=',
                                           'tarball=', 'noxenargs',
                                           'nodom0args', 'dom0args=',
                                           'hold=', 'holdfail=', 'arch=',
                                           'sepkern=', 'sepkrev=',
                                           'failkeep', 'res=', 'pool=',
                                           'xgt=', 'xgtnfs=', 'qcow',
                                           'removepassed', 'rpmpath=',
                                           'guestrpms=', 'pw=', 'guestaddr=',
                                           'pq=', 'pqpatch=', 'skip=',
                                           'skipgroup=', 'skiptype=',
                                           'run=', 'rungroup=',
                                           'pause-on-fail=',
                                           'pause-on-pass=',
                                           'hvarch=', 'no-finally',
                                           'debug', 'verbose', 'number=',
                                           'priority=', 'customsequence=',
                                           'customupdates=',
                                           'perf-data=', 'perf-regress=',
                                           'testcasefiles=', 'res1=',
                                           'inputs=',
                                           'flags=','guard=',
                                           'xenrtpqname='])
            for argpair in optlist:
                (flag, value) = argpair
                if argmap.has_key(flag):
                    details[argmap[flag]] = value
                elif argmapbool.has_key(flag):
                    details[argmapbool[flag]] = "yes"
                elif flag == "-m":
                    details['MACHINE'] = value
                    details['MACHINES_SPECIFIED'] = "yes"
                elif flag == "--rpm":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                elif flag == "--rpmpath":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                    details['OPTION_RPM_PATH'] = value
                elif flag == "--guestrpms":
                    details['OPTION_GUEST_RPMS'] = value
                    details['OPTION_XEN_PACKAGE_G'] = "rpm"
                elif flag == "--optrpm":
                    details['OPTION_XEN_PACKAGE'] = "rpm"
                    details['RPMARG'] = "2"
                elif flag == "--nfs":
                    details['OPTION_GUEST_ROOT'] = "nfs"
                elif flag == "--filevbd":
                    details['OPTION_GUEST_ROOT'] = "file"
                elif flag == "--filevbdnfs":
                    details['OPTION_GUEST_ROOT'] = "file"
                    details['OPTION_GUEST_BACKING'] = "nfs"
                elif flag == "--qcow":
                    details['OPTION_GUEST_ROOT'] = "qcow"
                elif flag == "--gnbd":
                    details['OPTION_USE_GNBD'] = "yes"
                elif flag == "--gnbdserver":
                    details['OPTION_GNBD_SERVER'] = value
                elif flag == "--gnbdclient":
                    details['OPTION_GNBD_SERVE_FOR'] = value
                elif flag == "--domu":
                    details['OPTION_ONLY_DOMU'] = "yes"
                    details['OPTION_SEP_DOM0U'] = "yes"
                    details['OPTION_BUILD_COMPONENTS'] = "kernels"
                    details['XEN_BUILD_OPTIONS2'] = "KERNELS=linux-2.6-xen0"
                    details['EXTRA_BUILD_OPTIONS'] = "KERNELS=linux-2.6-xenU"
                elif flag == "--patch":
                    details['PATCH_XEN'] = os.path.basename(value)
                    secondary['patch'] = value
                elif flag == "--testcasefiles":
                    tl = [ os.path.basename(x) for x in 
                           string.split(value, ",") ]
                    details['TESTCASEFILES'] = string.join(tl, ",")
                    secondary['testcasefiles'] = value
                elif flag == "--customsequence":
                    details['CUSTOM_SEQUENCE'] = "yes"
                    details['DEPS'] = os.path.basename(string.split(value, ",")[0])
                    secondary['seqfiles'] = value
                elif flag == "--customupdates":
                    updates = []                
                    for u in string.split(value, ","):
                        if not os.path.exists(u):
                            sys.stderr.write("Update %s doesn't exist on this machine." % u)
                            return None, None
                        known_formats = ["rpm", "tar", "tar.gz", "tgz", "tar.bz", "tbz"]                    
                        if len(filter(lambda ext: u.endswith("." + ext), known_formats)) == 0:
                            sys.stderr.write("Update %s has an unknown format ."
                                             "Only the following formats are supported: %s"
                                             % (u, known_formats))
                            return None, None
                        updates.append(os.path.basename(u))
                    details['CUSTOM_UPDATES'] = string.join(updates, ",")
                    secondary['customupdates'] = value
                elif flag == "--perf-data":
                    details['PERFDATAFILE'] = "yes"
                    secondary['perfdata'] = value
                elif flag == "--perf-regress":
                    details['PERFREGRESSFILE'] = "yes"
                    secondary['perfregress'] = value
                elif flag == "--xenargs":
                    details['XEN_EXTRA_ARGS_USER'] = value
                elif flag == "--dom0args":
                    details['DOM0_EXTRA_ARGS_USER'] = value
                elif flag == "--noxenargs":
                    details['OPTION_NO_XEN_ARGS'] = "yes"
                elif flag == "--nodom0args":
                    details['OPTION_NO_DOM0_ARGS'] = "yes"
                elif flag == "-U":
                    details['USERID'] = value
                elif flag == "--distro":
                    try:
                        (pref, rest) = string.split(value, ":", 1)
                        guest = string.atoi(pref)
                        if rest[-1] == "+":
                            rest = rest[:-1]
                            details['OPTION_XEN_PACKAGE[%u]' % (guest)] = \
                                                             "existing"
                        details['ROOT_DISTRO_DOM[%u]' % (guest)] = rest
                        details['OPTION_GUEST_XGT[%u]' % (guest)] = rest
                    except:
                        details['ROOT_DISTRO'] = value
                        details['OPTION_GUEST_XGT'] = value
                elif flag == "--sep":
                    details['OPTION_SEP_DOM0U'] = "yes"
                elif flag == "--smpdom0":
                    details['OPTION_SMP_DOM0'] = "yes"
                elif flag == "--nobuildopts":
                    details['OPTION_CLEAR_BUILDOPTS'] = "yes"
                elif flag == "--debug":
                    details['OPTION_DEBUG'] = "yes"
                elif flag == "--verbose":
                    details['OPTION_VERBOSE'] = "yes"
                elif flag == "--swap":
                    details['OPTION_SWAP_DOMU'] = "yes"
                elif flag == "--carboncd":
                    details['CARBON_CD_IMAGE'] = value
                elif flag == "--carbonpatch":
                    details['CARBON_INSTALLER_PATCH'] = value
                elif flag == "--xenbuild":
                    details['USER_BUILD_OPTIONS'] = value
                elif flag == "--ring0":
                    details['USER_BUILD_OPTIONS'] = "supervisor_mode_kernel=y"
                    details['OPTION_DEFAULT_GLIBC'] = "yes"
                elif flag == "--perftag":
                    details['PERFTAG'] = value
                elif flag == "--email":
                    details['EMAIL'] = value
                elif flag == "--tarball":
                    try:
                        (pref, rest) = string.split(value, ":", 1)
                        guest = string.atoi(pref)
                        details['OPTION_XEN_PACKAGE[%u]' % (guest)] = "tarball"
                        details['INSTALLATION_TARBALL[%u]' % (guest)] = rest
                    except:
                        details['INSTALLATION_TARBALL[0]'] = value
                        details['OPTION_XEN_PACKAGE'] = "tarball"
                elif flag == "--hold":
                    details['MACHINE_HOLD_FOR'] = value
                elif flag == "--holdfail":
                    details['MACHINE_HOLD_FOR_FAIL'] = value
                elif flag == "--arch":
                    (pref, rest) = string.split(value, ":", 1)
                    guest = string.atoi(pref)
                    details['GUEST_ARCH[%u]' % (guest)] = rest
                elif flag == "--sepkern":
                    details['SEPARATE_KERNEL_TREE'] = value
                elif flag == "--sepkrev":
                    details['OPTION_SEP_KREV'] = value
                elif flag == "--failkeep":
                    details['CLEANUP'] = "onsuccess"
                elif flag == "--res":
                    details['RESOURCES_REQUIRED'] = value
                elif flag == "--res1":
                    details['RESOURCES_REQUIRED_1'] = value
                elif flag == "--pool":
                    details['POOL'] = value
                elif flag == "--xgt":
                    if details.has_key("EXTRA_XGTS"):
                        details['EXTRA_XGTS'] = details['EXTRA_XGTS'] + " " \
                                                + value
                    else:
                        details['EXTRA_XGTS'] = value
                elif flag == "--xgtnfs":
                    details['OPTION_XGT_NFS'] = value
                elif flag == "--pw":
                    details['ROOT_PASSWORDS'] = value
                elif flag == "--guestaddr":
                    details['GUEST_HOSTNAME[1]'] = value
                elif flag == "-D":
                    try:
                        var, varval = string.split(value, "=", 1)
                        if len(var) > 24:
                            sys.stderr.write(\
                                "-D parameter too long (24 chars max): %s" % (var))
                            return None, None
                        if len(varval) > 255:
                            sys.stderr.write(\
                                "-D value too long (255 chars max): %s=%s" %
                                (var, varval))
                            return None, None
                        details[var] = varval
                    except:
                        sys.stderr.write("Error parsing -D variable '%s'\n" %
                                         (value))
                        return None, None
                elif flag == "--removepassed":
                    details['OPTION_REMOVE_PASSED'] = "yes"
                elif flag == "--pq":
                    details['OPTION_PATCHQUEUE'] = value
                elif flag == "--pqpatch":
                    details['OPTION_PQ_PATCH'] = value
                elif flag == "--skip":
                    details['SKIP_%s' % (value)] = "yes"
                elif flag == "--skipgroup":
                    details['SKIPG_%s' % (value)] = "yes"
                elif flag == "--skiptype":
                    details['SKIPT_%s' % (value)] = "yes"
                elif flag == "--run":
                    details['RUN_%s' % (value)] = "yes"
                elif flag == "--rungroup":
                    details['RUNG_%s' % (value)] = "yes"
                elif flag == "--priority":
                    details['PRIORITY'] = value
                elif flag == "--pause-on-fail":
                    details['POF_%s' % (value)] = "yes"
                elif flag == "--pause-on-pass":
                    details['POP_%s' % (value)] = "yes"
                elif flag == "--hvarch":
                    details['HVARCH'] = value
                elif flag == "--no-finally":
                    details['NOFINALLY'] = "yes"
                elif flag == "--number":
                    details['MACHINES_REQUIRED'] = value
                elif flag == "--inputs":
                    details['INPUTDIR'] = value
                elif flag == "--flags":
                    details['FLAGS'] = value
                elif flag == "--guard":
                    details['GUARD'] = value
                elif flag == "--xenrtpqname":
                    details['XENRT_PQ_NAME'] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None, None
        except getopt.GetoptError, e:
            sys.stderr.write("Unknown argument: %s\n" % (str(e)))
            return None, None

        if details.has_key('USER_BUILD_OPTIONS') and \
               details['USER_BUILD_OPTIONS'] == "supervisor_mode_kernel=y":
            if not details.has_key('TARGET'):
                details['TARGET'] = "dom0"
            if not details.has_key('OPTION_CLEAR_BUILDOPTS'):
                details['OPTION_CLEAR_BUILDOPTS'] = "yes"

        # For vendor kernel testing set a default repo
        if details.has_key('OPTION_ONLY_DOMU') and \
               details['OPTION_ONLY_DOMU'] == "yes":
            if not details.has_key('SECONDARY_REPO_VERSION'):
                details['SECONDARY_REPO_VERSION'] = "xen-3.0-testing"

        # And not let OPTION_ONLY_DOMU through otherwise run-all will override
        if details.has_key('OPTION_ONLY_DOMU'):
            del details['OPTION_ONLY_DOMU']

        return details, secondary

    job_usage = """
        [ --inputs <directory> ]    directory containing product
        [ -o <architecture> ]       x86-32 (default), x86-32p or x86-64
        [ -v <version> ]            xen-unstable (default), linux, etc.
        [ -r <revision> ]           as datestamp of changeset hash (default is tip)
        [ -m <machine> ]            optional specification of required machine
        [ -R <repository URL> ]     path, ssh or http. (default is local cache)
        [ -n <sequence> ]           test sequence (default is full run)
        [ -t <target> ]             sequence target (default 'all')
        [ -F <flags> ]              miscellaneous for machine selection, e.g. 4GB
        [ -P ]                      enable publishing of results
        [ -d ]                      debug command (show config info, no run)
        [ --res <string> ]          resource requirements
        [ --pool <poolname> ]       the machine pool to use
        [ --number <n> ]            number of machines to acquire (default 1)
        [ --arch <guest>:<arch> ]   x86-32, x86-32p or x86-64
        [ --hvarch <arch> ]         Hypervisor arch (v2 jobs only)
        [ --rpm ]                   test community RPMs
        [ --optrpm ]                test Optimizer RPMs
        [ --rpmpath <path> ]        path to RPMs for dom0/general use
        [ --guestrpms <path> ]      path to RPMs to use for guests
        [ --tarball <URL> ]         use a dist tarball from the specified URL
        [ --tarball <guest>:<URL> ] use a dist tarball from the specified URL
        [ --distro <distro> ]       the Linux distribution to use
        [ --distro <guest>:<distro>[+] ] the Linux distribution to use
        [ --nfs ]                   use NFS root for guests (where supported)
        [ --filevbd ]               use file-backed VBD for guests (local storage)
        [ --filevbdnfs ]            use file-backed VBD for guests (NFS storage)
        [ --qcow ]                  use blktap QCOW storage (if supported)
        [ --gnbd ]                  use GNBD for guest roots
        [ --gnbdclient <machine> ]  be a GNBD server for <machine>
        [ --gnbdserver <machine> ]  use <machine> as GNBD server instead of local
        [ --swap ]                  give swap partitions to guests
        [ --domu ]                  only build guest kernel from this repository,
                                    hypervisor, dom0 kernel and tools come from
                                    xen-3.0-testing
        [ --sep ]                   build -xenU/0 (rather than -xen) kernels
        [ --smpdom0 ]               build and/or boot dom0 on multiple CPUs
        [ --noxenargs ]             clear any default Xen command line arguments
        [ --nodom0args ]            clear any default dom0 command line arguments
        [ --xenargs "<args>" ]      additional arguments for the Xen command line
        [ --dom0args "<args>" ]     additional arguments for the dom0 command line
        [ --debug ]                 perform a debug build (if applicable)
        [ --verbose ]               perform a verbose build (if applicable)
        [ --xenbuild "<opts>" ]     extra build options for the Xen "make world"
        [ --ring0 ]                 build dom0 to run in ring0 (no domUs allowed)
        [ --carboncd "<iso>" ]      path to Carbon installer ISO image
        [ --perftag "<string>" ]    add a performance tag for graph grouping
        [ --email <address> ]       email a summary of results to this address
        [ --hold <minutes> ]        hold a machine after job completes
        [ --holdfail <minutes> ]    hold a machine after job fails
        [ --sepkern <URL> ]         use the kernel from this kernel-only repo
        [ --sepkrev <revision> ]    the revision for the above (default is tip)
        [ --xgtnfs <NFS URL> ]      NFS path for XGT imports
        [ --xgt <xgt file/url> ]    Add an extra XGT to a Carbon installation
        [ -D <variable>=<value> ]   set a general variable
        [ --removepassed ]          remove the job from the joblist if it passes
        [ --pw <password> ]         root password for existing guests
        [ --guestaddr <ipaddr> ]    guest IP address for existing guests
        [ --skip <test> ]           skip test <test> (all phases)
        [ --skipgroup <group> ]     skip group <group>
        [ --skiptype <type> ]       skip test type <type>
        [ --run <test> ]            do not skip test <test> (all phases)
        [ --rungroup <group> ]      do not skip group <group>
        [ --priority <n> ]          run tests up to and including P<n>
        [ --pause-on-fail <test> ]  ask for user intervention for <test> or "ALL"
        [ --pause-on-pass <test> ]  ask for user intervention for <test> or "ALL"
        [ --no-finally ]            no run run any "finally" actions
        [ --customsequence <file> ] use a customised sequence file       
        [ --perf-data <file> ]      upload performance limits data
        [ --perf-regress <file> ]   upload performance regression data
        [ --testcasefiles <files> ] upload extra testcases
        [ --customupdates <files> ] upload customized host installation updates (rpm/tarball)
        [ --guard <guard> ]         patchqueue guard to apply
        [ --xenrtpqname <pqname> ]  patchqueue repository, default "xenrt.pq.hg" (use with --guard)
        """
        
class XenRTStatus(XenRTCommand):

    name = "status"
    summary = "Get the status of a submitted job. Any follow-up arguments" \
            " are considered variable names that we wish status to return.\n" \
            "(Analogous to piping xenrt status through grep.)"
    mandatory = "<jobid> [VarName1] [VarName#] [...]"
    group = "Job"
    NEW=True

    def printVar(self, var):
        return not self.printVars or var in self.printVars

    def render(self, args):
        results = self.xenrt.get_job(int(args[0]))
        # Print CHECK first (XRT-303)
        self.printVars = args[1:]
        if results['result'] and self.printVar("CHECK"):
            self.printout("CHECK='%s'\n" % (results["result"]))
        if self.printVar("JOBSTATUS"):
            self.printout("JOBSTATUS='%s'\n" % (results["status"]))
        if self.printVar("USERID"):
            self.printout("USERID='%s'\n" % (results["user"]))
        if self.printVar("JOBID"):
            self.printout("JOBID='%s'\n" % (results["id"]))
        if self.printVar("PAUSED"):
            self.printout("PAUSED='%s'\n" % self.boolToYN("paused" in [x['result'] for x in results['results'].values()]))
        for key in results['params'].keys():
            if key != "CHECK" and self.printVar(key):
                self.printout("%s='%s'\n" % (key, results['params'][key]))
        return 0

class XenRTUtilisation(XenRTCommand):

    name = "utilisation"
    summary = "Get the utilisation of a pool for a specified period"
    usage = """
    -d <days>|<from>,<to>   Summary period as either a number of days or a
                            comma separated pair of UNIX timestamps
                            specifying start and end times. Default is 7 days.
    -p <pool>[,<pool>...]   List of pools to summarise. Default is all.
    -v                      Verbose - show per-machine details as well.
    """

    def run(self, args):
        details = {'action': 'utilisation'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        period = "7"
        self.verbose = False
        try:
            optlist, optx = getopt.getopt(args, 'd:p:v')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-v":
                    details["verbose"] = "yes"
                    self.verbose = True
                elif flag == "-d":
                    period = value
                elif flag == "-p":
                    details['pools'] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        details["period"] = period
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            ll = string.split(string.strip(line), ",")
            reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):        
        for ll in results:
            if ll[0] == "ALL":
                self.printout("Total (%s jobs, %s, %s)\n\n" %
                              (ll[4], ll[3], ll[2]))
                if not self.verbose:
                    self.printout("%-12s %12s %-18s %9s\n" % \
                                  ("Pool", "Utilisation", "Time Spent", "Job Count"))
                    self.printout("------------------------------------------" +
                                  "------------\n")
            elif ll[0] == "POOL" and self.verbose:
                self.printout("\n%s (%s jobs, %s, %s)\n" %
                              (ll[1], ll[4], ll[3], ll[2]))
                self.printout("%-12s %12s %-18s %9s\n" % \
                              ("Machine", "Utilisation", "Time Spent", "Job Count"))
                self.printout("------------------------------------------" +
                              "------------\n")
            elif ll[0] == "MACHINE" or (ll[0] == "POOL" and not self.verbose):
                self.printout("%-12s %12s %-18s %9s\n" % \
                              (ll[1], ll[2], ll[3], ll[4]))
                
class XenRTMachine(XenRTCommand):

    name = "machine"
    summary = "Get data for the specified machine"
    mandatory = "<machine>"
    group = "Machine"
    NEW=True

    def render(self, args):
        results = self.xenrt.get_machine(args[0])
        self.printout("STATUS='%s'\n" % results['rawstatus'])
        for i in ('jobid', 'leasereason', 'pool', 'leaseuser', 'cluster', 'site'):
            if results[i]:
                self.printout("%s='%s'\n" % (i.upper(), results[i]))
        for i in ('leaseto', 'leasefrom'):
            if results[i]:
                t = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(results[i]))
                self.printout("%s='%s'\n" % (i.upper(), t))
        if results['leaseuser']:
            self.printout("COMMENT='%s'\n" % results['leaseuser'])
        if results['resources']:
            self.printout("RESOURCES='%s'\n" % "/".join(["=".join(x) for x in results['resources'].items()]))
        for key in results['params'].keys():
            self.printout("%s='%s'\n" % (key, results['params'][key]))
        return 0

class XenRTShowLog(XenRTCommand):

    name = "showlog"
    summary = "Show the test progress log"
    mandatory = "<jobid>"
    usage = """
    [ -v ]      verbose    
    [ -w ]      wide format
    [ -t ]      show testcase durations
    """
    group = "Job"
    NEW = True

    def render(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        verbose=False
        wide=False
        times=False
        try:
            optlist, optx = getopt.getopt(args[1:], 'vwt')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-v":
                    verbose = True
                elif flag == "-w":
                    wide = True
                elif flag == "-t":
                    times = True
                else:
                    raise Exception("Unknown argument '%s'\n" % (flag))
        except getopt.GetoptError:
            raise Exception("Unknown argument\n")

        
        job = self.xenrt.get_job(string.atoi(args[0]), logitems=(verbose or times))

        pref = ""
        if wide:
            pref = job['params'].get("OPTIONS", "")
        if pref:
            pref += " "

        for r in sorted(job['results'].keys(), key=int):
            timestr = ""
            if times:
                start = [x['ts'] for x in job['results'][r]['log'] if x['log'] == "started"]
                finish = [x['ts'] for x in job['results'][r]['log'] if x['log'] in("pass", "fail", "error", "partial")]
                if start and finish:
                    timestr = " (Duration %6us)" % (finish[0] - start[0])
            self.printout("%s%-10s %-12s %-10s%s\n" % (
                    pref,
                    job['results'][r]['phase'],
                    job['results'][r]['test'],
                    job['results'][r]['result'],
                    timestr))
            if verbose:
                for l in job['results'][r]['log']:
                    dt = datetime.datetime.utcfromtimestamp(l['ts']).isoformat(" ")
                    self.printout("...[%-19s] %-10s %s\n" % (dt, l['type'], l['log']))
            

class XenRTMList2(XenRTCommand):

    name = "mlist2"
    summary = "Get a list of machines"
    usage = """
    [-s] <site>      Filter on site
    [-c] <cluster>   Filter on cluster
    [-o] <pool>      Filter on pool
    [-R] <resources> Filter on a resource string (e.g. "memory>3G/disks=1")
    [-P] <props>     Filter on machines matching the props string
    [-f] <flags>     Filter on machine flags
    [-b] <user>      Filter on machines borrowed by user
    [-n]             Filter on machines that are not borrowed
    [-m]             Filter on machines borrowed by me
    [-a]             Filter on machines borrowed by anyone
    [-r]             Show machine resources
    [-d]             Show machine descriptions
    [-p]             Show machine properties
    [-v]             Show pseudohosts
    """
    NEW = True

    def render(self, args):
        self.controller = False
        details = {}
        quiet = False
        show=None
        filterLeased = None
        filterBroken = False
        controllerFormat = False
        try:
            optlist, optx = getopt.getopt(args, 's:c:o:qrCdR:pP:vf:mb:na', "broken")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-s":
                    details["site"] = [value]
                elif flag == "-C":
                    controllerFormat = True
                    details["pseudohosts"] = True
                elif flag == "-c":
                    details["cluster"] = [value]
                elif flag == "-o":
                    details["pool"] = [value]
                elif flag == "-q":
                    quiet = True
                elif flag == "-r":
                    show = "Resources"
                elif flag == "-d":
                    show = "Description"
                elif flag == "-R":
                    details["resource"] = value.split("/")
                elif flag == "-p":
                    show = "Properties"
                elif flag == "-P":
                    if not "flag" in details:
                        details['flag'] = []
                    details["flag"].extend(value.split(","))
                elif flag == "-f":
                    if not "flag" in details:
                        details['flag'] = []
                    details["flag"].extend(value.split(","))
                elif flag == "-b":
                    details["user"] = [value]
                elif flag == "-m":
                    details["user"] = ["${user}"]
                elif flag == "-n":
                    filterLeased = False
                elif flag == "-a":
                    filterLeased = True
                elif flag == "-v":
                    details["pseudohosts"] = True
                elif flag == "--broken":
                    filterBroken = True
                else:
                    raise Exception("Unknown argument '%s'\n" % (flag))
        except getopt.GetoptError:
            raise Exception("Unknown argument\n")
        machines = self.xenrt.get_machines(**details)

        jobids = [x['jobid'] for x in machines.values() if x['status'] == "running"]

        jobs = self.xenrt.get_jobs(jobid=jobids, params=True)

        if show:
            chead = show
        else:
            chead = "Comment/Leased to"

        fmt = "%-15s %-12s %-8s %-9s %-8s %s\n"
        if not quiet and not controllerFormat:
            self.printout(fmt % ("Machine", "Site", "Cluster", "Status", "Pool", chead))
            self.printout("============================================================================\n")
            
        for m in sorted(machines.keys()):
            if filterBroken and not machines[m]['broken']:
                continue
            if filterLeased and not machines[m]['leaseuser']:
                continue
            if filterLeased == False and machines[m]['leaseuser']:
                continue
            if controllerFormat:
                self.printout("%s,%s,%s" % (m,machines[m]['rawstatus'],str(machines[m]['jobid']) if machines[m]['jobid'] else ""))
            else:
                status = machines[m]['rawstatus']
                if status == "scheduled":
                    status = "%d (S)" % machines[m]['jobid']
                elif status == "running":
                    status = "%d" % machines[m]['jobid']
                elif status == "slaved":
                    status = "(%d)" % machines[m]['jobid']
                if show == "Resources":
                    comment = "/".join(machines[m]['resources'])
                elif show == "Properties":
                    comment = ",".join(machines[m]['flags'])
                elif show == "Description":
                    comment = machines[m]['description'] or ""
                else:
                    if machines[m]['broken']:
                        comment = "Broken"
                        brokenInfo = machines[m]['params'].get("BROKEN_INFO")
                        brokenTicket = machines[m]['params'].get("BROKEN_TICKET")
                        if brokenInfo or brokenTicket:
                            comment += " -"
                        if brokenInfo and brokenTicket and brokenTicket in brokenInfo:
                            brokenTicket = None
                        if brokenTicket:
                            comment += " " + brokenTicket
                        if brokenInfo:
                            comment += " " + brokenInfo
                    elif machines[m]['leaseuser']:
                        dt = datetime.datetime.utcfromtimestamp(machines[m]['leaseto']).isoformat(" ")
                        if machines[m]['leasereason']:
                            userstr = "%s - %s" % (machines[m]['leaseuser'], machines[m]['leasereason'])
                        else:
                            userstr = machines[m]['leaseuser']
                        comment = "%s (%s)" % (dt, userstr)
                    elif machines[m]['status'] == "running":
                        job = jobs[str(machines[m]['jobid'])]
                        comment = "%s - %s" % (job["description"], job['user'])
                    else:
                        comment = ""
                
                self.printout(fmt % (m, machines[m]['site'], machines[m]['cluster'], status, machines[m]['pool'], comment))
                    

class XenRTMList(XenRTMList2):
    # Alias for xenrt mlist2
    name = "mlist"

class XenRTList(XenRTCommand):

    name = "list"
    summary = "Show status of new or running jobs"
    usage = """

    The optional parameters specify search filters.

    [ -m ]                   show only my jobs
    [ -U <user> ]            show only <user>'s jobs
    [ -n ]                   show only new jobs
    [ -r ]                   show only running jobs
    [ -s ]                   show testrun suite IDs if known
    [ -S <suiterun id> ]     show only jobs from this suite run
    [ -D <description> ]     show only jobs matching the given JOBDESC
    """
    group = "Scheduler"

    def run(self, args):
        self.showsr = False
        details = {'action': 'list',
                   'fields': 'MACHINE,VERSION,REVISION,DEPS,JOBDESC,USERID,TESTRUN_SR'}
        self.quiet = False
        try:
            optlist, optx = getopt.getopt(args, 'mU:nrsS:qD:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-U":
                    details["filter_USERID"] = value
                elif flag == "-S":
                    details["filter_TESTRUN_SR"] = value
                elif flag == "-m":
                    details["filter_USERID"] = pwd.getpwuid(os.getuid())[0]
                elif flag == "-n":
                    details["filter_JOBSTATUS"] = "new"
                elif flag == "-r":
                    details["filter_JOBSTATUS"] = "running"
                elif flag == "-s":
                    self.showsr = True
                elif flag == "-q":
                    self.quiet = True
                elif flag == "-D":
                    details["filter_JOBDESC"] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            else:
                if line[-1] == "\n":
                    ll = string.split(line[:-1], "\t")
                else:
                    ll = string.split(line, "\t")
                while len(ll) < 7:
                    ll.append("")
                reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):
        fieldwidths = [6, 8, 12, 9, 13, 18, 7]
        fmt = string.join(map(lambda x:"%%-%us" % x, fieldwidths))
        fmt = fmt + "\n"
        if not self.quiet:
            self.printout(fmt % ("ID",
                                 "Status",
                                 "Host(s)",
                                 "Version",
                                 "Revision",
                                 "Desc",
                                 "User"))
            self.printout("--------------------------------------------------"
                          "-----------------------------\n")
        for ll in results:
            if ll[6] != "":
                ll[5] = ll[6]
            ll[6] = ll[7]
            if ll[8] and self.showsr:
                ll[5] = ll[5].split("&")[0]
                ll[5] = "SR%s " % (ll[8]) + ll[5]
            for i in range(len(fieldwidths)):
                if len(ll[i]) > fieldwidths[i]:
                    ll[i] = ll[i][0:fieldwidths[i]]
            self.printout(fmt %
                          (ll[0], ll[1], ll[2], ll[3], ll[4], ll[5], ll[6]))
                          
        
class XenRTComplete(XenRTCommand):

    name = "complete"
    summary = "Mark a job as complete (server call only)"
    mandatory = "<jobid>"
    group = "Job"

    def run(self, args):
        details = {'action': 'complete'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTEmail(XenRTCommand):

    name = "email"
    summary = "Send job summary email (if necessary) (server call only)"
    mandatory = "<jobid>"
    hide = True

    def run(self, args):
        details = {'action': 'email'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTLogServer(XenRTCommand):
    name = "logserver"
    summary = "Get URL to default log server (server call only)"
    mandatory = ""
    hide = True

    def run(self, args, preconf=None):
        details = {'action': 'getlogserver'}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data.strip()
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%s\n" % results)
        return 0

class XenRTSetResult(XenRTCommand):

    name = "setresult"
    summary = "Set test result (server call only)"
    mandatory = "<jobid> <phase> <test> <result>"
    hide = True

    def run(self, args):
        details = {'action': 'setresult'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 4:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        details["result"] = args[3]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTEvent(XenRTCommand):

    name = "event"
    summary = "Record an event"
    mandatory = "<type> <subject> '<data>'"
    hide = True
    
    def run(self, args):
        details = {'action': 'event'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        details["etype"] = args[0]
        details["subject"] = args[1]
        details["edata"] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply
    
class XenRTJobGroup(XenRTCommand):

    name = "jobgroup"
    summary = "Reset job group or add a job to a group"
    mandatory = "<group> {-R | -a <jobid>}"
    usage = """
    [ -d '<description>' ]   short description of this job
    """
    group = "Job group"

    def run(self, args):
        details = {'action': 'jobgroup'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details['gid'] = args[0]
        command = None
        if len(args) > 1:
            optlist, optx = getopt.getopt(args[1:], 'Ra:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-R":
                    command = "reset"
                elif flag == "-a":
                    command = "add"
                    details['jobid'] = value
                elif flag == "-d":
                    details['desc'] = value
        if not command:
            sys.stderr.write("Invalid usage\n")
            return None
        details['command'] = command
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTLogData(XenRTCommand):

    name = "logdata"
    summary = "Set test data fields (server call only)"
    mandatory = "<jobid> <phase> <test> <key> <value>"
    hide = True
    
    def run(self, args):
        details = {'action': 'logdata'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 5:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        details["key"] = args[3]
        details["value"] = args[4]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTRemove(XenRTCommand):

    name = "remove"
    summary = "Remove a job from the system"
    mandatory = "<jobid>"
    group = "Job"

    def run(self, args):
        details = {'action': 'remove'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSubmit(XenRTCommand):

    name = "submit"
    summary = "Submit a XenRT run to the work queue"
    usage = XenRTCommand.job_usage
    group = "Job"
    
    def run(self, args, preconf=None):
        defaults = {
            'OPTIONS': 'x86-32',
            'XENRT_PQ_NAME': 'xenrt.pq.hg'
            }
            
        details, secondary = self.parse_options(args)
        if preconf:
            preconf.update(details)
            details = preconf
        defaults.update(details)
        details = defaults
        if not details:
            return None
        for key in details.keys():
            if len(details[key]) == 0:
                del details[key]
        if not details.has_key("USERID"):
            details["USERID"] = pwd.getpwuid(os.getuid())[0]

        if details.has_key("INPUTDIR") and "latest" in details["INPUTDIR"]:
            
            # if you use a build like this: /usr/groups/xen/carbon/trunk/latest/
            # then it will get cached on the controller using this name as the key.
            # The cached build will then not get updated when the symlink target 
            # build changes.
            
            sys.stderr.write("You must specify a build with a build number in it.\n")
            return None

        if details.has_key("DEBUGCMD"):
            del details['DEBUGCMD']
            com.commands['status'].render(None, details)
            return 0
                    
        details['action'] = 'submit'

        u = urlopen_with_retry(self.getServerURL(), urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        while 1:
            line = u.readline()
            if not line:
                break
            ll = string.split(line, ' ', 2)
            if len(ll) > 0:
                if ll[0] == 'OK':
                    if len(ll) < 2:
                        sys.stderr.write("Server returned success but " +
                                         "without a job ID\n")
                    else:
                        reply = string.atoi(ll[1])
                        # Do we have a patch to upload?
                        if secondary.has_key("patch"):
                            patch = secondary["patch"]
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'patch' }
                            if not self.upload(detp, patch, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of patch %s "
                                                 "failed.\n" % (reply, patch))
                                reply = None
                        if secondary.has_key("seqfiles"):
                            for sf in string.split(secondary['seqfiles'], ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(sf) }
                                if not self.upload(detp, sf, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of sequence file %s "
                                                     "failed.\n" % (reply, sf))
                                    reply = None
                        if secondary.has_key("testcasefiles"):
                            for tf in string.split(secondary['testcasefiles'],
                                                   ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(tf) }
                                if not self.upload(detp, tf, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of test case file "
                                                     "%s failed.\n" % (reply, 
                                                                       tf))
                                    reply = None
                        if secondary.has_key("customupdates"):
                            for cu in string.split(secondary['customupdates'],
                                                   ","):
                                detp = {
                                    'action': 'upload',
                                    'id': ll[1],
                                    'prefix': os.path.basename(cu) }
                                if not self.upload(detp, cu, proxies=self.proxies):
                                    sys.stderr.write("Submitted job %u but "
                                                     "upload of customized update "
                                                     "%s failed.\n" % (reply, 
                                                                       cu))
                                    reply = None
                        if secondary.has_key("perfdata"):
                            sf = secondary['perfdata']
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'perfdata' }
                            if not self.upload(detp, sf, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of perf data file %s "
                                                 "failed.\n" % (reply, sf))
                                reply = None
                        if secondary.has_key("perfregress"):
                            sf = secondary['perfregress']
                            detp = {
                                'action': 'upload',
                                'id': ll[1],
                                'prefix': 'perfregress' }
                            if not self.upload(detp, sf, proxies=self.proxies):
                                sys.stderr.write("Submitted job %u but "
                                                 "upload of perf regress file "
                                                 "%s failed.\n" % (reply, sf))
                                reply = None

                elif ll[0] == 'ERROR':
                    if len(ll) < 2:
                        sys.stderr.write("Server returned error but " +
                                         "without an explanation\n")
                    else:
                        sys.stderr.write("ERROR: %s\n" % (ll[1]))
                        reply = None
                        
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%d\n" % (results))
        return 0

class XenRTRun(XenRTCommand):

    name = "run"
    summary = "Run a XenRT test sequence directly"
    usage = XenRTCommand.job_usage
    group = "Miscellaneous"
    
    def run(self, args):
        global _sharedir
        details, secondary = self.parse_options(args)
        if not details:
            return None
        for key in details:
            if len(details[key]) == 0:
                del details[key]
        if not details.has_key("USERID"):
            details["USERID"] = pwd.getpwuid(os.getuid())[0]

        resdir = tempfile.mkdtemp(prefix="xenrtrun.", dir=".")
        print "Output directory: %s" % (resdir)

        optparse = []
        optparse.append(("OPTIONS", "--arch", True))
        optparse.append(("REPO", "--repo", True))
        optparse.append(("REVISION", "--revision", True))
        optparse.append(("OPTION_PATCHQUEUE", "--pq", True))
        optparse.append(("OPTION_PQ_PATCH", "--pqpatch", True))
        optparse.append(("OPTION_PATCHQUEUE_REV", "--pqrev", True))
        optparse.append(("HVARCH", "--hvarch", True))
        optparse.append(("HARNESS_TRACE", "--trace", False))
        optparse.append(("NOFINALLY", "--no-finally", False))
        optparsevars = []
        for opt in optparse:
            var, flag, hasarg = opt
            optparsevars.append(var)

        cmd = ["%s/exec/main.py" % (_sharedir)]
        cmd.append("-V")
        cmd.append("-C")
        cmd.append(resdir)
        cmd.append("--redir")
        cmd.append("--output-to-logdir")
        cmd.append("--matrix")
        cmd.append("matrix.csv")
        if not string.strip(os.popen("nisdomainname").read()) == "hq.xensource.com":
            cmd.append("--remote")
        if details.has_key("CLI_ARGS_PASSTHROUGH"):
            for i in string.split(details["CLI_ARGS_PASSTHROUGH"]):
                cmd.append(i)
        if details.has_key("MACHINE"):
            hosts = string.split(details["MACHINE"], ",")
            cmd.append("--host")
            cmd.append("%s" % (string.join(hosts, ",")))
        if details.has_key("DEPS"):
            cmd.append("--sequence")
            cmd.append("%s" % (details["DEPS"]))
        if details.has_key("TESTCASEFILES"):
            cmd.append("--testcasefiles")
            cmd.append("%s" % (details["TESTCASEFILES"]))
        for optpair in optparse:
            var, flag, hasarg = optpair
            if details.has_key(var):
                cmd.append(flag)
                if hasarg:
                    cmd.append(details[var])
        for k in details.keys():
            if not k in ("DEPS", "DEBUGCMD", "SCHEDULEDON", "SCHEDULEDON2", "SCHEDULEDON3", "TESTCASEFILES", "CLI_ARGS_PASSTHROUGH") and not k in optparsevars:
                cmd.append("-D")
                cmd.append("%s=%s" % (k, details[k]))

        if details.has_key('DEBUGCMD'):
            print "To Run: %s" % (string.join(cmd))
        else:
            print "Running: %s" % (string.join(cmd))        
            pid = os.spawnv(os.P_NOWAIT, cmd[0], cmd)

class XenRTRerun(XenRTSubmit):

    name = "rerun"
    summary = "Rerun a previously existed job"
    mandatory = "<jobid> [faithful|testrun|custom]"
    usage = """
Among the three rerun modes, 'custom' mode is the default choice if none is
present. After the mandatory arguments above, any 'xenrt submit' option can
be used to shadow the original setttings in any mode. Note that it might not
make sense to overwrite settings in the 'faithful' and 'testrun' mode, but we
preserve such possibilities.
    """

    faithful_ex = [ "XMLRPC", "HARNESS_PID", "JOBID", "RUNDIR", "XENRT_VERSION",
                    "JOB_SUBMITTED", "STARTED", "JOBSTATUS", "SCHEDULEDON.*",
                    "CHECK", "RETURN", "UPLOADED", "FINISHED", "PASSRATES",
                    "REGRESSION", "REMOVED", "PREPARE_FAILED" ]
    testrun_ex = [ "MACHINE", "PXE_BIOS_BOOT_RETRY" ]
    custom_ex = [ "JOBGROUP", "TESTRUN.*", "JIRA.*", "USERID",
                  "EMAIL.*", ".*EMAIL_TO", "AUTO_BUG.*" ]

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        jobid = args[0]
        options = com.commands['status'].dispatch([jobid], raw=1)
        if options is None: return None
        if len(args) < 2:
            mode = 'custom'
            noptions = []
        elif args[1].startswith('-'):
            mode = 'custom'
            noptions = args[1:]
        elif args[1] in ['faithful', 'testrun', 'custom']:
            mode = args[1]
            noptions = args[2:]
        else:
            sys.stderr.write("Invalid rerun mode\n")
            return None
        # Exclude patterns
        excludes = []
        # Include options dict
        includes = {}
        if mode == 'faithful':
            excludes += self.faithful_ex
        if mode == 'testrun':
            excludes += self.faithful_ex + self.testrun_ex
            runlogs = com.commands['showlog'].dispatch([jobid], raw=1)
            runlogs = runlogs.strip().splitlines()
            runlogs = filter(lambda l: len(l) >= 2, map(lambda l: l.split(), runlogs))
            runlogs = dict(map(lambda l: (l[1], len(l)>=3 and l[2] or ''), runlogs))
            for tc in runlogs:
                if not runlogs[tc] or re.match("error|fail|block", runlogs[tc]):
                    includes['RUN_%s' % tc] = 'yes'
        if mode == 'custom':
            excludes += self.faithful_ex + self.testrun_ex + self.custom_ex
        excludes = map(lambda s: '^' + s + '$', excludes)
        options=dict(filter(lambda (k,v): not (re.match("|".join(excludes), k)), options.iteritems()))
        options.update(includes)
        options['ORIGINAL_JOBID'] = jobid
        result = XenRTSubmit.run(self, noptions, preconf=options)
        return result

class XenRTUpdate(XenRTCommand):

    name = "update"
    summary = "set/update a field in a job description"
    mandatory = "<jobid> <field> <value>"
    group = "Job"
    
    def run(self, args):
        details = {'action': 'update'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMBroken(XenRTCommand):
    name = "mbroken"
    summary = "Mark a machine as broken"
    mandatory = "<machine> <reason>"
    group = "Machine"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        reason = " ".join(args[1:])

        details = {'action': 'machine', 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            data = self.parse_job(data)
        u.close()
        pool = data['POOL']
        pool = pool.rstrip("x")
        pool = "%sx" % pool

        details = {'action': 'mupdate', 'POOL': pool, 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()
        
        m = re.search("([A-Z]+-\d+)", reason)
        if m:
            details = {'action': 'mupdate', 'BROKEN_TICKET': m.group(1), 'machine':machine}
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
                return None
            u.close()

        details = {'action': 'mupdate', 'BROKEN_INFO': reason, 'machine': machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMFixed(XenRTCommand):
    name = "mfixed"
    summary = "Mark a machine as fixed"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]

        details = {'action': 'machine', 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            data = self.parse_job(data)
        u.close()
        pool = data['POOL']
        pool = pool.rstrip("x")

        details = {'action': 'mupdate', 'POOL': pool, 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()
        
        details = {'action': 'mupdate', 'BROKEN_TICKET': "", 'machine':machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        u.close()

        details = {'action': 'mupdate', 'BROKEN_INFO': "", 'machine': machine}
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMUpdate(XenRTCommand):

    name = "mupdate"
    summary = "set/update a field of machine data"
    mandatory = "<machine> <field> <value>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mupdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMRes(XenRTMUpdate):
    name = "mres"
    summary = "set/update a resource on a machine"
    mandatory = "<machine> <resource>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'machine'}
        if len(args) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        if len(args[1].split("=", 1)) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
            return None
        else:
            reply = self.parse_job(data)
        u.close()
        try:
            res = reply["RESOURCES"]
        except:
            res = ""
        resitems = res.split("/")
        found = False
        for i in range(len(resitems)):
            if resitems[i].split("=")[0] == args[1].split("=")[0]:
                resitems[i] = args[1]
                found = True
        if not found:
            resitems.append(args[1])
        XenRTMUpdate.run(self, [args[0], "RESOURCES", "/".join(resitems)])

class XenRTMStatus(XenRTCommand):

    name = "mstatus"
    summary = "update the status field of machine data"
    mandatory = "<machine> <status>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mstatus'}
        if len(args) != 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        details["status"] = args[1]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTBorrow(XenRTCommand):

    name = "borrow"
    summary = "Borrow a machine"
    mandatory = "<machine>"
    usage = """
    -h <hours>     Number of hours to borrow for (default is 24)
    -d <days>      Number of days to borrow for (default is 1)
    -r <reason>    Reason for borrowing machine
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'borrow'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], 'h:u:d:fr:', "force")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-h':
                    details["hours"] = value
                elif flag == '-d':
                    details["hours"] = "%d" % (int(value) * 24)
                elif flag == "-r":
                    details["reason"] = value
                elif flag == '-u':
                    details['USERID'] = value
                elif flag == "-f":
                    details["forever"] = "yes"
                elif flag == "--force":
                    details["force"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTReturn(XenRTCommand):

    name = "return"
    summary = "Return a borrowed machine"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'return'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], '', "force")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "--force":
                    details["force"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTProp(XenRTCommand):

    name = "prop"
    summary = "Add/remove dynamic machine properties"
    mandatory = "<machine> add|del <property>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mupdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        if args[1] == "add":
            details["+PROPS"] = args[2]
        elif args[1] == "del" or args[1] == "rem":
            details["-PROPS"] = args[2]
        else:
            sys.stderr.write("Invalid usage: need \"add\" or \"del\".\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSFlag(XenRTCommand):

    name = "sflag"
    summary = "Add/remove site flags"
    mandatory = "<site> add|del <property>"
    group = "Site"

    def run(self, args):
        details = {'action': 'supdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        if args[1] == "add":
            details["+FLAGS"] = args[2]
        elif args[1] == "del" or args[1] == "rem":
            details["-FLAGS"] = args[2]
        else:
            sys.stderr.write("Invalid usage: need \"add\" or \"del\".\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTPool(XenRTCommand):

    name = "pool"
    summary = "Set machine pool"
    mandatory = "<machine> [<poolname>]"
    usage = """
The first usage is for setting the pool a machine is in. A blank <poolname>
moves the machine to the "DEFAULT" pool.
    """
    group = "Machine"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")            
            return None

        # Machine update
        details = {'action': 'mupdate',
                   'SUBPOOL': 'DEFAULT'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        machine = args[0]
        details["machine"] = machine
        if len(args) > 1:
            details["SUBPOOL"] = args[1]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

    def render(self, args, results):
        if len(args) > 0 and args[0] == "--list":
            for r in results:
                self.printout("%s\n" % (r[0]))
        return 0

class XenRTMakeTickets(XenRTCommand):

    name = "maketickets"
    summary = "Make empty Jira tickets for a test run"
    mandatory = "[--findold] [--branch=<branch>] <suite> <version> [<priority>]"
    group = "Miscellaneous"

    def run(self, args):
        details = {'action': 'maketickets'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 2 or len(args) > 4:
            sys.stderr.write("Invalid usage\n")
            return None
        i = 0
        for arg in args:
            if arg.startswith("--"):
                if arg == "--findold":
                    details["findold"] = "yes"
                    continue
                m = re.match("--branch=(.*)", arg)
                if m:
                    details["branch"] = m.group(1)
                    continue
            elif i == 0:
                suite = arg
            elif i == 1:
                version = arg
            elif i == 2:
                details["priority"] = arg
            i += 1    
        details["suite"] = suite
        details["version"] = version
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTSuiteStatus(XenRTCommand):

    name = "suitestatus"
    summary = "Returns the status of a suite run"
    mandatory = "<suiterun>"
    usage = """
    -r             Report details of resource usage by the suite
    -m             Used with -r, orders list by machine-hours
    """
    group = "Miscellaneous"

    def run(self, args):
        self.advanced = False
        self.orderbymh = False
        details = {'action': 'suitestatus'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        try:
            optlist, optx = getopt.getopt(args[1:], 'rm')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-r':
                    details["resources"] = "yes"
                    details["summary"] = "no"
                    self.advanced = True
                elif flag == "-m":
                    self.orderbymh = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        suiterun = args[0]
        details["suiterun"] = suiterun
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if self.advanced:
            data = {}
            for line in results.splitlines():
                if "=" in line:
                    ll = line.split("=", 1)
                    data[ll[0]] = ll[1]
            if data.has_key("JOBDESCS"):
                self.printout("%-24s %5s %8s %7s %7s\n" %
                              ("Sequence",
                               "Hours",
                               "Machines",
                               "M-Hours",
                               "Job ID"))
                costs = {}
                jobdescs = data["JOBDESCS"].split(",")
                for jobdesc in jobdescs:
                    if data.has_key("RES_%s" % (jobdesc)):
                        ll = data["RES_%s" % (jobdesc)].split(",")
                        jobid = int(ll[0])
                        if ll[1]:
                            duration = int(ll[1])
                        else:
                            duration = 0
                        machines = int(ll[2])
                        if self.orderbymh:
                            dkey = "%08u%s" % (duration * machines, jobdesc)
                        else:
                            dkey = "%08u%s" % (duration, jobdesc)
                        costs[dkey] = (duration, jobdesc, jobid, machines)
                dkeys = costs.keys()
                dkeys.sort()
                for dkey in dkeys:
                    duration, jobdesc, jobid, machines = costs[dkey]
                    if duration == 0:
                        durtxt = "     "
                        mhtxt = "       "
                    else:
                        durtxt = "%5.1f" % (duration/3600.0)
                        mhtxt = "%7.1f" % (duration/3600.0 * machines)
                    self.printout("%-24s %5s %8u %7s %7u\n" %
                                  (jobdesc, durtxt, machines, mhtxt, jobid))
        else:
            self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTDetailID(XenRTCommand):

    name = "detailid"
    summary = "Get the detailid for a specified jobid, phase and test"
    mandatory = "<jobid> <phase> <test>"
    hide = True

    def run(self, args):
        details = {'action': 'detailid'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) <> 3:
            sys.stderr.write("Invalid usage\n")
            return None
        jobid = args[0]
        details["id"] = jobid
        phase = args[1]
        details["phase"] = phase
        test = args[2]
        details["test"] = test
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        self.printout("%s\n" % (string.strip(results)))
        return 0

class XenRTHelp(XenRTCommand):

    name = "help"
    summary = "Get a summary of commands"
    group = "Miscellaneous"

    def run(self, args):
        cx = {}
        for c in self.commands.getall():
            if not c.hide:
                if not cx.has_key(c.group):
                    cx[c.group] = []
                cx[c.group].append(c)
        first = ["Job", "Suite", "Machine", "Site"]
        last = ["Miscellaneous", "Other"]
        order = []
        order.extend(first)
        for g in cx.keys():
            if not g in first and not g in last:
                order.append(g)
        order.extend(last)
        for g in order:
            self.printout("\n%s commands:\n\n" % (g))
            for c in cx[g]:
                self.printout("  %-10s %s\n" % (c.name, c.summary))
        self.printout("\nRun \"%s <command> --help\" for usage information.\n"
                      % (sys.argv[0]))        
        return 1

class XenRTSubResults(XenRTCommand):

    name = "subresults"
    summary = "Upload a XML subresults file for a job (server call only)"
    mandatory = "<jobid> <phase> <test>"
    usage = """
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'subresults'}
        if len(args) < 3:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["jobid"] = id
        details["phase"] = args[1]
        details["test"] = args[2]
        filename = None
        try:
            optlist, optx = getopt.getopt(args[3:], 'f:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    filename = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        return self.upload(details, filename, proxies=self.proxies, scheduler=True)

class XenRTPerfData(XenRTCommand):

    name = "perfdata"
    summary = "Upload a XML performance data file (server call only)"
    usage = """
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'perfdata'}
        filename = None
        try:
            optlist, optx = getopt.getopt(args, 'f:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    filename = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        return self.upload(details, filename, proxies=self.proxies, scheduler=True)

class XenRTUpload(XenRTCommand):

    name = "upload"
    summary = "Upload a results file for a job (server call only)"
    mandatory = "<jobid>"
    usage = """
    [ -p <phase> -t <test> ]  Phase and test for per-test results file.
    [ -f <filename> ]         Filename to upload (default is STDIN)
    """
    hide = True

    def run(self, args):
        details = {'action': 'upload'}
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id
        filename = None
        try:
            optlist, optx = getopt.getopt(args[1:], 'p:t:f:P:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-p':
                    details["phase"] = value
                if flag == '-t':
                    details["test"] = value
                if flag == '-f':
                    filename = value
                if flag == '-P':
                    details["prefix"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        return self.upload(details, filename, proxies=self.proxies)                

class XenRTDownload(XenRTCommand):

    name = "download"
    summary = "Download a results file for a job"
    mandatory = "<jobid>"
    usage = """
    [ -p prefix ]   Prefix for file to download.
    [ -f filename ] File to write results to (defaults to stdout)
    [ -g phase ]    Optional phase (test also required)
    [ -t test ]     Optional test (phase also required)
    """
    group = "Miscellaneous"

    def run(self, args):
        self.filename = None
        details = {'action': 'download'}
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        id = string.atoi(args[0])
        details["id"] = id        
        usemasterserver=False
        try:
            optlist, optx = getopt.getopt(args[1:], 'op:f:g:t:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-p':
                    details["prefix"] = value
                elif flag == "-f":
                    self.filename = value
                elif flag == "-g":
                    details["phase"] = value
                elif flag == "-t":
                    details["test"] = value
                elif flag == "-o":
                    usemasterserver = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        url = self.getServerURL()

        if usemasterserver:
            params = ["JOB_FILES_SERVER"]
        else:
            params = None
        logserver = self.getLogServer(id, proxies=self.proxies, params=params)
        if logserver:
            url = logserver_url % logserver

        u = urlopen_with_retry(url, urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            if self.filename:
                f = file(self.filename, "w")
                f.write(data)
                f.close()
                reply = 1
            else:
                reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results is None:
            return 1
        if not self.filename:
            self.printout(results)
        return 0

class XenRTSchedule(XenRTCommand):

    name = "schedule"
    summary = "Run the job scheduler to assign jobs to machines"
    usage = """
    -v     Verbose output
    -d     Perform a dry run to see what could be scheduled, do not schedule
    -i     Ignore current allocations when performing a dry run
    -b     Best effort - don't rediect to master if a slave is connected to
    """
    group = "Scheduler"
    
    def run(self, args):
        details = {'action': 'schedule'}
        showstatus = False
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        try:
            optlist, optx = getopt.getopt(args, 'divjb')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-d':
                    details["dryrun"] = "yes"
                elif flag == "-i":
                    details["ignore"] = "yes"
                elif flag == "-v":
                    details["verbose"] = "yes"
                elif flag == "-b":
                    details["besteffort"] = "yes"
                elif flag == "-j":
                    showstatus = True
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details))
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        if showstatus:
            reply += "Schedule complete\n"
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTMDefine(XenRTCommand):

    name = "mdefine"
    summary = "Define a new test machine"
    mandatory = "<machine> <site>"
    usage = """
    -c <cluster>
    -p <pool>
    -r <resourcestring>
    -f <flags>
    -d <description>
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'mdefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        details["machine"] = args[0]
        details["site"] = args[1]
        try:
            optlist, optx = getopt.getopt(args[2:], 'c:p:r:f:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-c':
                    details["cluster"] = value
                if flag == '-p':
                    details["pool"] = value
                if flag == '-r':
                    details["resources"] = value
                if flag == '-f':
                    details["flags"] = value
                if flag == '-d':
                    details["descr"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTMDefineXML(XenRTCommand):

    name = "mdefinexml"
    summary = "Define test machines from XML config files"
    mandatory = ""
    usage = """
    -s <site>
    """
    group = "Machine"

    def run(self, args):
        global _confdir

        site = None

        try:
            optlist, optx = getopt.getopt(args, 's:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-s':
                    site = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        if not site:
            # See if there is a CONFDIR/siteid file
            try:
                f = file("%s/siteid","r")
                site = f.read().strip()
                f.close()
            except:
                site = "DEFAULT"

        # Try and read in the XML files
        files = glob.glob("%s/machines/*.xml" % (_confdir))
        machines = []
        for filename in files:
            r = re.search(r"%s/machines/(.*)\.xml" % (_confdir), filename)
            if r:
                machine = r.group(1)
                machines.append(machine)

        for machine in machines:
            print "Adding machine %s" % (machine)
            xmd = XenRTMDefine(None)
            args = [machine,site]
            xmd.dispatch(args)

class XenRTMUndefine(XenRTCommand):

    name = "mundefine"
    summary = "Remove a machine from the system"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        details = {'action': 'mundefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["machine"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTCaseSet(XenRTCommand):

    name = "caseset"
    summary = "List a set of test cases"
    mandatory = "<set>"
    hide = True

    def run(self, args):
        details = {'action': 'caseset'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTCaseSets(XenRTCommand):

    name = "casesets"
    summary = "List all known casesets"
    hide = True

    def run(self, args):
        details = {'action': 'casesets'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            self.printout(results)
        return 0

class XenRTAddCase(XenRTCommand):

    name = "addcase"
    summary = "Add a test case to a set"
    mandatory = "<set>"
    usage = """
    -g <group>
    -c <testcase>
    -x <subgroup>
    -s <subcase>
    """
    hide = True

    def run(self, args):
        details = {'action': 'addcase'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'g:c:s:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-g':
                    details["tgroup"] = value
                if flag == '-c':
                    details["tcase"] = value
                if flag == '-x':
                    details["tcgroup"] = value
                if flag == '-s':
                    details["subtcase"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not details.has_key("tcase"):
            sys.stderr.write("Need a test case\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTDelCase(XenRTCommand):

    name = "delcase"
    summary = "Delete a test case from a set"
    mandatory = "<set>"
    usage = """
    -g <group>
    -c <testcase>
    -x <subgroup>
    -s <subcase>
    """
    hide = True

    def run(self, args):
        details = {'action': 'delcase'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["caseset"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'g:c:s:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-g':
                    details["tgroup"] = value
                if flag == '-c':
                    details["tcase"] = value
                if flag == '-x':
                    details["tcgroup"] = value
                if flag == '-s':
                    details["subtcase"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not details.has_key("tcase"):
            sys.stderr.write("Need a test case\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply


class XenRTInteract(XenRTCommand):

    name = "interact"
    summary = "Interact with a running job"
    mandatory = "{<jobid>|<host:port>}"
    usage = """
    [-l]               List running test cases
    [-c] <testcase>    Continue a paused testcase
    [-u] <testcase>    Continue a paused testcase without blocking on failure
    [-n] <testcase>    Abort a paused testcase
    [-x] <testcase>    Remove the automatic 24 hours unpause of a testcase
    [-C]               Continue any paused testcases
    [-N]               Abort any paused testcases
    [-R] <tcase>=<res> Set a testcase result (PASS|FAIL|ERROR|SKIPPED)
    [-D] <var>=<value> Set a config variable (var may be a /-separated split)
    [-d]               Dump config
    [-A]               Abort a run (after the current tests have completed)
    [-f]               Flush harness.err and harness.out log buffers
    [-I]               Display information about the hosts and guest
    [-r] <guest>:<filename>
                       Read a file from a named guest
    [-s]               Interactive shell
    [-L]               Show last 1000 log output lines
    """
    group = "Job"

    def run(self, args):

        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        if string.find(args[0], ":") > -1:
            hostport = args[0]
        else:
            try:
                id = string.atoi(args[0])
            except:
                details = {'action': 'machine'}
                details['USERID'] = pwd.getpwuid(os.getuid())[0]
                details["machine"] = args[0]
                u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                                   proxies=self.proxies)
                reply = None
                data = u.read()
                if data[0:5] == "ERROR":
                    sys.stderr.write(data)
                    return None
                else:
                    reply = self.parse_job(data)
                u.close()
                if not reply.has_key("JOBID"):
                    sys.stderr.write("Machine has no Job ID")
                    return None
                id = string.atoi(reply['JOBID'])
                 
            details = {'action': 'status'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["id"] = id
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            reply = None
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
            else:
                reply = self.parse_job(data)
            u.close()
            if not reply.has_key("XMLRPC"):
                sys.stderr.write("Job has no XMLRPC variable\n")
                return None
            hostport = reply["XMLRPC"]
        s = xmlrpclib.Server("http://%s" % (hostport))
        shell = False
        logger = False
        try:
            optlist, optx = getopt.getopt(args[1:], 'lc:CD:dAfIr:sLR:n:Nu:x:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-l':
                    for t in s.getRunningTests():
                        print "%-30s %s" % (t[0], t[1])
                elif flag == '-c':
                    s.setRunningStatus(value, "Continue")
                elif flag == '-u':
                    s.setBlockingStatus(value, False)
                    s.setRunningStatus(value, "Continue")
                elif flag == '-n':
                    s.setRunningStatus(value, "NotContinue")
                elif flag == '-x':
                    s.setRunningStatus(value, "Indefinite")
                elif flag == '-R':
                    l = string.split(value, '=')
                    testcase = l[0]
                    if l[1] == 'PASS':
                        result = 1
                    elif l[1] == 'FAIL':
                        result = 2
                    elif l[1] == 'ERROR':
                        result = 4
                    elif l[1] == 'SKIPPED':
                        result = 5
                    else:
                        sys.stderr.write("Unknown result '%s'" % (l[1]))
                        return None
                    s.setTestResult(testcase, result)
                elif flag == '-C':
                    for t in s.getRunningTests():
                        if t[1] == "Paused":
                            s.setRunningStatus(t[0], "Continue")
                elif flag == '-N':
                    for t in s.getRunningTests():
                        if t[1] == "Paused":
                            s.setRunningStatus(t[0], "NotContinue")
                elif flag == "-D":
                    try:
                        var, varval = string.split(value, "=", 1)
                        if string.find(var, "/") > -1:
                            var = string.split(var, "/")
                        s.setConfigVariable(var, varval)
                    except:
                        sys.stderr.write("Error parsing -D variable '%s'\n" %
                                         (value))
                        return None
                elif flag == "-d":
                    print s.dumpConfig()
                elif flag == "-A":
                    s.abortRun()
                elif flag == "-f":
                    s.flushLogs()
                elif flag == "-I":
                    hosts = s.getHostList()
                    for h in hosts:
                        info = s.getHostInfo(h)
                        print "Host: %s (%s)" % (info[0], info[1])
                    guests = s.getGuestList()
                    for g in guests:
                        info = s.getGuestInfo(g)
                        print "Guest: %s (%s) uuid=%s" % \
                              (info[0], info[1], info[5])
                elif flag == "-r":
                    ll = string.split(value, ":", 1)
                    if len(ll) != 2:
                        sys.stderr.write("Error parsing -r variable '%s'\n" %
                                         (value))
                        return None
                    data = s.getGuestFile(ll[0], ll[1])
                    sys.stdout.write(data.data)
                elif flag == "-s":
                    shell = True
                elif flag == "-L":
                    logger = True
                    
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None

        if shell:
            print "XenRT interactive Python shell."
            import readline
            while True:
                try:
                    command = raw_input(">>> ")
                    print s.xmlrpcShell(command)
                except EOFError, e:
                    print ""
                    break

        if logger:
            print string.join(s.xmlrpcLogger(), '')

class XenRTSList(XenRTCommand):

    name = "slist"
    summary = "Get a list of sites"
    usage = """
    [-p]             Show site properties
    [-q]             Quiet mode (don't show header)
    """
    group = "Site"

    def run(self, args):
        self.controller = False
        details = {'action': 'slist'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        try:
            optlist, optx = getopt.getopt(args, 'pq')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-q":
                    details["quiet"] = "yes"
                elif flag == "-p":
                    details["props"] = "yes"
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            if self.controller:
                reply = []
                lines = string.split(data, "\n")
                for l in lines:
                    if l != "":
                        reply.append(string.split(l,","))
            else:
                reply = data
        u.close()
        return reply

    def render(self, args, results):
        if results:
            if self.controller:
                for line in results:
                    self.printout("%s\n" % (string.join(line, ",")))
            else:
                self.printout(results)
        return 0

class XenRTSDefine(XenRTCommand):

    name = "sdefine"
    summary = "Define a new site"
    mandatory = "<site>"
    usage = """
    -f <flags>
    -d <description>
    """
    group = "Site"

    def run(self, args):
        details = {'action': 'sdefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["site"] = args[0]
        try:
            optlist, optx = getopt.getopt(args[1:], 'f:d:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '-f':
                    details["flags"] = value
                elif flag == '-d':
                    details["descr"] = value
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None        
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSUndefine(XenRTCommand):

    name = "sundefine"
    summary = "Remove a site from the system"
    mandatory = "<site>"
    group = "Site"

    def run(self, args):
        details = {'action': 'sundefine'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        details["site"] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSUpdate(XenRTCommand):

    name = "supdate"
    summary = "set/update a field of site data"
    mandatory = "<site> <field> <value>"
    group = "Site"

    def run(self, args):
        details = {'action': 'supdate'}
        if len(args) != 3:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        details[args[1]] = args[2]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = 1
        u.close()
        return reply

class XenRTSite(XenRTCommand):

    name = "site"
    summary = "Get data for the specified site"
    mandatory = "<site>"
    group = "Site"

    def run(self, args):
        details = {'action': 'site'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if len(args) != 1:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details["site"] = site
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        return reply

    def render(self, args, results):
        for key in results.keys():
            self.printout("%s='%s'\n" % (key, results[key]))
        return 0

class XenRTRunSuite(XenRTCommand):

    name = "runsuite"
    summary = "Run a test suite on a specified revision"
    mandatory = "<suite> <revision>"
    usage = """
    [-b <branch>]     Branch to test
    [-s <sku>]        SKU to test
    [-S <seqs>]       Suite sequences to run
    [-R]              Attempt to rerun if suite already exists
    [-v]              Verbose
    """
    group = "Suite"

    def findBuild(self):
        global _jenkins
        for i in range(20):
            time.sleep(5)
            j = json.load(urlopen_with_retry("%s/job/Suite%%20Run%%20Basic/api/json?depth=1" % _jenkins))
            for b in j['builds']:
                for a in b['actions']:
                    if a.has_key("parameters"):
                        for p in a['parameters']:
                            if p['name'] == "Cookie" and p['value'] == self.cookie:
                                self.build = b['url']
                                if self.verbose:
                                    print "Found Build %s" % self.build
                                return
            if self.verbose:
                print "Could not find build in job, retrying..."
        raise Exception("Could not find build")

    def waitForBuildCompletion(self):
        for i in range(30):
            j = json.load(urlopen_with_retry("%s/api/json" % self.build))
            if self.verbose:
                print "Building status: %s" % j['building']
            if not j['building']:
                if j['result'] != "SUCCESS":
                    # Find the failure reason if available
                    lines = urlopen_with_retry("%s/consoleText" % self.build)
                    reason = "Unknown"
                    for l in lines:
                        if l.startswith("REASON: "):
                            reason = l[8:].strip()
                            break
                    raise Exception("Could not start suite: %s (%s)" % (str(j['result']), reason))
                return
            time.sleep(10)

        raise Exception("Starting suite timed out")

    def getSuiteRunAndJobs(self):
        j = json.load(urlopen_with_retry("%s/api/json" % self.build))
        m = re.search("\((\d+)\)$", j['fullDisplayName'])
        if not m:
            raise Exception("Could not determine suite run number")
        sr = m.group(1)


        lines = urlopen_with_retry("%s/consoleText" % self.build)
        jobs = {}
        for l in lines:
            m = re.match("^Starting (\S+?)\.\.\. (\d+)$", l)
            if m:
                jobs[m.group(1)] = m.group(2)

        return (sr, jobs)

    def run(self, args):
        global _jenkins
        self.verbose = False
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        
        self.cookie = str(random.randint(0, 2**31-1))
        jenkins = {"Update Mercurial": "false",
                   "Additional_Args": "",
                   "Cookie": self.cookie,
                   "Attempt Rerun": "false"}

        jenkins['Suite'] = "/etc/xenrt/suites/%s" % args[0]
        jenkins['Version'] = args[1]
        if len(args) > 2:
            optlist, optx = getopt.getopt(args[2:], 'b:s:D:S:RV')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-b":
                    jenkins['Branch'] = value
                elif flag == "-s":
                    jenkins['sku'] = "/etc/xenrt/suites/%s" % value
                elif flag == "-S":
                    jenkins["Additional_Args"] += "--suite-seqs %s " % value
                elif flag == "-D":
                    jenkins["Additional_Args"] += "-D %s "% value
                elif flag == "-V":
                    self.verbose = True
                elif flag == "-R":
                    jenkins['Attempt Rerun'] = "true"
                    
        u = urlopen_with_retry("%s/job/Suite%%20Run%%20Basic/buildWithParameters" % _jenkins, urllib.urlencode(jenkins))
        u.close()
        if self.verbose:
            print "Suite submitted, finding build number..."
        self.findBuild()
        self.waitForBuildCompletion()
        (suite, jobs) = self.getSuiteRunAndJobs()

        reply = ["SR%s\n" % suite]
        for j in jobs.keys():
            reply.append("%s:%s\n" % (j, jobs[j]))
        return reply

    def render(self, args, results):
        for r in results:
            self.printout(r)
        return 0

class XenRTWarnings(XenRTCommand):

    name = "warnings"
    summary = "Display warnings or other data generated by a job or job group"
    usage = """
    [ -j <jobid> ]           query by job ID
    [ -g <jobgroup> ]        query by job group
    [ -k <key> ]             type of data to display, default is 'warning'
                             alternatives include 'comment' and 'data'
    """
    group = "Miscellaneous"

    def run(self, args):
        self.showsr = False
        details = {'action': 'warnings'}
        try:
            optlist, optx = getopt.getopt(args, 'j:g:k:')
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-j":
                    details["jobid"] = value
                elif flag == "-g":
                    details["jobgroup"] = value
                elif flag == "-k":
                    details["key"] = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = []
        error = 0
        while 1:
            line = u.readline()
            if not line:
                break
            if line[0:5] == "ERROR":
                sys.stderr.write(line)
                error = 1
            else:
                if line[-1] == "\n":
                    ll = string.split(line[:-1], "\t")
                else:
                    ll = string.split(line, "\t")
                reply.append(ll)
        u.close()
        if error:
            return None
        return reply

    def render(self, args, results):
        for ll in results:
            self.printout("%s %s %s\n" % (ll[0], ll[1], ll[2]))

class _XenRTControllerOperation(XenRTCommand):
    def getControllerAddrForMachine(self,machine,args):
        site = None
        self.overrideconsole = None
        try:
            optlist, optx = getopt.getopt(args, 's:',['override-console=', 'bootdev='])
            for argpair in optlist:
                (flag, value) = argpair
                if flag == "-s":
                    site = value
                elif flag == "--override-console":
                    self.overrideconsole = value
                elif flag == "--bootdev":
                    self.bootdev = value
                else:
                    sys.stderr.write("Unknown argument '%s'\n" % (flag))
                    return None
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        if not site:
            details = {'action': 'machine'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["machine"] = machine
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                               proxies=self.proxies)
            reply = None
            data = u.read()
            if data[0:5] == "ERROR":
                sys.stderr.write(data)
            else:
                reply = self.parse_job(data)
            u.close()
        
            if not reply.has_key("SITE"):
                return None
            site = reply["SITE"]
        return self.getControllerAddr(site)

    def getControllerAddr(self,site):
        details = {'action': 'site'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        details["site"] = site
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        if data[0:5] == "ERROR":
            sys.stderr.write(data)
        else:
            reply = self.parse_job(data)
        u.close()
        if reply.has_key("CTRLADDR"):
            return reply["CTRLADDR"] 
        return None
        
class XenRTSNetwork(_XenRTControllerOperation):
    name = "snetwork"
    summary = "Show network info for a site"
    mandatory = "<site>"
    group = "Site"
    
    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        site = args[0]
        details = {'action': 'network'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]

        addr = self.getControllerAddr(site)
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        self.printout(results)
        return 0

class XenRTMConfig(_XenRTControllerOperation):
    name = "mconfig"
    summary = "See config for a machine"
    mandatory = "<machine>"
    usage = """
    [ --generated ] See the generated config looked up from RackTables
    """
    group = "Machine"

    def run(self, args):
        details = {'action': 'mconfig'}
        if len(args) == 0:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        details["machine"] = machine
        try:
            optlist, optx = getopt.getopt(args[1:], '', "generated")
            for argpair in optlist:
                (flag, value) = argpair
                if flag == '--generated':
                    details["generated"] = "yes"
        except getopt.GetoptError:
            sys.stderr.write("Unknown argument\n")
            return None
        addr = self.getControllerAddrForMachine(machine, [])
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr  + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        reply = None
        data = u.read()
        u.close()
        return data
        
    def render(self, args, results):
        self.printout(results)
        return 0


class XenRTPower(_XenRTControllerOperation):

    name = "power"
    summary = "Power control a machine"
    mandatory = "<machine> off|on|reboot|nmi"
    group = "Machine"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        self.bootdev = None
        addr = self.getControllerAddrForMachine(machine, args[2:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {'action': 'power'}
        details['USERID'] = pwd.getpwuid(os.getuid())[0]
        if args[1] not in ["off", "on", "reboot", "nmi"]:
            sys.stderr.write("Invalid power operation - must be one of off, on or reboot\n")
            return None
        details["powerop"] = args[1]
        details["machine"] = machine
        if self.bootdev:
            details['bootdev'] = self.bootdev
        u = urlopen_with_retry("http://%s/share/control/queue.cgi" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        self.printout(results)
        return 0

class XenRTConsole(_XenRTControllerOperation):
    name = "console"
    summary = "Serial console for a machine"
    mandatory = "<machine>"
    group = "Machine"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        global _console
        global _conserver
        results = None
        console = os.popen("which console").read().strip()
        if console == "":
            console = _console
        machine = args[0]
        if machine == "-l":
            details = {'action': 'mlist2'}
            details['USERID'] = pwd.getpwuid(os.getuid())[0]
            details["controller"] = "yes"
            u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)

            machines = map(lambda x: x.split(",")[0], u.readlines())

            results = []

            for l in os.popen("%s -p 3109 -U -M %s -u" % (console, _conserver)).readlines():
                m = re.match(" (.+?)\s+(.+?)\s+(.+?)", l)
                if m:
                    if not m.group(1) in machines:
                        results.append(m.group(1))
        else:
            addr = self.getControllerAddrForMachine(machine, args[1:])
            if not addr:
                addr = _conserver
            if self.overrideconsole:
                console = self.overrideconsole
            if os.environ.get("SSH_CONSOLE") != "yes":
                os.system("%s -p 3109 -U -M %s %s" % (console, addr, machine.split(".")[0].split("_")[0]))
            else:
                out = re.sub("(\S{64}) ", "\\1\n", _conskey)
                out = re.sub("(-{5}) ", "\\1\n", out)
                out = re.sub(" (-{5})", "\n\\1", out)
                f = tempfile.NamedTemporaryFile()
                f.file.write(out)
                f.file.close()
                os.system("ssh -t -i %s -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o CheckHostIP=no cons@%s %s" % (f.name, addr, machine.split(".")[0].split("_")[0]))
        return results

    def render(self, args, results):
        if results:
            for line in results:
                self.printout("%s\n" % line)
        return 0

class XenRTGlobalResLock(XenRTCommand):
   
    name = "globalreslock"
    summary = "Lock a global resource (controller command)"
    mandatory = "<type> <jobid> <site>"
    group = "resources"

    def run(self, args):
        details = {'action': 'lockresource',
                   'type': args[0],
                   'job': args[1],
                   'site': args[2]}

        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details), proxies=self.proxies)

        ret = u.read()
        data = json.loads(ret)
        
        return data

    def render(self, args, results):
        if not 'name' in results.keys():
            sys.stderr.write("ERROR: Could not lock resource\n")
            return 1
        self.printout(json.dumps(results)+"\n")
        return 0

class XenRTGlobalResRelease(XenRTCommand):
    name = "globalresrelease"
    summary = "Release a global resource"
    mandatory = "<job id or resource name>"
    group = "resources"

    def run(self, args):
        details = {'action': 'releaseresource'}
        try:
            details['job'] = int(args[0])
        except:
            details['name'] = args[0]
        u = urlopen_with_retry(self.getServerURL() + "?" + urllib.urlencode(details),
                           proxies=self.proxies)

        data = u.read()

        if data[0:5] == "ERROR":
            reply = ""
            sys.stderr.write(data)
        else:
            reply = "OK"
        return reply

    def render(self, args, results):
        print results
        return 0

class XenRTMGetResource(_XenRTControllerOperation):
    name = "mgetresource"
    summary = "Get a controller resource for a machine"
    mandatory = "<machine> <resource type> [<args>]"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[2:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {"machine": args[0], "type": args[1]}
        if len(args) > 2:
            details['args'] = " ".join(args[2:])
        u = urlopen_with_retry("http://%s/xenrt/api/controller/getresource" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
class XenRTMListResources(_XenRTControllerOperation):
    name = "mlistresources"
    summary = "List controller resources for a machine"
    mandatory = "<machine>"

    def run(self, args):
        if len(args) < 1:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[1:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = {"machine": args[0]}
        u = urlopen_with_retry("http://%s/xenrt/api/controller/listresources" % addr + "?" + urllib.urlencode(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
class XenRTMReleaseResources(_XenRTControllerOperation):
    name = "mreleaseresources"
    summary = "Relase controller resources"
    mandatory = "<machine> [<resource1> <resource2>...]"

    def run(self, args):
        if len(args) < 2:
            sys.stderr.write("Invalid usage\n")
            return None
        machine = args[0]
        addr = self.getControllerAddrForMachine(machine, args[1:])
        if not addr:
            sys.stderr.write("Controller for machine %s not found\n" % machine)
            return None
        details = []
        for r in args[1:]:
            details.append("resource=%s" % r)
        
        u = urlopen_with_retry("http://%s/xenrt/api/controller/releaseresources" % addr + "?" + "&".join(details),
                           proxies=self.proxies)
        data = u.read()
        return data

    def render(self, args, results):
        print results
        return 0
        
#############################################################################

class Commands:

    def __init__(self, outfd=sys.stdout, raw=0):
        self.outfd = outfd
        self.raw = raw
        self.commands = {}
        self.add(XenRTSubmit)
        self.add(XenRTRun)
        self.add(XenRTStatus)
        self.add(XenRTHelp)
        self.add(XenRTComplete)
        self.add(XenRTEmail)
        self.add(XenRTList)
        self.add(XenRTUpdate)
        self.add(XenRTUpload)
        self.add(XenRTDownload)
        self.add(XenRTRemove)
        self.add(XenRTSetResult)
        self.add(XenRTLogData)
        self.add(XenRTShowLog)
        self.add(XenRTJobGroup)
        self.add(XenRTMachine)
        self.add(XenRTMList)
        self.add(XenRTMConfig)
        self.add(XenRTMList2)
        self.add(XenRTMUpdate)
        self.add(XenRTBorrow)
        self.add(XenRTReturn)
        self.add(XenRTEvent)
        self.add(XenRTPool)
        self.add(XenRTProp)
        self.add(XenRTMRes)
        self.add(XenRTMBroken)
        self.add(XenRTMFixed)
        self.add(XenRTSFlag)
        self.add(XenRTUtilisation)
        self.add(XenRTMStatus)
        self.add(XenRTSchedule)
        self.add(XenRTMDefine)
        self.add(XenRTMDefineXML)
        self.add(XenRTMUndefine)
        self.add(XenRTCaseSet)
        self.add(XenRTCaseSets)
        self.add(XenRTAddCase)
        self.add(XenRTDelCase)
        self.add(XenRTSubResults)
        self.add(XenRTInteract)
        self.add(XenRTPerfData)
        self.add(XenRTMakeTickets)
        self.add(XenRTSuiteStatus)
        self.add(XenRTDetailID)
        self.add(XenRTSList)
        self.add(XenRTSDefine)
        self.add(XenRTSUndefine)
        self.add(XenRTSUpdate)
        self.add(XenRTSite)
        self.add(XenRTRunSuite)
        self.add(XenRTWarnings)
        self.add(XenRTRerun)
        self.add(XenRTPower)
        self.add(XenRTSNetwork)
        self.add(XenRTConsole)
        self.add(XenRTGlobalResLock)
        self.add(XenRTGlobalResRelease)
        self.add(XenRTMGetResource)
        self.add(XenRTMListResources)
        self.add(XenRTMReleaseResources)
        self.add(XenRTLogServer)

    def add(self, cl):
        c = cl(self)
        self.commands[c.name] = c

    def has(self, command):
        return self.commands.has_key(command)

    def run(self, command, args):
        return self.commands[command].dispatch(args, raw=self.raw)

    def getall(self):
        return self.commands.values()

    def setProxies(self, proxies):
        for c in self.commands.values():
            c.proxies = proxies

#############################################################################

def xenrt_profile_stats():
    global XRTPROF_FILENAME
    global XRTPROF

    XRTPROF.close()
    
    stats = hotshot.stats.load(XRTPROF_FILENAME)
    stats.strip_dirs()
    stats.sort_stats('time', 'calls')
    stats.print_stats(120)


if __name__ == '__main__':
    if PROFILER_ENABLED:
	import hotshot
    	import hotshot.stats
	import atexit

    	XRTPROF = hotshot.Profile(XRTPROF_FILENAME)
        atexit.register(xenrt_profile_stats)

    com = Commands(raw=0)

    # Dirty hack to use the JOBSERVER_PROXY variable
    if os.path.exists("/etc/xenrt/site.xml"):
        f = file("/etc/xenrt/site.xml", "r")
        data = f.read()
        f.close()
        r = re.search("<JOBSERVER_PROXY>(http:.*?)<\/JOBSERVER_PROXY>", data)
        if r:
            com.setProxies({'http': r.group(1)})

    if len(sys.argv) < 2:
        sys.stderr.write("Usage: %s <command> [options]\n" % (sys.argv[0]))
        sys.stderr.write("  run '%s help' for a list of commands\n" % \
                         (sys.argv[0]))
        sys.exit(1)

    if com.has(sys.argv[1]):
    	if PROFILER_ENABLED:
        	rc = XRTPROF.runcall(com.run, sys.argv[1], sys.argv[2:])
	else:
		rc = com.run(sys.argv[1], sys.argv[2:])
        if com.raw:
            if rc:
                print rc
                sys.exit(0)
            sys.exit(1)
        sys.exit(rc)

    if sys.argv[1] == '--help':
        sys.exit(com.run("help", sys.argv[2:]))
        
    sys.stderr.write("Command '%s' not recognised.\n" % (sys.argv[1]))
    sys.stderr.write("  run '%s help' for a list of commands\n" %
                     (sys.argv[0]))
    sys.exit(1)
    

