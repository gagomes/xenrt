from testing import XenRTUnitTestCase
from mock import Mock, patch
from xenrt.objects import GenericGuest
import xenrt

class TestIsGPUBeingUtilized(XenRTUnitTestCase):
    
    # maybe consts.
    ubuntu = "ubuntu1404"
    centos = "centos7"
    rhel = "rhel7"
    oel = "oel7"
    windows = "win7x64"

    lspciGrepGood = """00:05.0 VGA compatible controller: NVIDIA Corporation GF104GLM [Quadro 3000M] (rev a1)
00:06.0 Audio device: NVIDIA Corporation GF104 High Definition Audio Controller (rev a1)"""
    lspciGrepBad = "" # Throws an exception.

    lspciSerialGood = """00:05.0 VGA compatible controller: NVIDIA Corporation GF104GLM [Quadro 3000M] (rev a1) (prog-if 00 [VGA controller])
        Subsystem: Hewlett-Packard Company Device 0851
        Physical Slot: 5
        Flags: bus master, fast devsel, latency 0, IRQ 81
        Memory at ec000000 (32-bit, non-prefetchable) [size=32M]
        Memory at e0000000 (64-bit, prefetchable) [size=128M]
        Memory at e8000000 (64-bit, prefetchable) [size=64M]
        I/O ports at c200 [size=128]
        Expansion ROM at ef800000 [disabled] [size=512K]
        Capabilities: [60] Power Management version 3
        Capabilities: [68] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Capabilities: [78] Express Endpoint, MSI 00
        Capabilities: [b4] Vendor Specific Information: Len=14 <?>
        Kernel driver in use: nouveau

"""
    lspciSerialBad = """00:05.0 VGA compatible controller: NVIDIA Corporation GF104GLM [Quadro 3000M] (rev a1) (prog-if 00 [VGA controller])
        Subsystem: Hewlett-Packard Company Device 0851
        Physical Slot: 5
        Flags: bus master, fast devsel, latency 0, IRQ 81
        Memory at ec000000 (32-bit, non-prefetchable) [size=32M]
        Memory at e0000000 (64-bit, prefetchable) [size=128M]
        Memory at e8000000 (64-bit, prefetchable) [size=64M]
        I/O ports at c200 [size=128]
        Expansion ROM at ef800000 [disabled] [size=512K]
        Capabilities: [60] Power Management version 3
        Capabilities: [68] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Capabilities: [78] Express Endpoint, MSI 00
        Capabilities: [b4] Vendor Specific Information: Len=14 <?>

"""

    lshwGood = """<?xml version="1.0" standalone="yes" ?>
<!-- generated by lshw-B.02.16 -->
<!-- GCC 4.8.2 -->
<!-- Linux 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 -->
<!-- GNU libc 2 (glibc 2.19) -->
<list>
  <node id="display:0" class="display" handle="PCI:0000:00:02.0">
   <description>VGA compatible controller</description>
   <physid>2</physid>
   <businfo>pci@0000:00:02.0</businfo>
   <version>00</version>
   <width units="bits">32</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
   </capabilities>
   <resources>
    <resource type="memory" value="ef000000-ef7fffff" />
   </resources>
  </node>
  <node id="display:1" claimed="true" class="display" handle="PCI:0000:00:05.0">
   <description>VGA compatible controller</description>
   <product>GF104GLM [Quadro 3000M]</product>
   <vendor>NVIDIA Corporation</vendor>
   <physid>5</physid>
   <businfo>pci@0000:00:05.0</businfo>
   <version>a1</version>
   <width units="bits">64</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="driver" value="nouveau" />
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="pm" >Power Management</capability>
    <capability id="msi" >Message Signalled Interrupts</capability>
    <capability id="pciexpress" >PCI Express</capability>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
    <capability id="cap_list" >PCI capabilities listing</capability>
    <capability id="rom" >extension ROM</capability>
   </capabilities>
   <resources>
    <resource type="irq" value="81" />
    <resource type="memory" value="ec000000-edffffff" />
    <resource type="memory" value="e0000000-e7ffffff" />
    <resource type="memory" value="e8000000-ebffffff" />
    <resource type="ioport" value="c200(size=128)" />
    <resource type="memory" value="ef800000-ef87ffff" />
   </resources>
  </node>
</list>
"""
    lshwBad  = """<?xml version="1.0" standalone="yes" ?>
<!-- generated by lshw-B.02.16 -->
<!-- GCC 4.8.2 -->
<!-- Linux 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 -->
<!-- GNU libc 2 (glibc 2.19) -->
<list>
  <node id="display:0" class="display" handle="PCI:0000:00:02.0">
   <description>VGA compatible controller</description>
   <physid>2</physid>
   <businfo>pci@0000:00:02.0</businfo>
   <version>00</version>
   <width units="bits">32</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
   </capabilities>
   <resources>
    <resource type="memory" value="ef000000-ef7fffff" />
   </resources>
  </node>
  <node id="display:1" class="display" handle="PCI:0000:00:05.0">
   <description>VGA compatible controller</description>
   <product>GF104GLM [Quadro 3000M]</product>
   <vendor>NVIDIA Corporation</vendor>
   <physid>5</physid>
   <businfo>pci@0000:00:05.0</businfo>
   <version>a1</version>
   <width units="bits">64</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="driver" value="nouveau" />
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="pm" >Power Management</capability>
    <capability id="msi" >Message Signalled Interrupts</capability>
    <capability id="pciexpress" >PCI Express</capability>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
    <capability id="cap_list" >PCI capabilities listing</capability>
    <capability id="rom" >extension ROM</capability>
   </capabilities>
   <resources>
    <resource type="irq" value="81" />
    <resource type="memory" value="ec000000-edffffff" />
    <resource type="memory" value="e0000000-e7ffffff" />
    <resource type="memory" value="e8000000-ebffffff" />
    <resource type="ioport" value="c200(size=128)" />
    <resource type="memory" value="ef800000-ef87ffff" />
   </resources>
  </node>
</list>
"""
    lshwBadAlt  = """<?xml version="1.0" standalone="yes" ?>
<!-- generated by lshw-B.02.16 -->
<!-- GCC 4.8.2 -->
<!-- Linux 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 -->
<!-- GNU libc 2 (glibc 2.19) -->
<list>
  <node id="display:0" class="display" handle="PCI:0000:00:02.0">
   <description>VGA compatible controller</description>
   <physid>2</physid>
   <businfo>pci@0000:00:02.0</businfo>
   <version>00</version>
   <width units="bits">32</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
   </capabilities>
   <resources>
    <resource type="memory" value="ef000000-ef7fffff" />
   </resources>
  </node>
  <node id="display:1" claimed="false" class="display" handle="PCI:0000:00:05.0">
   <description>VGA compatible controller</description>
   <product>GF104GLM [Quadro 3000M]</product>
   <vendor>NVIDIA Corporation</vendor>
   <physid>5</physid>
   <businfo>pci@0000:00:05.0</businfo>
   <version>a1</version>
   <width units="bits">64</width>
   <clock units="Hz">33000000</clock>
   <configuration>
    <setting id="driver" value="nouveau" />
    <setting id="latency" value="0" />
   </configuration>
   <capabilities>
    <capability id="pm" >Power Management</capability>
    <capability id="msi" >Message Signalled Interrupts</capability>
    <capability id="pciexpress" >PCI Express</capability>
    <capability id="vga_controller" />
    <capability id="bus_master" >bus mastering</capability>
    <capability id="cap_list" >PCI capabilities listing</capability>
    <capability id="rom" >extension ROM</capability>
   </capabilities>
   <resources>
    <resource type="irq" value="81" />
    <resource type="memory" value="ec000000-edffffff" />
    <resource type="memory" value="e0000000-e7ffffff" />
    <resource type="memory" value="e8000000-ebffffff" />
    <resource type="ioport" value="c200(size=128)" />
    <resource type="memory" value="ef800000-ef87ffff" />
   </resources>
  </node>
</list>
"""

    gpuType = "NVIDIA"
    serial = "00:05.0"

    def lspciGrepFail(self, *args, **kwargs):
        if args[0] == "lspci | grep %s" % self.gpuType:
            raise Exception() # Throws an exception when nothing returns from grep. Not sure what kind. It just catches all though.
        elif args[0] == "lspci -v -s %s" % self.serial:
            return self.lspciSerialGood
        elif args[0] == "lshw -xml -c video":
            return self.lshwGood

    def lspciSerialFail(self, *args, **kwargs):
        if args[0] == "lspci | grep %s" % self.gpuType:
            return self.lspciGrepGood
        elif args[0] == "lspci -v -s %s" % self.serial:
            return self.lspciSerialBad
        elif args[0] == "lshw -xml -c video":
            return self.lshwGood

    def lshwFail(self, *args, **kwargs):
        if args[0] == "lspci | grep %s" % self.gpuType:
            return self.lspciGrepGood
        elif args[0] == "lspci -v -s %s" % self.serial:
            return self.lspciSerialGood
        elif args[0] == "lshw -xml -c video":
            return self.lshwBad

    def lshwFailAlt(self, *args, **kwargs):
        if args[0] == "lspci | grep %s" % self.gpuType:
            return self.lspciGrepGood
        elif args[0] == "lspci -v -s %s" % self.serial:
            return self.lspciSerialGood
        elif args[0] == "lshw -xml -c video":
            return self.lshwBadAlt

    def allPass(self, *args, **kwargs):
        if args[0] == "lspci | grep %s" % self.gpuType:
            return self.lspciGrepGood
        elif args[0] == "lspci -v -s %s" % self.serial:
            return self.lspciSerialGood
        elif args[0] == "lshw -xml -c video":
            return self.lshwGood

    # Covers the standard positive scenarios.
    @patch('xenrt.TEC')
    def testUbuntu(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.allPass)

        self.assertTrue(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testRHEL(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.rhel
        guest.execguest = Mock(side_effect=self.allPass)

        self.assertTrue(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testCentos(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.centos
        guest.execguest = Mock(side_effect=self.allPass)

        self.assertTrue(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testOEL(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.oel
        guest.execguest = Mock(side_effect=self.allPass)

        self.assertTrue(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testWindows(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.windows
        guest.execguest = Mock(side_effect=self.allPass)

        self.assertRaises(xenrt.XRTError, guest.isGPUBeingUtilized, self.gpuType)


    @patch('xenrt.TEC')
    def testInvalidLspciGrep(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lspciGrepFail)

        self.assertFalse(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testInvalidLspciSerial(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lspciSerialFail)

        self.assertFalse(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testInvalidLshw(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lshwFail)

        self.assertFalse(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testInvalidLshwAlt(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lshwFailAlt)

        self.assertFalse(guest.isGPUBeingUtilized(self.gpuType))

    @patch('xenrt.TEC')
    def testNoneGpuType(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lspciGrepFail)

        self.assertFalse(guest.isGPUBeingUtilized(None))

    @patch('xenrt.TEC')
    def testEmptyGpuType(self, tec):
        guest = GenericGuest("Fake")
        guest.distro = self.ubuntu
        guest.execguest = Mock(side_effect=self.lspciGrepFail)

        self.assertFalse(guest.isGPUBeingUtilized(""))